* * *

# Создание бизнес-приложений с REBOL

> ** By: Nick Antonaccio  
Обновлено: 12-16-2015  
Научитесь решать типовые проблемы управления бизнес-данными с помощью гибкого инструмента разработки, достаточно простого для непрограммистов.  
** Рекомендуется сначала прочесть http://re-bol.com/rebol_quick_start.html и попробовать конструктор приложений http://withoutwritingcode.com для быстрого ознакомления с программированием на Rebol. Затем вернитесь к чтению этого текста для более полного взгляда на все возможности Rebol.  
Также не забудьте посмотреть короткие примеры на http://re-bol.com/short_rebol_examples.r для быстрого и интересного обзора простого/продуктивного стиля кодирования на Rebol.  
Смотрите http://re-bol.com/examples.txt где много других примеров кода на Rebol.  
На форуме http://rebolforum.com можно задавать вопросы.  
Также посмотрите 68 видео на YouTube с видеоуроками REBOL (10 часов видео).  
Предыдущее введение к этому тексту было удалено. Оно доступно здесь и краткая версия здесь.
Презентация, охватывающая предыдущее введение доступна здесь. **

## Содержание:

1\. Ускоренный курс введения в REBOL  
1.1 Установка и запуск программ  
1.2 Открытие REBOL прямо в консоли
1.3 Несколько кратких примеров кода для разжигания аппетита
1.4 Основы кодирования на REBOL
1.5 Условные оценки
1.6 Ещё больше полезных функций
2\. Lists, Tables, and the "Foreach" Function  
2.1 Managing Spreadsheet-Like Data  
2.2 Some Simple List Algorithms (Count, Sum, Average, Max/Min)  
2.3 Searching  
2.4 Gathering Data, and the "Copy" Function  
2.5 List Comparison Functions  
2.6 Creating Lists From User Input  
2.7 Three Useful Data Storage Programs: Inventory, Contacts, Schedule  
2.8 Working With Tables of Data: Columns and Rows  
2.9 Additional List/Block/Series Functions and Techniques  
2.10 Sorting Lists and Tables of Data  
2.11 CSV Files and the "Parse" Function  
2.12 Two Paypal Report Programs, Analyzed  
2.13 Some Perspective about Studying These Topics  
3\. Using GUI Windows and Widgets to Input and Display Data  
3.1 Basic Layout Guidelines and Widgets  
3.2 Breathing Life Into GUI Programs - Performing Actions  
3.3 GUI Language Reference  
3.4 A Telling Comparison  
4\. Quick Review and Clarification  
5\. SOME COMPLETE GUI APPLICATION EXAMPLES  
5.1 Generic Text Field Saver  
5.2 Calculator  
5.3 File Editor  
5.4 Web Page Editor  
5.5 Inventory List Creator  
5.6 Inventory Sorter and Viewer  
5.7 Contacts Viewer  
5.8 Minimal Retail Cash Register and Sales Report System  
5.9 Email  
5.10 Scheduler  
5.11 Parts Database  
5.12 Time Clock and Payroll Report  
5.13 Blogger  
5.14 FTP Group Chat  
5.15 Group Reminder  
5.16 A Univeral Report Generator, For Paypal and any other CSV Table Data  
5.17 Reviewing and Using the Code You've Seen To Model New Applications  
6\. User Defined Functions and Imported Code Modules  
6.1 "Do", "Does", and "Func"  
6.2 Return Values  
6.3 Scope  
6.4 Function Documentation  
6.5 Doing Imported Code  
6.6 Separating Form and Function in GUIs - The Check Writer App  
6.7 A Full Featured Group Note Sharing App  
7\. A Few Useful Data Visualization Tools  
7.1 Displaying and Sorting Data Using Spreadsheet-Like GUI Grids  
7.2 Creating Graphs, Plots, and Charts with "Q-Plot"  
7.3 Drawing Charts Using Raw GUI Code  
7.4 Creating 3D Graphs With r3D  
7.5 Using the Google Chart API  
7.6 Using the "Nano-Sheets" Spreadsheet App  
8\. Using REBOL to Create Presentations  
8.1 REBOL as Presentation Software  
8.2 Some Basic Layout Ideas and a Simple Code Framework for Presentations  
8.3 Using Tab Panels and Menus to Present Information  
8.4 Show.r - A Useful Line-By-Line Presentation System  
8.5 Creating "Screen Shot" Images of GUIs  
8.6 Embedding Binary Resources (images, sounds, files etc.) in Code  
8.7 Playing Sounds  
8.8 Launching Code in Separate Processes  
8.9 Running Command Line Applications  
8.10 Creating Simple Animations  
8.11 A Simple Animation Framework for Presentations  
8.12 Using Animated GIF Images  
8.13 And That's Just the Beginning  
9\. Makedoc And Other Useful REBOL Productivity Tools  
9.1 Makedoc.r - HTML Document Builder  
9.2 An Improved Text Editor  
9.3 GUI Builders and Learning Tools  
10\. Real World Concerns and Examples: Why "Programming" > Office Software  
10.1 An Expanded Inventory Program  
10.2 Receipt Printer  
10.3 Advanced Time Clock and Automated Payroll Reports  
11\. More REBOL Language Fundamentals  
11.1 Comments  
11.2 Function Refinements  
11.3 White Space and Indentation  
11.4 Multi Line Strings, Quotes, and Concatenation  
11.5 More About Variables  
11.6 Data Types  
11.7 Random Values  
11.8 More About Reading, Writing, Loading, and Saving to and from Varied Sources  
11.9 Understanding Return Values and the Order of Evaluation  
11.10 More About Conditional Evaluations  
11.11 More About Loops  
11.12 More About Why/How Blocks are Useful  
11.13 REBOL Strings  
12\. More Essential Topics  
12.1 Built-In Help and Online Resources  
12.2 Saving and Running REBOL Scripts  
12.3 "Compiling" REBOL Programs - Distributing Packaged .EXE Files  
12.4 Common REBOL Errors, and How to Fix Them  
13\. Creating Web Applications using REBOL CGI  
13.1 An HTML Crash Course  
13.2 A Standard CGI Template to Memorize  
14\. Example CGI Applications  
14.1 Form Mail  
14.2 A Generic Drop Down List Application  
14.3 Photo Album  
14.4 Simple Interactive REBOL Web Site Console  
14.5 Attendance  
14.6 Bulletin Board  
14.7 GET vs POST Example  
14.8 Group Note System  
14.9 Generic Form Handler  
14.10 File Uploader  
14.11 File Downloader  
14.12 A Complete Web Server Management Application  
14.13 The RebolForum.com CGI Code  
14.14 Etsy Account Manager  
14.15 A Note About Working With Web Servers  
14.16 WAP - Cell Phone Browser CGI Apps (deprecated)  
15\. Organizing Efficient Data Structures and Algorithms  
15.1 A Simple Loop Example  
15.2 A Real Life Example: Checkout Register and Cashier Report System  
16\. Additional Topics  
16.1 Objects  
16.2 Ports - Fine Grained Access to Files, Email, Network and More  
16.3 Console and CGI Email Apps Using Ports  
16.4 Network Ports - Transferring Data and Files with HTTP  
16.5 Transferring Binary Files Through TCP Network Sockets  
16.6 Transferring Data Through UDP Network Ports  
16.7 Parse (REBOL's Answer to Regular Expressions)  
16.8 Using Parse to Load Speadsheet CSV Files and Other Structured Data  
16.9 Using Parse's Pattern Matching Mode to Search Data  
16.10 Responding to Special Events in a GUI - "Feel"  
16.11 2D Drawing, Graphics, and Animation  
16.12 3D Graphics with r3D  
16.13 Several 3D Scripts Using Raw REBOL Draw Dialect  
16.14 Sprite Sheets  
16.15 Multitasking  
16.16 Using DLLs and Shared Code Files in REBOL  
16.17 A Multiple Network Security Camera App Using The Window's Webcam DLL  
16.18 REBOL as a Browser Plugin  
16.19 Using Databases  
16.20 Menus  
16.21 Creating Multi Column GUI Text Lists (Data Grids) From Scratch  
16.22 RebGUI  
16.23 RebGUI Apps - Spreadsheet, Rolodex, Member Manager, Editor, POS system  
16.24 Creating PDF files using pdf-maker.r  
16.25 Bar Codes  
16.26 Creating .swf Files with REBOL/Flash  
16.27 Printing With REBOL  
16.28 A Remote Check Printing Application  
16.29 Creating Apps on Platforms That Don't Support GUI Interfaces  
16.30 Encryption and Security  
16.31 Rebcode  
16.32 Useful REBOL Tools: XML, Zip, Database, Network, Web Server, and More  
16.33 6 REBOL Flavors  
16.34 Bindology, Dialects, Metaprogramming and Other Advanced Topics  
17\. REBOL on Android, Open Source R3 (Saphirion Builds), and RED  
17.1 Open Source  
17.2 Creating an Android Working Environment - Necessary Tools  
17.3 R3 GUI Basics  
17.4 Simple Requestors  
17.5 Layout  
17.6 Styles  
17.7 Some More Simple Examples  
17.8 Additional Essential Resources  
17.9 RED  
18\. Implementing Multi-User Data Management Applications with Rebol  
18.1 Multi-User Database Systems In Rebol  
18.2 The Typical REBOL 101 Example  
18.3 Multi-User Databases  
18.4 A Longer Example  
18.5 Obtaining Dynamically Assigned Server Addresses  
18.6 Serving Clients HTML Form Interfaces  
18.7 Simplicity  
19\. Building Mobile and Web Apps with jsLinb & Sigma Visual Builder  
19.1 What are the jsLinb Library and Sigma Visual Builder?  
19.2 Installing Sigma Builder on a Web Server  
19.3 Basic jsLinb Code and Sigma IDE Examples  
19.4 Connecting jsLinb Apps to Rebol CGI Server Applications  
19.5 Example Apps made with jsLinb and Rebol CGI Code  
19.6 Saving and Deploying your jsLinb Apps in Sigma IDE  
19.7 Some Data Grid Examples  
19.8 Powerful Layout Widgets  
19.9 jsLinb and Sigma Builder Documentation Features  
19.10 Using the jsLinb Databinder to Collect and Set Form Data  
19.11 A Larger Example App  
19.12 Connecting to Stand-Alone Rebol Server Apps  
19.13 CrossUI  
19.14 A Powerful Addition to the Rebol Toolkit  
20\. REAL WORLD CASE STUDIES - Learning To Think In Code  
20.1 Case: Scheduling Teachers  
20.2 Case: A Simple Image Gallery CGI Program  
20.3 Case: Days Between Two Dates Calculator  
20.4 Case: Simple Search  
20.5 Case: A Simple Calculator Application  
20.6 Case: A Backup Music Generator (Chord Accompaniment Player)  
20.7 Case: FTP Tool  
20.8 Case: The "Jeoparody" Training Program  
20.9 Case: Scheduling Teachers, Part Two  
20.10 Case: An Online Member Page CGI Program  
20.11 Case: A CGI Event Calendar  
20.12 Case: Media Player (Wave/Mp3 Jukebox)  
20.13 Case: Guitar Chord Chart Printer  
20.14 Case: Web Site Content Management System (CMS), Sitebuilder.cgi  
20.15 Case: Downloading Directories - A Server Spidering App  
20.16 Case: Vegetable Gardening  
20.17 Case: An Additional Teacher Automation Project  
21\. Game Programming to Improve Algorithmic Thought and Graphic Skills  
21.1 Case: More About Creative Algorithmic Thought: a Tetris Clone  
21.2 Case: More Full Program Loops: Ski, Snake, and Invaders  
21.3 Case: A GUI Playing Card Framework (Creating a Freecell Clone)  
21.4 Case: Creating the REBOL "Demo"  
22\. Other Scripts  
22.1 Thumbnail Maker  
22.2 Loops and Conditions - A Simple Data Storage App  
22.3 Listview Multi Column Data Grid Example  
22.4 Image Effector  
22.5 Little Menu Example  
22.6 Shoot-Em-Up Video Game  
22.7 Bingo Board  
22.8 Voice Alarms  
22.9 Odds and Ends  
23\. Learning More About REBOL - Important Documentation Links  
24\. Beyond REBOL  
25\. About The Author  
25.1 My Businesses  
25.2 Client List and Previous Experience  
25.3 Contact Me  


## 1\. A Crash Course Introduction to REBOL

> ### 1.1 Installing and Running Programs

> To get started, download and install REBOL/View from http://www.rebol.com/download-view.html (it takes just a few seconds).
> 
> Once it's installed, run REBOL (Start -> Programs -> REBOL -> REBOL View), then click the "Console" Icon.
> 
> Type "editor none" at the prompt - that will run REBOL's built in text editor.
> 
> At this point, you are ready to start typing in REBOL programs. Copy/paste each example from this tutorial into the REBOL editor to see what the code does. Try it right now. Paste the following code into the REBOL editor, then press [F5] on your keyboard to save and run the program. You can save the file using the default "temp.txt" file name, as prompted, or rename it if you'd like. If you see the REBOL security requestor, select "Allow all":
>     
>     
>     REBOL []
>     alert "Hello World!"
>     
> 
> If you save your program with a ".r" extension in the file name (i.e., "myprogram.r"), then you can also click your saved program's file icon, and it will run just like any normal executable (.exe) file. Try saving the program above on your desktop as "hello.r", then run it by clicking the hello.r icon on your desktop with your mouse.

### 1.2 Opening REBOL Directly to the Console

> Before typing in or pasting any more code, adjust the following option in the REBOL interpreter: click the "User" menu in the graphic _Viewtop_ that opens by default with REBOL, and uncheck "Open Desktop On Startup". That'll save you the trouble of clicking the "Console" button every time you start REBOL.
> 
> Setting your email account information and other user settings, is also recommended at this point.

### 1.3 Some Short Code Examples to Whet Your Appetite

> Here are some REBOL program examples which demonstrate the simple and concise nature of REBOL code. Paste each program into the REBOL editor and press [F5] to see it run. Read briefly through each line of the programs to familiarize yourself with what REBOL code looks like. You'll understand exactly how everything works, very shortly.
> 
> Here's a short and useful example that saves text field data to a text file. It can be used as the basis for entering and saving categorical units of data of almost every type, for receipts, notes, etc.
>     
>     
>     REBOL [title: "Text Field Saver"]
>     view layout [
>         f1: field
>         f2: field
>         f3: field
>         btn "Save Fields" [
>             write/append %fields.csv rejoin [
>                 mold f1/text ", " mold f2/text ", " mold f3/text newline
>             ]
>             alert "Added to File"
>         ]
>     ]
>     
> 
> Here's an example of a text editor program that allows you to read, edit, and save any text file:
>     
>     
>     REBOL [title: "Text Editor"]
>     view layout [
>         h1 "Text Editor:"
>         f: field 600 "filename.txt"
>         a: area 600x350 
>         across 
>         btn "Load" [
>             f/text: request-file
>             show f
>             filename: to-file f/text
>             a/text: read filename 
>             show a
>         ]
>         btn "Save" [
>             filename: to-file request-file/save/file f/text
>             write filename a/text
>             alert "Saved"
>         ]
>     ]
>     
> 
> Here's a variation of the program above, repurposed as a web page editor (this program can actually be used to edit real, live web pages on the Internet):
>     
>     
>     REBOL [title: "Web Page Editor"]
>     view layout [
>         h1 "Web Page Editor:"
>         f: field 600 "ftp://user:pass@site.com/public_html/page.html"
>         a: area 600x350 
>         across 
>         btn "Load" [
>             a/text: read to-url f/text 
>             show a
>         ]
>         btn "Save" [
>             write (to-url f/text) a/text
>             alert "Saved"
>         ]
>     ]
>     
> 
> Here's a basic calculator app:
>     
>     
>     REBOL [title: "Calculator"]
>     view layout [
>         origin 0  space 0x0  across
>         style btn btn 50x50 [append f/text face/text  show f]
>         f: field 200x40 font-size 20 return
>         btn "1"  btn "2"  btn "3"  btn " + "  return
>         btn "4"  btn "5"  btn "6"  btn " - "  return
>         btn "7"  btn "8"  btn "9"  btn " * "  return
>         btn "0"  btn "."  btn " / "   btn "=" [
>             attempt [f/text: form do f/text  show f]
>         ]
>     ]
>     
> 
> Here's a variation of the Paypal example from this tutorial's introduction. It downloads a Paypal account file from the web and reports the sum of all gross account transactions, displays all purchases made from the name "Saoud Gorn", and computes the total of all transactions from "Ourliptef.com" which occured between midnight and noon hours. Try running it on a computer that's connected to the Internet:
>     
>     
>     REBOL [title: "Paypal Reports"]
>     sum1: sum2: $0
>     foreach line at read/lines http://re-bol.com/Download.csv 2 [
>         sum1: sum1 + to-money pick row: parse/all line "," 8
>         if find row/4 "Saoud" [print rejoin [row/1 ", Saoud Gorn: " row/8]]
>         if find row/4 "Ourliptef.com" [
>             if (0:00am <= time: to-time row/2) and (time <= 12:00pm) [
>                 sum2: sum2 + to-money row/8
>             ]
>         ]
>     ]
>     alert join "GROSS ACCOUNT TRANSACTIONS: " sum1
>     alert join "2012 Ourliptef.com Morning Total: " sum2
>     
> 
> This example extends the reports above with graphs of the collected data (Internet connection required for this example too):
>     
>     
>     REBOL [title: "Paypal Report Charts"]
>     transactions: copy []
>     saoud: copy []
>     dates: copy []
>     foreach line at read/lines http://re-bol.com/Download.csv 2 [
>         row: parse/all line ","
>         append transactions to-integer row/8
>         if find row/4 "Saoud" [
>             append saoud to-integer row/8
>             append dates replace row/1 "/2012" ""
>         ]
>     ]
>     if not exists? %q-plot.r [write %q-plot.r read http://re-bol.com/q-plot.r]
>     do %q-plot.r
>     view center-face quick-plot [
>         594x400
>         bars [(data: copy transactions)]
>         label "All Paypal Transactions"
>     ]
>     view center-face quick-plot [
>         495x530
>         pen blue
>         pie [(data: copy saoud)] labels [(data: copy dates)] explode [1 2 3]
>         title "Saoud" style vh2     
>     ]
>     
> 
> Here's a slighty more mature version of the first example in this section. This program creates an inventory list using a simple GUI form (a window with some text fields and buttons). The file created could be used, for example, to determine re-order requirements, to calculate inventory and sales tax due, or sent to an accountant to be imported and used in a spreadsheet, etc.:
>     
>     
>     REBOL [title: "Inventory"]
>     view layout [
>         text "SKU:"
>         f1: field
>         text "Cost:"
>         f2: field "1.00"
>         text "Quantity:"
>         f3: field
>         across
>         btn "Save" [
>             write/append %inventory.txt rejoin [
>                 mold f1/text " " mold f2/text " " mold f3/text newline
>             ]
>             alert "Saved"
>         ]
>         btn "View Data" [editor %inventory.txt]
>     ]
>     
> 
> This program allows users to _view_ the inventory data created by the program above, _sorted_ by any chosen column:
>     
>     
>     REBOL [title: "Sort Inventory"]
>     inventory: load %inventory.txt
>     blocked: copy []
>     foreach [sku cost qty] inventory [
>         append/only blocked reduce [
>             sku 
>             to-money cost
>             to-integer qty
>         ]
>     ]
>     field-name: request-list "Choose Field To Sort By:" [
>         "sku" "cost" "qty"
>     ]
>     field: select ["sku" 1 "cost" 2 "qty" 3] field-name
>     order: request-list "Ascending or Descending:" ["ascending" "descending"]
>     either order = "ascending" [
>         sort/compare blocked func [a b] [(at a field) < (at b field)]
>     ][
>         sort/compare blocked func [a b] [(at a field) > (at b field)]
>     ]
>     foreach item blocked [
>         print rejoin [
>             "SKU:  " item/1 "  COST: " item/2 "  QTY: " item/3 newline
>         ]
>     ]
>     halt
>     
> 
> Here's a little contact database app that displays user information in a tabular display:
>     
>     
>     REBOL [title: "Contacts"]
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     gui: [
>         backdrop white
>         across
>         style header text black 200
>         header "Name:" header "Address:" header "Phone:" return
>     ]
>     foreach [name address phone] users [
>         append gui compose [
>             field (name) field (address) field (phone) return
>         ]
>     ]
>     view layout gui
>     
> 
> Here's a simple email app:
>     
>     
>     REBOL [title: "Email"]
>     view layout[
>         h1 "Send:"
>         btn "Server settings" [
>             system/schemes/default/host: request-text/title "SMTP Server:"
>             system/schemes/pop/host:     request-text/title "POP Server:"
>             system/schemes/default/user: request-text/title "SMTP User Name:"
>             system/schemes/default/pass: request-text/title "SMTP Password:"
>             system/user/email: to-email request-text/title "Your Email Addr:"
>         ]
>         a: field "user@website.com"
>         s: field "Subject" 
>         b: area
>         btn "Send"[
>             send/subject to-email a/text b/text s/text
>             alert "Sent"
>         ]
>         h1 "Read:" 
>         f: field "pop://user:pass@site.com"
>         btn "Read" [editor read to-url f/text]
>     ]
>     
> 
> Here's a scheduling app that allows users to create events on any day. The user can then click days on the calendar to see the scheduled events:
>     
>     
>     REBOL [title: "Schedule"]
>     view center-face gui: layout [
>         btn "Date" [date/text: form request-date  show date]
>         date: field
>         text "Event Title:"
>         event: field
>         text "Time:"
>         time: field
>         text "Notes:"
>         notes: field
>         btn "Add Appointment" [
>             write/append %appts.txt rejoin [
>                 mold date/text newline
>                 mold event/text newline
>                 mold time/text newline
>                 mold notes/text newline 
>             ]
>             date/text: "" event/text: "" time/text: "" notes/text: ""
>             show gui
>             alert "Added"
>         ]
>         a: area
>         btn "View Schedule" [
>             today: form request-date
>             foreach [date event time notes] load %appts.txt [
>                 if date = today [
>                     a/text: copy ""
>                     append a/text form rejoin [
>                         date newline
>                         event newline
>                         time newline
>                         notes newline newline
>                     ]
>                     show a
>                 ]
>             ]
>         ]
>     ]
>     
> 
> Here's a small but fully functional cash register application:
>     
>     
>     REBOL [title: "Minimal Cash Register"]
>     view gui: layout [
>         style fld field 80
>         across
>         text "Cashier:"   cashier: fld 
>         text "Item:"      item: fld 
>         text "Price:"     price: fld [
>             if error? try [to-money price/text] [alert "Price error" return]
>             append a/text reduce [mold item/text "    " price/text newline]
>             item/text: copy "" price/text: copy ""
>             sum: 0
>             foreach [item price] load a/text [sum: sum + to-money price]
>             subtotal/text: form sum
>             tax/text: form sum * .06
>             total/text: form sum * 1.06 
>             focus item
>             show gui
>         ]
>         return
>         a: area 600x300
>         return
>         text "Subtotal:"   subtotal: fld 
>         text "Tax:"        tax: fld 
>         text "Total:"      total: fld
>         btn "Save" [
>             items: replace/all (mold load a/text) newline " "
>             write/append %sales.txt rejoin [
>                 items newline cashier/text newline now/date newline
>             ]
>             clear-fields gui
>             a/text: copy ""             
>             show gui             
>         ]
>     ]
>     
> 
> This program computes a sum all sales made on the current day:
>     
>     
>     REBOL [title: "Daily Total"]
>     sales: read/lines %sales.txt
>     sum: $0
>     foreach [items cashier date] sales [
>         if now/date = to-date date [
>             foreach [item price] load items [
>                 sum: sum + to-money price
>             ]
>         ]
>     ]
>     alert rejoin ["Total sales today: " sum]
>     
> 
> Here's a full screen slide show presentation example:
>     
>     
>     REBOL [title: "Simple Presentation"]
>     slides: [
>         [
>             at 0x0 box system/view/screen-face/size white [unview]
>             at 20x20 h1 blue "Slide 1"
>             box black 2000x2
>             text "This slide takes up the full screen."
>             text "Adding images is easy:"
>             image logo.gif
>             image stop.gif
>             image info.gif
>             image exclamation.gif
>             text "Click anywhere on the screen for next slide..."
>             box black 2000x2
>         ]
>         [
>             at 0x0 box system/view/screen-face/size effect [
>                 gradient 1x1 tan brown
>             ] [unview]
>             at 20x20 h1 blue "Slide 2"
>             box black 2000x2
>             text "Gradients and color effects are easy in REBOL:"
>             box effect [gradient 123.23.56 254.0.12]
>             box effect [gradient blue gold/2]
>             text "Click anywhere on the screen to close..."
>             box black 2000x2
>         ]
>     ]
>     foreach slide slides [
>         view/options center-face layout slide 'no-title
>     ]
>     
> 
> Here's a parts database application:
>     
>     
>     REBOL [title: "Parts"]
>     write/append %data.txt ""
>     database: load %data.txt
>     view center-face gui: layout [
>         text "Parts in Stock:"
>         name-list: text-list blue 400x100 data sort (extract database 4) [
>             if value = none [return]
>             marker: index? find database value
>             n/text: pick database marker
>             a/text: pick database (marker + 1)
>             p/text: pick database (marker + 2)
>             o/text: pick database (marker + 3)
>             show gui
>         ]
>         text "Part Name:"       n: field 400
>         text "Manufacturer:"    a: field 400
>         text "SKU:"      p: field 400
>         text "Notes:"      o: area  400x100
>         across
>         btn "Save" [
>             if n/text = "" [alert "You must enter a Part name." return]
>             if find (extract database 4) n/text [
>                 either true = request "Overwrite existing record?" [
>                    remove/part (find database n/text) 4
>                 ] [
>                    return
>                 ]
>             ]
>             save %data.txt repend database [n/text a/text p/text o/text]
>             name-list/data: sort (extract copy database 4)
>             show name-list
>         ]
>         btn "Delete" [
>             if true = request rejoin ["Delete " n/text "?"] [
>                 remove/part (find database n/text) 4
>                 save %data.txt database
>                 do-face clear-button 1
>                 name-list/data: sort (extract copy database 4)
>                 show name-list
>             ]
>         ]
>         clear-button: btn "New" [
>             n/text: copy  ""
>             a/text: copy  ""
>             p/text: copy  ""
>             o/text: copy  ""
>             show gui
>         ]
>     ]
>     
> 
> Here's a spreadsheet application, originally written in REBOL by Carl Sassenrath, which can inherently use the entire REBOL language and all it's features to process cell data (math, graphics, Internet, file and network protocols, parse, native dialogs, GUI, and _all_ other general purpose capabilities of the language are available to functions in this tiny 68 line program):
>     
>     
>     REBOL [Title: "Rebocalc" Authors: ["Carl Sassenrath" "Nick Antonaccio"]]
>     csize: 100x20  max-x: 8  max-y: 16
>     pane: []
>     xy: csize / 2 + 1 * 1x0
>     yx: csize + 1 * 0x1
>     layout [
>         cell: field csize edge none [enter face compute face/para/scroll: 0x0]
>         label: text csize white black bold center
>     ]
>     char: #"A"
>     repeat x max-x [
>         append pane make label [offset: xy text: char]
>         set in last pane 'offset xy
>         xy: csize + 1 * 1x0 + xy
>         char: char + 1
>     ]
>     repeat y max-y [
>         append pane make label [offset: yx text: y size: csize * 1x2 / 2]
>         yx: csize + 1 * 0x1 + yx
>     ]
>     xy: csize * 1x2 / 2 + 1
>     cells: tail pane
>     repeat y max-y [
>         char: #"A"
>         repeat x max-x [
>             v: to-word join char y
>             set v none
>             char: char + 1
>             append pane make cell [offset: xy text: none var: v formula: none]
>             xy: csize + 1 * 1x0 + xy
>         ]
>         xy: csize * 1x2 / 2 + 1 + (xy * 0x1)
>     ]
>     enter: func [face /local data] [
>         if empty? face/text [exit]
>         set face/var face/text
>         data: either face/text/1 = #"=" [next face/text][face/text]
>         if error? try [data: load data] [exit]
>         if find [
>             integer! decimal! money! time! date! tuple! pair!
>         ] type?/word :data [set face/var data exit]
>         if face/text/1 = #"=" [face/formula: :data]
>     ]
>     compute: has [blk] [
>         unfocus
>         foreach cell cells [
>             if cell/formula [
>                 either cell/text = "formula" [
>                     cell/text: join "=" form cell/formula
>                     show cell return
>                 ][
>                     if error? cell/text: try [do cell/formula] [
>                         cell/text: "ERROR!"
>                     ]
>                 ]
>                 set cell/var cell/text
>                 show cell
>             ]
>         ]
>     ]
>     lo: layout [
>         bx: box second span? pane
>         text "Example: type '7' into A1, '19' into B1, '=a1 + b1' into C1" 
>         text "Type 'formula' into any cell to edit an existing formula (C1)."
>     ]
>     bx/pane: pane
>     view center-face lo
>     
> 
> The process of learning a programming language is similar to learning any spoken language (English, French, Spanish, etc.). If you move a person from the United States to Spain, you can be fairly certain that within a year, they will be able to speak Spanish adequately, even if they aren't provided any appropriate structured Spanish training or guidance. Guidance certainly helps clarify the process, but a key essential component is _immersion_. Immersion in code works the same way. It may be painful and confusing at first to see or comprehend a totally foreign language and environment, but diving right into code is required if you want to become proficient at "speaking" REBOL. Run each example in this section, and along the way, try changing some text headers, button labels, text field sizes, and other obvious properties to see how the programs change. Getting used to _using the REBOL interpreter_, becoming aware that code examples in this text are _malleable_, and opening your mind to the prospect and activity of actually _typing_ REBOL code, is an important first step.

### 1.4 Basics of REBOL Coding

> Computer programming is about processing **data** \- that's _all computers do internally_ (although the results of that data processing can appear, and actually end up being, magically more human). Everything you learn about in this text, therefore, will necessarily have to do with inputting, manipulating, and outputting processed **data**.
> 
> Every REBOL program must begin with the following header:
>     
>     
>     REBOL []
>     
> 
> **Function** words perform actions upon data values. The following function examples display some data values (text, in this case) and request useful data values from users (any text after a semicolon in these examples is a human readable "comment", and is ignored completely by the REBOL interpreter):
>     
>     
>     REBOL []
>     alert "Hello world"      ; "ALERT" is the function word here.
>     editor "Hello world"     ; "Hello world" is the text data parameter.
>     print "Hello world"      ; 
>     wait 2                   ; "Wait" is the function here, "2" is the data.
>     request-date             ; Requestor functions get some data from a user.
>     request-pass
>     request-text/title "What is your Name?"
>     request-file
>     request-list "Choose a color:" ["Red" "Green" "Blue"]
>     request ["Size:" "Small" "Medium" "Large"]
>     request-color
>     
> 
> Be sure to paste EVERY code example into the REBOL editor, and watch each line run.
> 
> In REBOL, the output of one function (the "return value") can be used as the input ("argument" or "parameter") of another function:
>     
>     
>     ; Here, the "editor" function edits whatever date is input by the user:
>     
>     editor request-date
>     
>     ; Here, the "alert" function displays whatever text is input by the user:
>     
>     alert request-text
>     
> 
> In REBOL you can assign data to a _label_ word (also called a "variable"), using the _colon_ symbol. Once data is assigned to a word label, you can use that word anywhere to refer to the assigned value:
>     
>     
>     REBOL []
>     balance: $53940.23 - $234
>     print balance
>     name: request-text/title "Name:"
>     print name
>     date: request-date
>     print date
>     alert "Click [OK] to continue"
>     
> 
> You can join together, or _concatenate_, data values using the "rejoin" function. Try adding this line to the end of the program above:
>     
>     
>     alert rejoin [name ", your balance on " date " is " balance]
>     
> 
> There are a variety of useful values built into REBOL:
>     
>     
>     REBOL []
>     alert rejoin ["Right now the date and time is: " now]
>     alert rejoin ["The date is: " now/date]
>     alert rejoin ["The time is: " now/time]
>     alert rejoin ["The value of PI is " pi]
>     alert rejoin ["The months are " system/locale/months]
>     alert rejoin ["The days are " system/locale/days]
>     
> 
> REBOL can perform useful calculations on many types of values:
>     
>     
>     REBOL []
>     alert rejoin ["5 + 7 = " 5 + 7]
>     alert rejoin ["Five days ago was " now/date - 5]
>     alert rejoin ["Five minutes ago was " now/time - 00:05]
>     alert rejoin ["Added coordinates: " 23x54 + 19x31]
>     alert rejoin ["Multiplied coordinates: " 22x66 * 2]
>     alert rejoin ["A multiplied coordinate matrix: " 22x66 * 2x3]
>     alert rejoin ["Added tuple values: " 192.168.1.1 + 0.0.0.37]
>     alert rejoin ["The RGB color value of purple - brown is: " purple - brown]
>     
> 
> Remember, programming is fundamentally about managing data, so REBOL's ability to appropriately handle operations and computations with common data types leads to greater simplicity and productivity for programmers.

### 1.5 Conditional Evaluations

> _Conditional evaluations_ can be performed using the syntax: "if (this is true) [do this]":
>     
>     
>     REBOL []
>     if (now/time > 6:00am) [alert "It's time to get up!"]
>     
> 
> Notice the natural handling of the time value in the example above. No special formatting or parsing is required to use that value. REBOL natively "understands" how to perform appropriate computations with time and other common data types.
> 
> Use the "either" evaluation to do one thing if a condition is true, and another if the condition is false:
>     
>     
>     REBOL []
>     user: "sa98df"
>     pass: "008uqwefbvuweq"
>     userpass: request-pass
>     either (userpass = reduce [user pass]) [
>         alert rejoin ["Welcome back " user "!"]
>     ][ 
>         alert "Incorrect username/password combination"
>     ]
>     
> 
> In the code above:
> 
>   1. The word label (variable) "user" is assigned to a text value.
>   2. The variable "pass" is assigned to some text.
>   3. A username/password combination is requested from the user, and the result of that function is labeled "userpass".
>   4. An "either" conditional evaluation is performed on the returned "userpass" value. If the userpass value equals the set "user" and "pass" variables, the user is alerted with a welcome message. Otherwise, the user is alert with an error message.

### 1.6 Some More Useful Functions

> Try pasting every individual line below into the REBOL interpreter console to see how each function can be used to perform useful actions:
>     
>     
>     REBOL []
>     print read http://rebol.com  ; "read" retrieves the data from many sources
>     editor http://rebol.com   ; the built in editor can also read many sources
>     print read %./          ; the % symbol is used for local files and folders
>     editor %./
>     write %temp.txt "test"   ; write takes TWO parameters (file name and data)
>     editor %temp.txt
>     editor request-file/only       ; "only" refinement limits choice to 1 file
>     write clipboard:// (read http://rebol.com)  ; 2nd parameter in parentheses
>     editor clipboard://
>     print read dns://msn.com   ; REBOL can read many built in protocols
>     print read nntp://news.grc.com
>     write/binary %/c/bay.jpg (read/binary http://rebol.com/view/bay.jpg)
>     write/binary %tada.wav (read/binary %/c/windows/media/tada.wav)
>     write/binary %temp.dat (compress read http://rebol.com)    ; COMPRESS DATA
>     print decompress read/binary %temp.dat                   ; DECOMPRESS DATA
>     print read ftp://user:pass@website.com/name.txt       ; user/pass required
>     write ftp://user:pass@website.com/name.txt "text"     ; user/pass required
>     editor ftp://user:pass@website.com/name.txt  ; can save changes to server!
>     editor pop://user:pass@website.com       ; read all emails in this account
>     send user@website.com "Hello"                                 ; send email
>     send user@website.com (read %file.txt)     ; email the text from this file
>     send/attach user@website.com "My photos" [%pic1.jpg %pic2.jpg pic3.jpg]
>     name: ask "Enter your name"  print name  ; request a user value in console
>     
>     call/show "notepad.exe c:\config.sys"            ; run an OS shell command
>     browse http://re-bol.com       ; open system default web browser to a page
>     view layout [image %pic1.jpg]                              ; view an image
>     view layout [image request-file/only]         ; view a user selected image
>     insert s: open sound:// load request-file/only wait s close s ; play sound
>     insert s: open sound:// load %/c/windows/media/tada.wav wait s close s
>     
>     rename %temp.txt %temp2.txt                             ; change file name
>     write %temp.txt read %temp2.txt                                ; copy file
>     write/append %temp2.txt ""     ; create file (or if it exists, do nothing)
>     delete %temp2.txt
>     change-dir %../
>     what-dir 
>     list-dir
>     make-dir %./temp
>     print read %./
>     
>     attempt [print 0 / 0]                         ; test for and handle errors
>     if error? try [print 0 / 0] [alert "*** ERROR:  divide by zero"]
>     
>     parse "asdf#qwer#zxcv" "#"                ; split strings at character set
>     trim "  asdf89w   we   "     ; remove white space at the beginning and end
>     replace/all "xaxbxcxd" "x" "q"   ; replace all occurrences of "x" with "q"
>     checksum read %file.txt            ; compute a checksum to ensure validity
>     print dehex "a%20space"                  ; convert from URL encoded string
>     print to-url "a space"                     ; convert to URL encoded string
>     print detab "tab    separated"                    ; convert tabs to spaces
>     print enbase/base "a string" 64  ; convert string or bin to base 64, 16, 2
>     print encloak "my data" "my pass"  ; encrypt and decrpyt data (AES, blow-
>     print decloak "µÜiűŽz®" "my pass"  ; fish and other formats also supported
>     read-cgi            ; neatly parse all data submitted from a web page form
>     for i 1 99 3 [print i]                 ; count from 1 to 99, by steps of 3
>     
>     halt           ; "HALT" stops the REBOL console from closing,
>                    ; so you can see the printed results.
>     
> 
> In order to see each of the lines above execute, paste them directly into the REBOL console, instead of into the editor. When running code directly in the console, it's not necessary to include the REBOL[] header, or the "halt" function:
> 
> Really take a look at how much computing ability is enabled by each of the functions above. That short collection of one line code snippets demonstrates how to do many of the most commonly useful tasks performed by a computer:
> 
>   1. Reading data from and writing data to files on a hard drive, thumb drive, etc.
>   2. Reading/writing data from/to web servers and other network sources, the system clipboard, user input, etc.
>   3. Reading emails, sending emails, sending attached files by email.
>   4. Displaying images.
>   5. Playing sounds.
>   6. Navigating and manipulating folders and files on the computer.
>   7. Compressing, decompressing, encrypting, and decrypting data.
>   8. Running third party programs on the computer.
>   9. Reading, parsing, and converting back and forth between common data types and values.
> 
> And those lines are just a cursory introduction to a handful of built in REBOL functions. There are hundreds more. At this point in the tutorial, simply read the examples and paste them into the REBOL interpreter console to introduce yourself to the syntax, and to witness their resulting action. You will see these functions, and others, used repeatedly throughout this tutorial and in real working code, for as long as you study and use REBOL. Eventually, you will get to know their syntax and refinements by heart, but you can always refer to reference documentation while you're learning. If you're serious about learning to program, you should take some time now to try changing the parameters of each function to do some useful work (try reading the contents of different file names, send some emails to yourself, compress and decompress some data and view the results with the editor function, etc.)
> 
> You can get a list of all function words by typing the "what" function into the REBOL console:
>     
>     
>     what                             ; press the [ESC] key to stop the listing
>     
> 
> You can see the syntax, parameters, and refinements of any function using the "help" function:
>     
>     
>     help print
>     help prin
>     help read
>     help write
>     
> 
> You can learn more about all the useful functions built in to REBOL by running the following program. Try it now:
>     
>     
>     write %wordbrowser.r read http://re-bol.com/wordbrowser.r
>     do %wordbrowser.r
>     
> 
> By learning to combine simple functions with a bit of conditional evaluation (if/then) thinking, along with some list processing techniques, you can accomplish truly useful programming goals that go far beyond the capabilities of even complex office suite programs (much more about 'list processing' will be covered shortly).
> 
> The important thing to understand at this point is that _functions_ exist in REBOL, to perform _actions_ on all sorts of useful _data_. Learning to recognize functions and the data parameters which follow them, when you see them in code, is an important first step in learning to read and write REBOL. Eventually memorizing the syntax and appropriate use patterns of all built in functions is a necessary goal if you want to write code fluently.
> 
> The benefit of pasting (or even better _typing_) every single example into the REBOL editor and/or console, cannot be overstated. Concepts will become more understandable, and important code details will be explicitly clarified as this text progresses. For now, working by rote is the best way to continue learning. Read and execute each example, and pay attention to which words are functions and which words are data arguments.

## 2\. Lists, Tables, and the "Foreach" Function

> ### 2.1 Managing Spreadsheet-Like Data

> #### 2.1.1 Warning
> 
> NOTE: This section of the tutorial is the longest and most difficult to grasp at first read. Read through it once to introduce yourself to all the topics, and skim the code structures. Be prepared for it - the code is going to get hairy. Just press on, absorb what you can, and continue to read through the entire section. You'll refer back to it later in much greater detail, once you've seen how all the concepts, functions, and code patterns fit together to create useful programs.
> 
> #### 2.1.2 Blocks
> 
> Most useful business programs process _lists_ of data. _Tables_ of data are actually dealt with programatically as _consecutive lists_ of items. A list or "block" of data is created in REBOL by surrounding values with square brackets:
>     
>     
>     REBOL []
>     names: ["Bob" "Tom" "Bill"]
>     
> 
> To perform an operation/computation with/to each data item in the block, use the **foreach** function. _Foreach_ syntax can be read like this: "foreach (labeled item) in (this labeled block) [perform this operation with/to each labeled item]:
>     
>     
>     REBOL []
>     names: ["Bob" "Tom" "Bill"] ; create a block of text items labeled "names"
>     foreach name names [print name]       ; print each name value in the block
>     halt
>     
> 
> This example prints each value stored in the built-in "system/locale/months" block:
>     
>     
>     REBOL []
>     months: system/locale/months     ; set the variable "months" to the values
>     foreach month months [print month]                ; print each month value
>     halt
>     
> 
> _Note that in the example above, the variable words "months" and "month" could be changed to any other desired, arbitrarily determined, label:_
>     
>     
>     REBOL []
>     foo: system/locale/months
>     foreach bar foo [print bar]                ; variable labels are arbitrary
>     halt
>     
> 
> Labeling the system/locale/months block is also not required. Without the label, the code is shorter, but perhaps just a bit harder to read:
>     
>     
>     REBOL []
>     foreach month system/locale/months [print month]
>     halt
>     
> 
> Learning to read and think in terms of "foreach item in list [do this to each item]" is one of the most important fundamental concepts to grasp in programming. You'll see numerous repeated examples in this text. Be aware every time you see the word "foreach".
> 
> You can obtain lists of data from a variety of different sources. Notice that the "load" function is typically used to read lists of data. This example prints the files in the current folder on the hard drive:
>     
>     
>     REBOL []
>     folder: load %. 
>     foreach file folder [print file]
>     halt
>     
> 
> This example loads the list from a file stored on a web site:
>     
>     
>     REBOL []
>     names: load http://re-bol.com/names.txt 
>     foreach name names [print name]     
>     halt
>     
> 
> NOTE: you can write the data required for the above example to your own web server, using the following line of code. Note that the "save" function is typically used to write lists of data:
>     
>     
>     REBOL []
>     save ftp://user:pass@site.com/folder/names.txt ["Bob" "Tom" "Bill"]
>     

### 2.2 Some Simple List Algorithms (Count, Sum, Average, Max/Min)

> #### 2.2.1 Counting Items
> 
> The "length?" function counts the number of items in a list:
>     
>     
>     REBOL []
>     receipts: [$5.23 $95.98 $7.46 $34]        ; a list labeled "receipts"
>     alert rejoin ["There are " length? receipts " receipts in the list."]
>     
> 
> You can assign counts to variable labels and use the values later:
>     
>     
>     REBOL []
>     month-count: length? system/locale/months 
>     day-count: length? system/locale/days
>     alert rejoin ["There are " month-count " months and " day-count " days."]
>     
> 
> Another way to count items in a list is to create a counter variable, initially set to 0. Use a foreach loop to go through each item in the list, and increment (add 1) to the count variable:
>     
>     
>     REBOL []
>     count: 0
>     receipts: [$5.23 $95.98 $7.46 $34]
>     foreach receipt receipts [count: count + 1]   ; increment count by 1
>     alert rejoin ["There are " count " receipts in the list."]
>     
> 
> Here's an alternate syntax for incrementing counter variables:
>     
>     
>     REBOL []
>     count: 0
>     receipts: [$5.23 $95.98 $7.46 $34] 
>     foreach receipt receipts [++ count]           ; increment count by 1
>     alert rejoin ["There are " count " receipts in the list."]
>     
> 
> This example counts the number of months in a year and the number of days in a week, using counter variables:
>     
>     
>     REBOL []
>     month-count: 0
>     day-count: 0
>     foreach month system/locale/months [++ month-count] 
>     foreach day system/locale/days [++ day-count]
>     alert rejoin ["There are " month-count " months and " day-count " days."]
>     
> 
> Counter variables are particularly useful when you only want to count _certain items_ in a list. The following example counts only items that are number values:
>     
>     
>     REBOL []
>     count: 0
>     list: ["screws" 14 "nuts" 38 "bolts" 23]
>     foreach item list [
>         ; Increment only if item type is integer:
>         if (type? item) = integer! [++ count]
>     ]
>     alert rejoin ["The count of all number values in the list is: " count]
>     
> 
> #### 2.2.2 Sums
> 
> To calculate the _sum_ of numbers in a list, start by assigning a sum variable to 0. Then use a foreach loop to increment the sum by each individual number value. This example starts by assigning the label "balance" to a value of 0. Then the label "receipts" is assigned to a list of money values. Then, each value in the receipts list is added to the balance, and that tallied balance is displayed:
>     
>     
>     REBOL []
>     sum: 0                                ; a sum variable, initially set to 0
>     receipts: [$5.23 $95.98 $7.46 $34]            ; a list, labeled "receipts"
>     foreach item receipts [sum: sum + item]                      ; add them up
>     alert rejoin ["The sum of all receipts is: " sum]
>     
> 
> You could total _only_ the items in a list which contain number values, for example, like this:
>     
>     
>     REBOL []
>     sum: 0
>     list: ["screws" 14 "nuts" 38 "bolts" 23]
>     foreach item list [
>         if (type? item) = integer! [            ; only if item type is integer
>             sum: sum + item                     ; add item to total
>         ]
>     ]
>     alert rejoin ["The total of all number values in the list is: " sum]
>     
> 
> #### 2.2.3 Averages
> 
> Computing the average value of items in a list is simply a matter of dividing the sum by the count:
>     
>     
>     REBOL []
>     sum: 0
>     receipts: [$5.23 $95.98 $7.46 $34]
>     foreach item receipts [sum: sum + item]
>     average: sum / (length? receipts)
>     alert rejoin ["The average balance of all receipts is: " average]
>     
> 
> #### 2.2.4 Maximums and Minimums
> 
> REBOL has built in "maximum-of" and "minimum-of" functions:
>     
>     
>     REBOL []
>     receipts: [$5.23 $95.98 $7.46 $34]
>     print first maximum-of receipts
>     print first minimum-of receipts
>     halt
>     
> 
> You can perform more complicated max/min comparisons by checking each value with a conditional evaluation. This example looks for the highest receipt value under $50:
>     
>     
>     REBOL []
>     highest: $0
>     receipts: [$5.23 $95.98 $7.46 $34]
>     foreach receipt receipts [
>         if (receipt > highest) and (receipt < $50) [highest: receipt] 
>     ]
>     alert rejoin ["Maximum receipt below fifty bucks: " highest]
>     

### 2.3 Searching

> The "find" function is used to perform simple searches:
>     
>     
>     REBOL []
>     names: ["John" "Jane" "Bill" "Tom" "Jen" "Mike"]
>     if find names "Bill" [alert "Yes, Bill is in the list!"]
>     if not find names "Paul" [alert "No, Paul is not in the list."]
>     
> 
> You can determine the index position of a found item in a list, using the "index?" function:
>     
>     
>     REBOL []
>     names: ["John" "Jane" "Bill" "Tom" "Jen" "Mike"]
>     indx: index? find names "Bill"
>     print rejoin ["Bill is at position " indx " in the list."]
>     halt
>     
> 
> You can search for text within each item in a list using a foreach loop to search each individual value:
>     
>     
>     REBOL []
>     names: ["John" "Jane" "Bill" "Tom" "Jen" "Mike"]
>     foreach name names [
>         if find name "j" [
>             print rejoin ["'j' found in " name]
>         ]
>     ]
>     halt
>     
> 
> The "find/any" refinement can be used to search for wildcard characters. The "*" character allows for portions of search text to contain random character strings of any length. The "?" character allows for random character searches of a specified length (at specific character positions within a search term):
>     
>     
>     REBOL []
>     names: ["OJ" "John" "Joan" "Jan" "Major Bill" "MJO" "Mike"]
>     foreach name names [
>         if find/any name "*jo*" [
>             print rejoin ["'jo' found in " name]
>         ]
>     ]
>     print ""
>     foreach name names [
>         if find/any name "j*n" [
>             print rejoin ["'j*n' found in " name]
>         ]
>     ]
>     print ""
>     foreach name names [
>         if find/any name "j??n" [
>             print rejoin ["'j--n' found in " name]
>         ]
>     ]
>     halt
>     

### 2.4 Gathering Data, and the "Copy" Function

> When collecting ("aggregating") values into a new block, _always use the **"copy"** function to create the new block_. You'll need to do this whenever a sub-list or super-list of values is created based upon conditional evaluations performed on data in a base list:
>     
>     
>     REBOL []
>     low-receipts: copy []             ; Create blank list with copy [], NOT []
>     receipts: [$5.23 $95.98 $7.46 $34]
>     foreach receipt receipts [
>         if receipt < $10 [append low-receipts receipt]     ; add to blank list
>     ]
>     print low-receipts
>     halt
>     
> 
> For example, the following line should should NOT be used (it does not contain the word "copy" when creating a blank list):
>     
>     
>     low-receipts: []               ; WRONG - should be   low-receipts: COPY []
>     
> 
> The same is true when creating blank string values. Use the "copy" function whenever you create an empty text value that you intend to adjust or add to:
>     
>     
>     REBOL []
>     names: copy {}                  ; Create blank string with copy {}, NOT {}
>     people: ["Joan" "George" "Phil" "Jane" "Peter" "Tom"]
>     foreach person people [
>         if find person "e" [
>             append names rejoin [person " "]    ; This appends to blank string
>         ]
>     ]
>     print names
>     halt
>     

### 2.5 List Comparison Functions

> REBOL has a variety of useful built in list comparison functions. You'll use these for determining differences, similarities, and combinations between sets of data:
>     
>     
>     REBOL []
>     group1: ["Joan" "George" "Phil" "Jane" "Peter" "Tom"]
>     group2: ["Paul" "George" "Andy" "Mary" "Tom" "Tom"]
>     print rejoin ["Group 1: " group1]  
>     print ""   
>     print rejoin ["Group 2: " group2]
>     print newline
>     print rejoin ["Intersection:           " intersect group1 group2]
>     print "^/(values shared by both groups)^/^/"  
>     print rejoin ["Difference:             " difference group1 group2]
>     print "^/(values not shared by both groups)^/^/"
>     print rejoin ["Union:                  " union group1 group2]
>     print "^/(all unique values contained in both groups)^/^/"
>     print rejoin ["Join:                   " join group1 group2]
>     print "^/(one group tacked to the end of the other group)^/^/"
>     print rejoin ["Excluded from Group 2:  " exclude group1 group2]
>     print "^/(values contained in group1, but not contained in group2)^/^/"
>     print rejoin ["Unique in Group 2:      " unique group2]
>     print "^/(unique values contained in group2)"
>     halt
>     

### 2.6 Creating Lists From User Input

> #### 2.6.1 Creating New Blocks and Adding Values
> 
> You can create a new block using the code pattern below. Simply assign variable labels to "**copy []**":
>     
>     
>     REBOL []
>     items: copy []          ; new empty block named "items"
>     prices: copy []         ; new empty block named "prices"
>     
> 
> Add values to new blocks using the "append" function:
>     
>     
>     REBOL []
>     items: copy []
>     prices: copy []
>     append items "Screwdriver"
>     append prices "1.99"
>     append items "Hammer"
>     append prices "4.99"
>     append items "Wrench"
>     append prices "5.99"
>     
> 
> Use the "print", "probe", or "editor" functions to view the data in a block. The "print" function simply prints the values in the block. The "probe" function shows the block data structure (square brackets enclosing the values, quotes around text string values, etc.). The "editor" function opens REBOL's built in text editor, with the block structure displayed:
>     
>     
>     REBOL []
>     items: copy []
>     prices: copy []
>     append items "Screwdriver"
>     append prices "1.99"
>     append items "Hammer"
>     append prices "4.99"
>     append items "Wrench"
>     append prices "5.99"
>     
>     editor items
>     editor prices
>     
>     print rejoin ["ITEMS:   " items newline]
>     print rejoin ["PRICES:  " prices newline]
>     
>     probe items
>     probe prices
>     
>     halt
>     
> 
> #### 2.6.2 Accepting Data Input from a User
> 
> You've already been introduced to the "request-text" function. It accepts text input from a user:
>     
>     
>     REBOL []
>     request-text
>     
> 
> You can assign a variable label to the data entered by the user, and then use that data later in your program:
>     
>     
>     REBOL []
>     price: request-text
>     alert price
>     
> 
> You can add a text title to the request-text function, with the "/title" refinement:
>     
>     
>     REBOL []
>     price: request-text/title "Input a dollar value:"
>     alert price
>     
> 
> You can add a default text response using the "/default" refinement:
>     
>     
>     REBOL []
>     price: request-text/default "14.99"
>     alert price
>     
> 
> You can combine the "/title" and "/default" refinements:
>     
>     
>     REBOL []
>     price: request-text/title/default "Input a dollar value:" "14.99"
>     alert price
>     
> 
> The "ask" function does the same thing, but within the text environment of the REBOL interpreter console (instead of using a popup windowed requestor):
>     
>     
>     REBOL []
>     price: ask "Input a dollar value:  $"
>     alert price
>     
> 
> #### 2.6.3 Building Blocks from User-Entered Data
> 
> Add data to a block, which has been entered by the user, using the code pattern below. Append the variable label of the entered data to the block label:
>     
>     
>     REBOL []
>     items: copy []
>     prices: copy []
>     item: request-text/title/default "Item:" "screwdriver"
>     price: request-text/title/default "Price:" "1.99"
>     append items item
>     append prices price
>     
> 
> The example below uses a "forever" loop to repeatedly perform the "request-text" and "append" operations. A conditional "if" evaluation checks to see if the user enters "" (empty text) in the Item requestor. If so, it stops the forever loop using the "break" function, and displays the data in each block:
>     
>     
>     REBOL []
>     items: copy []
>     prices: copy []
>     forever [
>         item: request-text/title "Item:"
>         if item = "" [break]
>         price: request-text/title "Price:"
>         append items item
>         append prices price
>     ]
>     print "Items:^/"                       ; THE ^/ CHARACTER PRINTS A NEWLINE
>     probe items
>     print "^/^/Prices:^/"
>     probe prices
>     halt
>     
> 
> _You could just as easily add the entered data to a single block_:
>     
>     
>     REBOL []
>     inventory: copy []
>     forever [
>         item: request-text/title "Item:"
>         if item = "" [break]
>         price: request-text/title "Price:"
>         append inventory item
>         append inventory price
>     ]
>     print "Inventory:^/"
>     probe inventory
>     halt
>     
> 
> #### 2.6.4 Saving and Reading Block Data To/From Files
> 
> Save a block to a text file using the "save" function. Remember that in REBOL, file names always begin with the "%" character:
>     
>     
>     REBOl []
>     inventory: ["Screwdriver" "1.99" "Hammer" "4.99" "Wrench" "5.99"]
>     save %inv.txt inventory
>     alert "Saved"
>     
> 
> Load blocked data from a saved file using the "load" function. You can assign a variable label to the loaded data, to use it later in the program:
>     
>     
>     REBOL []
>     inventory: load %inv.txt
>     print "Inventory^/"
>     probe inventory
>     halt
>     
> 
> You can also append data directly to a file using the "write/append" function. When using the "write/append" function, use the "mold" function to enclose each text value in quotes, and the "rejoin" function to separate each value with a space:
>     
>     
>     REBOL []
>     forever [
>         item: request-text/title "Item:"
>         if item = "" [break]
>         price: request-text/title "Price:"
>         write/append %inv.txt rejoin [
>             mold item " " mold price " "
>         ]
>     ]
>     inventory: load %inv.txt
>     print "Inventory:^/"
>     probe inventory
>     halt
>     

### 2.7 Three Useful Data Storage Programs: Inventory, Contacts, Schedule

> The last program above provides a nice template for practical applications of all types. It stores and displays inventory items and prices. Notice that a "title" variable has been added to the header, set to the text "Inventory". It's good practice to assign titles to all your programs:
>     
>     
>     REBOL [title: "Inventory"]
>     forever [
>         item: request-text/title "Item:"
>         if item = "" [break]
>         price: request-text/title "Price:"
>         write/append %inv.txt rejoin [
>             mold item " " mold price " "
>         ]
>     ]
>     inventory: load %inv.txt
>     print "Inventory:^/"
>     probe inventory
>     halt
>     
> 
> Here's the same program as above, changed slightly to store and display contact information:
>     
>     
>     REBOL [title: "Contacts"]
>     forever [
>         name: request-text/title "Name:"
>         if name = "" [break]
>         address: request-text/title "Address:"
>         phone: request-text/title "Phone:"
>         write/append %contacts.txt rejoin [
>             mold name " " mold address " " mold phone " "
>         ]
>     ]
>     contacts: load %contacts.txt
>     print "Contacts:^/"
>     probe contacts
>     halt
>     
> 
> Here it is again, repurposed to hold schedule information:
>     
>     
>     REBOL [title: "Schedule"]
>     forever [
>         event: request-text/title/default "Event Title:" "Meeting with "
>         if event = "" [break]
>         date: request-text/title/default "Date:" "1-jan-2013"
>         time: request-text/title/default "Time:" "12:00pm"
>         notes: request-text/title/default "Notes:" "Bring: "
>         write/append %schedule.txt rejoin [
>             mold event " " mold date " " mold time " " mold notes " "
>         ]
>     ]
>     schedule: load %schedule.txt
>     print "Schedule:^/^/"
>     probe schedule
>     halt
>     
> 
> The types of data you store using these sorts of operations can be adjusted specifically to your particular data management needs for any given task. Your ability to apply this code to practical situations is limited only by your own creativity. All you need to do is change the requestor titles and the variable labels to clarify the type of data being stored.

### 2.8 Working With Tables of Data: Columns and Rows

> _Columns_ within tables of data are arranged in sequential order in blocks. Indentation and white space helps to display columns neatly, within a visual "table" layout. The following table conceptually contains 3 rows of 3 columns of data, _but the whole block is still just a sequential list of 9 items_:
>     
>     
>     accounts:  [
>         "Bob"   $529.23   21-jan-2013
>         "Tom"   $691.37   13-jan-2013
>         "Ann"   $928.85   19-jan-2013
>     ]
>     
> 
> The foreach function in the next example alerts the user with every three consecutive data values in the table (each row of 3 consecutive name, balance, and date column values):
>     
>     
>     REBOL []
>     accounts:  [
>         "Bob" $529.23 21-jan-2013
>         "Tom" $691.37 13-jan-2013
>         "Ann" $928.85 19-jan-2013
>     ]
>     foreach [name balance date] accounts [
>         alert rejoin [
>             "Name: " name ", Date: " date ", Balance: " balance
>         ]
>     ]
>     
> 
> This example displays the computed balance for each person on the given date. The amount displayed is the listed "balance" value for each account, minus a universal "fee" value):
>     
>     
>     REBOL []
>     accounts:  [
>         "Bob" $529.23 21-jan-2013
>         "Tom" $691.37 13-jan-2013
>         "Ann" $928.85 19-jan-2013
>     ]
>     fee: $5
>     foreach [name balance date] accounts [
>         alert rejoin [name "'s balance on " date " will be " balance - fee]
>     ]
>     
> 
> Here's a variation of the above example which displays the sum of values in all accounts:
>     
>     
>     REBOL []
>     accounts:  [
>         "Bob" $529.23 21-jan-2013
>         "Tom" $691.37 13-jan-2013
>         "Ann" $928.85 19-jan-2013
>     ]
>     sum: $0
>     foreach [name balance date] accounts [sum: sum + balance]
>     alert rejoin ["The total of all balances is: " sum]
>     
> 
> Here's a variation that computes the average balance:
>     
>     
>     REBOL []
>     accounts:  [
>         "Bob" $529.23 21-jan-2013
>         "Tom" $691.37 13-jan-2013
>         "Ann" $928.85 19-jan-2013
>     ]
>     sum: $0
>     foreach [name balance date] accounts [sum: sum + balance]
>     alert rejoin [
>         "The average of all balances is: " 
>         sum / ((length? accounts) / 3)
>     ]
>     
> 
> Here is a variation of the "Schedule" application from the previous section, slightly adjusted using the "foreach" function to format a more cleanly printed data display:
>     
>     
>     REBOL []
>     forever [
>         event: request-text/title "Event Title:"
>         if event = "" [break]
>         date: request-text/title/default "Date:" "1-jan-2013"
>         time: request-text/title/default "Time:" "12:00pm"
>         notes: request-text/title/default "Notes:" "Bring: "
>         write/append %schedule.txt rejoin [
>             mold event " " mold date " " mold time " " mold notes " "
>         ]
>     ]
>     schedule: load %schedule.txt
>     print newpage                          ; "newpage" prints a cleared screen
>     print "SCHEDULE:^/^/"
>     foreach [event date time notes] schedule [
>         print rejoin [
>             "Event:  " event newline
>             "Date:   " date newline
>             "Time:   " time newline
>             "Notes:  " notes newline newline
>         ]
>     ]
>     halt
>     
> 
> Here is the "Inventory" program from the previous section, adjusted slightly to count the number of items and calculate a sum of inventory prices:
>     
>     
>     REBOL [title: "Inventory"]
>     forever [
>         item: request-text/title "Item:"
>         if item = "" [break]
>         price: request-text/title "Price:"
>         write/append %inv.txt rejoin [
>             mold item " " mold price " "
>         ]
>     ]
>     inventory: load %inv.txt
>     count: 0
>     sum: $0
>     foreach [item price] inventory [
>         count: count + 1
>         sum: sum + to-money price
>     ]
>     print newpage
>     print rejoin ["Total # of Items:  " count]
>     print rejoin ["Sum of Prices:     " sum]
>     halt
>     
> 
> Here's a variation of the "Contacts" application that searches for saved names, and prints out any matching contact information:
>     
>     
>     REBOL []
>     search: request-text/title/default "Search text:" "John"
>     contacts: load %contacts.txt
>     print newpage
>     print rejoin [search " found in:^/"]
>     foreach [name address phone] contacts [
>         if find name search [
>             print rejoin [
>                 "Name:      " name newline
>                 "Address:   " address newline
>                 "Phone:     " phone newline
>             ]
>         ]
>     ]
>     halt
>     
> 
> The ability to conceptually "flatten" tabular data into sequential streams of items, and vice-versa, to think of consecutive groups of items in a list as rows within mapped categorical columns, is fundamentally important to working with all sorts of business data sets. You'll see this concept applied regularly throughout examples in this tutorial and in real working code.

### 2.9 Additional List/Block/Series Functions and Techniques

> REBOL has built-in functions for performing every imaginable manipulation to list content, order, and other block properties - adding, deleting, searching, sorting, comparing, counting, replacing, changing, moving, etc. Here's a quick demonstrative list of functions. Try pasting each line individually into the REBOL interpreter to see how each function works:
>     
>     
>     REBOL []
>     
>     names: ["John" "Jane" "Bill" "Tom" "Jen" "Mike"]  ; a list of text strings
>     
>     print "Two ways of printing values, 'probe' and 'print':"
>     probe names   ; "Probe" is like "print", but it shows the actual data
>     print names   ;  structure. "Print" attempts to format the displayed data.
>     
>     print "^/Sorting:"
>     sorted: sort copy names    ; "Sort" sorts values ascending or descending.
>     probe names                ; "Copy" keeps the names block from changing
>     print sorted
>     sort/reverse names         ; Here, the names block has been sorted without
>     probe names                ; copy, so it's permanently changed.
>     
>     print "^/Picking items:"
>     probe first names                 ; 3 different ways to pick the 1st item:
>     probe names/1 
>     probe pick names 1 
>     probe second names                ; 3 different ways to pick the 2nd item:
>     probe names/2
>     probe pick names 2
>     
>     print "^/Searching:"
>     probe find names "John"                            ; How to search a block
>     probe first find names "John"
>     probe find/last names "Jane"
>     probe select names "John"                    ; Find next item after "John"
>     
>     print "^/Taking sections of a series:"
>     probe at names 2
>     probe skip names 2                                  ; Skip every two items
>     probe extract names 3                           ; Collect every third item
>     
>     print "^/Making changes:"
>     append names "George"
>     probe names
>     insert (at names 3) "Lee" 
>     probe names
>     remove names
>     probe names 
>     remove find names "Mike" 
>     probe names
>     change names "Phil" 
>     probe names
>     change third names "Phil"
>     probe names
>     poke names 3 "Phil" 
>     probe names
>     probe copy/part names 2 
>     replace/all names "Phil" "Al"
>     probe names
>     
>     print "^/Skipping around:"
>     probe head names 
>     probe next names 
>     probe back names 
>     probe last names 
>     probe tail names  
>     probe index? names 
>     
>     print "^/Converting series blocks to strings of text:"
>     probe form names
>     probe mold names
>     
>     print "^/Other Series functions:"
>     print length? names 
>     probe reverse names 
>     probe clear names
>     print empty? names
>     halt
>     
> 
> To demonstrate just a few of the functions above, here are some practical examples of common list operations, performed on a block of user contact information. The demonstration block of data is organized as 5 rows of 3 columns of data (name, address, phone), or 15 consecutive items in a list labeled "users". _Notice that to maintain the column and row structure, empty strings ("") are placed at positions in the list where there is no data_:
>     
>     
>     REBOL []
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     
>     append users ["Joe Thomas" "" "555-321-7654"]  ; append to end of list
>     probe users
>     
>     probe (at users 4)                      ; parentheses are not required
>     
>     insert (at users 4) [
>         "Tom Adams" "321 Way Lane Villageville, AZ" "555-987-6543"
>     ]
>     probe users
>     
>     remove (at users 4)                                   ; remove 1 item
>     probe users
>     
>     ; BE CAREFUL - the line above breaks the table structure by removing
>     ; an item entirely, so all other data items are shifted into incorrect
>     ; columns.  Instead, either replace the data with an empty place holder
>     ; or remove the address and phone fields too:
>     
>     remove/part (at users 4) 2                            ; remove 2 items
>     probe users
>     
>     change (at users 1) "Jonathan Smith"
>     probe users
>     
>     remove (at users 1) insert (at users 1) "Jonathan Smith"
>     probe users
>     halt
>     
> 
> The "extract" function is useful for picking out columns of data from structured blocks:
>     
>     
>     REBOL []
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ] 
>     probe extract users 3             ; names
>     probe extract (at users 2) 3      ; addresses 
>     probe extract (at users 3) 3      ; phone numbers 
>     halt
>     
> 
> You can "pick" items at a particular index location in the list:
>     
>     
>     REBOL []
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     print pick users 1                  ; FIRST name
>     print pick users 2                  ; FIRST address
>     print pick users 3                  ; FIRST phone
>     ;
>     print pick users 4                  ; SECOND name
>     print pick users 5                  ; SECOND address
>     print pick users 6                  ; SECOND phone
>     ;
>     indx: length? users                 ; index position of the LAST item
>     print pick users indx               ; last item
>     print pick users (indx - 1)         ; second to last item
>     print pick users (random length? users)  ; random item
>     halt
>     
> 
> You can determine the index location at which an item is found, using the "find" function:
>     
>     
>     indx: index? find users "John Smith"
>     
> 
> In REBOL there 4 ways to pick items at such a variable index. Each syntax below does the _exact same thing_. These are just variations of the "pick" syntax:
>     
>     
>     print pick users indx
>     print users/:indx
>     print compose [users/(indx)]       ; put composed values in parentheses
>     print reduce ['users/(indx)]       ; put a tick mark on non-reduced values
>     
> 
> Pay particular attention to the "compose" and "reduce" functions. They allow you to convert _static words_ in blocks to _evaluated values_:
>     
>     
>     REBOL []
>     
>     ; This example prints "[month]" 12 times:
>     
>     foreach month system/locale/months [
>         probe [month]
>     ]
>     
>     ; These examples print all 12 month values:
>     
>     foreach month system/locale/months [
>         probe reduce [month]
>     ]
>     
>     foreach month system/locale/months [
>         probe compose [(month)]
>     ]
>     
> 
> Here's a complete example that requests a name from the user, finds the index of that name in the list, and picks out the name, address, and phone data for that user (located at the found indx, indx + 1, and indx + 2 positions):
>     
>     
>     REBOL [title: "Search Users"]
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     
>     name: request-text/title/default "Name:" "Jim Persee"
>     indx: index? find users name
>     
>     print rejoin [
>         (pick users indx) newline
>         (pick users (indx + 1)) newline
>         (pick users (indx + 2)) newline
>     ]
>     halt
>     
> 
> Here's a version that uses code from the "Contacts" program you saw earlier. It allows you to create your own user database, and then search and display entries with the code above:
>     
>     
>     REBOL [title: "Search My Stored Contacts"]
>     
>     ; This code is borrowed from the "Contacts" program seen earlier:
>     
>     forever [
>         name: request-text/title "Name:"
>         if name = "" [break]
>         address: request-text/title "Address:"
>         phone: request-text/title "Phone:"
>         write/append %contacts.txt rejoin [
>             mold name " " mold address " " mold phone " "
>         ]
>     ]
>     users: load %contacts.txt
>     
>     ; This is a variation of the code above which adds an error check, to
>     ; provide a response if the search text is not found in the data block:
>     
>     name: request-text/title/default "Search For:" "Jim Persee"
>     if error? try [indx: index? find users name] [
>         alert "Name not found" quit
>     ]
>     print rejoin [
>         (pick users indx) newline
>         (pick users (indx + 1)) newline
>         (pick users (indx + 2)) newline
>     ]
>     halt
>     

### 2.10 Sorting Lists and Tables of Data

> You can sort a list of data using the "sort" function:
>     
>     
>     REBOL []
>     print sort system/locale/months
>     halt
>     
> 
> This example displays a list requestor with the months sorted alphabetically:
>     
>     
>     REBOL []
>     request-list "Sorted months:" sort system/locale/months
>     
> 
> If you sort a block of values consisting of data types that REBOL understands, the values will be sorted _appropriately for their type_ (i.e., chronologically for dates and times, numerically for numbers, alphabetically for text strings):
>     
>     
>     REBOL []
>     probe sort [1 11 111 2 22 222 8 9 5]  ; sorted NUMERICALLY
>     probe sort ["1" "11" "111" "2" "22" "222" "8" "9" "5"]  ; ALPHABETICALLY
>     probe sort [1-jan-2012 1-feb-2012 1-feb-2011]  ; sorted CHRONOLOGICALLY
>     halt
>     
> 
> To sort by the _first column_ in a table, use the "sort/skip" refinement. The table below is made up of 5 rows of 3 conceptual columns, so the first item of each row is found by skipping every 3 values:
>     
>     
>     REBOL []
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     editor sort/skip users 3
>     
> 
> Sorting by any other selected column requires that data be restructured into _blocks of blocks_ which clearly define the column structure. For example, this "flat" table, although visually clear, is really just a consecutive list of 15 data items:
>     
>     
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     
> 
> To sort it by colomn, the data must be represented as follows (notice that conceptual rows are now separated into discrete blocks of 3 columns of data):
>     
>     
>     blocked-users: [
>         ["John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"]
>         ["Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"]
>         ["Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"]
>         ["George Jones" "456 Topforge Court Mountain Creek, CO" ""]
>         ["Tim Paulson" "" "555-5678"]
>     ]
>     
> 
> The following code demonstrates how to convert a flattened block into such a structure of nested row/column blocks:
>     
>     
>     REBOL []
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     blocked-users: copy []
>     foreach [name address phone] users [
>         ; APPEND/ONLY inserts blocks as blocks, instead of as individual items
>         ; The REDUCE function convert the words "name", "address", and "phone"
>         ; to text values:
>         append/only blocked-users reduce [name address phone]
>     ]
>     editor blocked-users
>     
> 
> Now you can use the "/compare" refinement of the sort function to sort by a chosen column (field):
>     
>     
>     REBOL []
>     blocked-users: [
>         ["John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"]
>         ["Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"]
>         ["Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"]
>         ["George Jones" "456 Topforge Court Mountain Creek, CO" ""]
>         ["Tim Paulson" "" "555-5678"]
>     ]
>     field: 2                          ; column to sort (address, in this case)
>     sort/compare blocked-users func [a b] [(at a field) < (at b field)]
>     editor blocked-users                ; sorted by the 2nd field (by address)
>     
> 
> To sort in the opposite direction (i.e., descending, as opposed to ascending), just change the "<" operater to ">":
>     
>     
>     REBOL []
>     blocked-users: [
>         ["John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"]
>         ["Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"]
>         ["Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"]
>         ["George Jones" "456 Topforge Court Mountain Creek, CO" ""]
>         ["Tim Paulson" "" "555-5678"]
>     ]
>     field: 2
>     sort/compare blocked-users func [a b] [(at a field) > (at b field)]
>     editor blocked-users
>     
> 
> Here's a complete example that converts a flat data block to a nested block of blocks, and then sorts by a user-selected field, in a chosen ascending/descending direction:
>     
>     
>     REBOL [title: "View Sorted Users"]
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     blocked-users: copy []
>     foreach [name address phone] users [
>         append/only blocked-users reduce [name address phone]
>     ]
>     field: to-integer request-list "Choose Field To Sort By:" ["1" "2" "3"]
>     order: request-list "Ascending or Descending:" ["ascending" "descending"]
>     either order = "ascending" [
>         sort/compare blocked-users func [a b] [(at a field) < (at b field)]
>     ][
>         sort/compare blocked-users func [a b] [(at a field) > (at b field)]
>     ]
>     editor blocked-users
>     
> 
> Here's a version of the program above that uses code from the "Contacts" app presented earlier, which allows you to enter your own "users" contact info, and then sort and display it as above:
>     
>     
>     REBOL [title: "Sort My Stored Contacts"]
>     
>     ; This code is borrowed from the "Contacts" program seen earlier:
>     
>     forever [
>         name: request-text/title "Name:"
>         if name = "" [break]
>         address: request-text/title "Address:"
>         phone: request-text/title "Phone:"
>         write/append %contacts.txt rejoin [
>             mold name " " mold address " " mold phone " "
>         ]
>     ]
>     users: load %contacts.txt
>     
>     ; This is a variation of the code above:
>     
>     blocked-users: copy []
>     foreach [name address phone] users [
>         append/only blocked-users reduce [name address phone]
>     ]
>     field-name: request-list "Choose Field To Sort By:" [
>         "Name" "Address" "Phone"
>     ]
>     
>     ; The "select" function chooses the next value in a list, selected by the
>     ; user.  In this case if the field-name variable equals "name", the
>     ; "field" variable is set to 1.  If the field-name variable equals
>     ; "address", the "field" variable is set to 2.  If field-name="phone", the
>     ; "field" variable is set to 3:
>     
>     field: select ["name" 1 "address" 2 "phone" 3] field-name
>     
>     order: request-list "Ascending or Descending:" ["ascending" "descending"]
>     either order = "ascending" [
>         sort/compare blocked-users func [a b] [(at a field) < (at b field)]
>     ][
>         sort/compare blocked-users func [a b] [(at a field) > (at b field)]
>     ]
>     editor blocked-users
>     
> 
> Note again that REBOL sorts data appropriately, _according to type_. If numbers, dates, times, and other recognized data types are stored as string values, the sort will be _alphabetical_ for the chosen field (because that is the appropriate sort order for text):
>     
>     
>     REBOL []
>     text-data: [
>         "1"    "1-feb-2012"  "1:00am"   "abcd"
>         "11"   "1-mar-2012"  "1:00pm"   "bcde"
>         "111"  "1-feb-2013"  "11:00am"  "cdef"
>         "2"    "1-mar-2013"  "13:00"    "defg"
>         "22"   "2-feb-2012"  "9:00am"   "efgh"
>         "222"  "2-feb-2009"  "11:00pm"  "fghi"
>     ]
>     blocked: copy []
>     foreach [number date time string] text-data [
>         append/only blocked reduce [number date time string]
>     ]
>     field-name: request-list "Choose Field To Sort By:" [
>         "number" "date" "time" "string"
>     ]
>     field: select ["number" 1 "date" 2 "time" 3 "string" 4] field-name
>     order: request-list "Ascending or Descending:" ["ascending" "descending"]
>     either order = "ascending" [
>         sort/compare blocked func [a b] [(at a field) < (at b field)]
>     ][
>         sort/compare blocked func [a b] [(at a field) > (at b field)]
>     ]
>     editor blocked
>     
> 
> Convert values to appropriate data types during the process of blocking the "flattened" data, and fields will magically be sorted appropriately (in numerical, chronological, or other data-type-appropriate order):
>     
>     
>     REBOL []
>     text-data: [
>         "1"    "1-feb-2012"  "1:00am"   "abcd"
>         "11"   "1-mar-2012"  "1:00pm"   "bcde"
>         "111"  "1-feb-2013"  "11:00am"  "cdef"
>         "2"    "1-mar-2013"  "13:00"    "defg"
>         "22"   "2-feb-2012"  "9:00am"   "efgh"
>         "222"  "2-feb-2009"  "11:00pm"  "fghi"
>     ]
>     blocked: copy []
>     foreach [number date time string] text-data [
>         append/only blocked reduce [
>             to-integer number
>             to-date date
>             to-time time
>             string
>         ]
>     ]
>     field-name: request-list "Choose Field To Sort By:" [
>         "number" "date" "time" "string"
>     ]
>     field: select ["number" 1 "date" 2 "time" 3 "string" 4] field-name
>     order: request-list "Ascending or Descending:" ["ascending" "descending"]
>     either order = "ascending" [
>         sort/compare blocked func [a b] [(at a field) < (at b field)]
>     ][
>         sort/compare blocked func [a b] [(at a field) > (at b field)]
>     ]
>     editor blocked
>     

### 2.11 CSV Files and the "Parse" Function

> "Comma Separated Value" (CSV) files are a universal text format used to store and transfer tables of data. Spreadsheets, database systems, financial software, and other business applications typically can export and import tabular data to and from CSV format.
> 
> In CSV files, rows of data are separated by a line break. Column values are most often enclosed in quotes and separated by a comma or other "delimiter" character (sometimes a tab, pipe (|), or other symbol that visually separates the values).
> 
> #### 2.11.1 Saving Tabular Data Blocks to CSV Files
> 
> You can _create_ a CSV file from a block of REBOL table data, using the "foreach" function. Just rejoin each molded value (value enclosed in quotes), with commas separating each item, and a newline after each row, into a long text string. Then save the string to a file with the extension ".csv":
>     
>     
>     REBOL [title: "Save CSV"]
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     foreach [name address phone] users [
>         write/append %users.csv rejoin [
>             mold name ", " mold address ", " mold phone newline
>         ]
>     ]
>     
> 
> Try opening the file above with Excel or another spreadsheet application. Because the particular values in this data block _contain commas_ within the address field, you may need to select "comma", "space", and "merge delimiters", or similar options, in programs such as OpenOffice Calc.
> 
> #### 2.11.2 Loading Tabular Data Blocks From CSV Files
> 
> To _import_ CSV files into REBOL, use the "read/lines" function to read the file contents, with one text line per item stored in the resulting block. Assign the results of the read/lines function to a variable label. Use "foreach" and REBOL's "parse" function to separate each item in the lines back to individual values. Collect all the resulting sequential values into an empty block, and you're ready to use the data in all the ways you've seen so far:
>     
>     
>     REBOL [title: "Load CSV - Flat"]
>     block: copy []
>     csv: read/lines %users.csv
>     foreach line csv [
>         data: parse line ","
>         append block data
>     ]
>     probe block
>     foreach [name address phone] block [
>         alert rejoin [name ": " address " " phone]
>     ]
>     halt
>     
> 
> The first parameter of the parse function is the data to be parsed (in the case above, each line of the CSV file). The second parameter is the delimiter character(s) used to separate each value. Assign a variable to the output of the parse function, and you can refer to each individual value as needed (using "pick" and other series functions). The code above creates a "flat" block. To create a block of blocks, in which each line of the CSV file is delineated into a separate interior (nested) block, just use the append/only function, as you've seen earlier:
>     
>     
>     REBOL [title: "Load CSV - Block of Blocks"]
>     block: copy []
>     csv: read/lines %users.csv
>     foreach line csv [
>         data: parse line ","
>         append/only block data
>     ]
>     probe block
>     foreach line block [probe line]
>     halt
>     
> 
> Parse's "/all" refinement can be used to control how spaces and other characters are treated during the text splitting process (for example, if you want to separate the data at commas contained within each quoted text string). You can use the "trim" function to eliminate extra spaces in values. Other functions such as "replace", "to-(value)", and conditional evaluations, for example, can be useful in converting, excluding, and otherwise processing imported CSV data.
> 
> Try downloading account data from Paypal, or export report values from your financial software, and you'll likely see that the most prominent format is CSV. Accountants and others who use spreadsheets to crunch numbers will be able to instantly use CSV files in Excel, and/or export worksheet data to CSV format, for you to import and use in REBOL programs.
> 
> You'll learn much more about the extremely powerful "parse" function later. For now, it provides a simple way to import data stored in the common CSV format.

### 2.12 Two Paypal Report Programs, Analyzed

> Take a look at the Paypal code examples you've seen so far in this text. You should be able to follow the code a bit now:
>     
>     
>     REBOL [title: "Paypal Report"]
>     
>     ; A variable used to calculate the sum is initially set to zero dollars:
>     
>     sum: $0
>     
>     ; A foreach loop goes through every line in the downloaded CSV file,
>     ; starting at the second line (the first line contains columns labels):
>     
>     foreach line (at (read/lines http://re-bol.com/Download.csv) 2) [
>     
>         ; The sum is computed, using the money value in column 8:
>     
>         sum: sum + to-money pick (parse/all line ",") 8
>     
>     ]
>     
>     ; The user is alerted with the total:
>     
>     alert form sum
>     
> 
> Here's the whole program, without comments:
>     
>     
>     REBOL [title: "Paypal Report"]
>     sum: $0
>     foreach line (at (read/lines http://re-bol.com/Download.csv) 2) [
>         sum: sum + to-money pick (parse/all line ",") 8
>     ]
>     alert form sum
>     
> 
> This example deals with several different columns, and performs conditional evaluations on the name and time fields:
>     
>     
>     REBOL [title: "Paypal Reports"]
>     
>     ; Variables used to calculate 2 different sums are initially set to $0:
>     
>     sum1: sum2: $0
>     
>     ; A foreach loop goes through every line in the downloaded CSV file,
>     ; starting at the second line (the first line contains columns labels):
>     
>     foreach line at read/lines http://re-bol.com/Download.csv 2 [
>     
>         ; The first sum is computed, using the money value in column 8:
>     
>         sum1: sum1 + to-money pick row: parse/all line "," 8
>     
>         ; If the name column (col #4) contains the text "Saoud", print a
>         ; a concatenated message.  That message text consists of the date
>         ; (column 1), the characters ", Saoud Gorn: ", and the money value
>         ; in column 8:
>     
>         if find row/4 "Saoud" [print rejoin [row/1 ", Saoud Gorn: " row/8]]
>     
>         ; If the name column contains "Ourliptef.com", then perform an
>         ; additional conditional evaluation checking if the time field value
>         ; (column 2) is between midnight and noon.  If so, add to the sum2
>         ; variable the money value in column 8:
>     
>         if find row/4 "Ourliptef.com" [
>             time: to-time row/2
>             if (time >= 0:00am) and (time <= 12:00pm) [
>                 sum2: sum2 + to-money row/8
>             ]
>         ]
>     
>     ]
>     
>     ; Alert the user with some concatenated messages displaying the sums:
>     
>     alert join "GROSS ACCOUNT TRANSACTIONS: " sum1
>     alert join "2012 Ourliptef.com Morning Total: " sum2
>     
> 
> Here's the whole program, without comments:
>     
>     
>     REBOL [title: "Paypal Reports"]
>     sum1: sum2: $0
>     foreach line at read/lines http://re-bol.com/Download.csv 2 [
>         sum1: sum1 + to-money pick row: parse/all line "," 8
>         if find row/4 "Saoud" [print rejoin [row/1 ", Saoud Gorn: " row/8]]
>         if find row/4 "Ourliptef.com" [
>             time: to-time row/2
>             if (time >= 0:00am) and (time <= 12:00pm) [
>                 sum2: sum2 + to-money row/8
>             ]
>         ]
>     ]
>     alert join "GROSS ACCOUNT TRANSACTIONS: " sum1
>     alert join "2012 Ourliptef.com Morning Total: " sum2
>     
> 
> To see the data these scripts are sorting through, take a look at the raw data in the Download.csv file.

### 2.13 Some Perspective about Studying These Topics

> The List and Table Data topics are the most difficult sections in the first half of the tutorial. They will likely require several readings to be fully understood. Start by skimming once, and become familiar with the basic language structures and general code patterns. During the first read, you should be aware that demonstrated functions and code snippets can simply be copied, altered, and pasted for use in other applications. You don't need to memorize or even thoroughly understand how each line of code works. Instead, it's more important to understand that the functions and block/table concepts contained here simply exist and produce the described results. You will learn and interalize the details only by rote, through an extended period of reading, studying, copying, altering, and eventually writing fluently. There is a lot of material here to consume. It will likely take numerous applied hours of coding to fully understand it all.
> 
> You may find small snippets of code which provide solutions for the initial problem(s) and curiosities that motivated you to "learn how to program". Spend extra time experimenting with those pieces of code that are most interesting and relevant to your immediate needs. Copy, paste, and _run examples in the REBOL interpreter_. Get used to _editing and altering_ pieces of code to become more familiar with the syntax. Change variable labels, enter new data values, and try repurposing code examples to fit new data sets. Try to _break_ working code and figure out how to _fix_ it. Get used to _USING the REBOL text editor and the interpreter console_. Get your hands dirty and bury yourself in the mechanics of _typing and running code_. Becoming comfortable with the tool set and working environment is huge part of the battle.
> 
> You will learn REBOL and all other programming languages in the exact same way you would learn any spoken language: by "speaking" it. You must mimic at first (copy/paste code), and then learn to put together "phrases" that make sense (edit, experiment, and rearrange words), and eventually write larger compositions fluently. You will regularly make mistakes with function syntax as you learn to code, just as children make mistakes with grammar as they learn to speak. You'll only learn by experimenting creatively, and by experiencing errors.
> 
> It's important not to let initial confusion and error stop you from learning at this point. Use the materials in this section as a reference for looking up functions and syntax as you progress through the tutorial. Try to understand some key points about the structure of the language, especially the code patterns related to block and table operations, but realize that you'll only internalize so much detail during your first read. Acquire as much understanding and experiment with code as much as your curiosity and motivation allows, then move on and see how other important topics fit together to form useful coding skills.
> 
> Once you've made it past the next few sections, and in particular the complete programs section, you will have gotten a solid overview of how all the fundamental concepts are put to use. It's a good idea to review the entire first part of the tutorial at that point, paying closer attention to the fine details of each line of code, memorizing functions, immersing yourself in the logic of each word's operation, etc. For now, read and understand the general conceptual overview, and try not to get stuck on any single topic.
> 
> For more information about using lists and tables of data in REBOL, see http://www.rebol.com/docs/core23/rebolcore-6.html.

## 3\. Using GUI Windows and Widgets to Input and Display Data

> You've already seen how a number of functions can be used to display and request information from the user (print, request-text, request-list, editor, etc.). For simple utilities, these input/output functions are often all that's needed to build functional scripts. To create more complex programs that allow for both increasingly complex data entry, and increased ease of use, "GUI" or Graphic User Interfaces are typically employed. GUIs are windows, forms, and data entry screens that typically contain "widgets" such as text fields, buttons, drop down selectors, multi-line text areas, data grids, menus, and other recognizable visual components. The requestors you've seen so far are very simple types of GUIs, but they only accept single units of data. Windowed GUIs allow users to view and edit multiple fields of data on a single screen. This tends to be more efficient and less error prone than responding to sequential requests for input, and is the "normal" interface expected by users of business applications. GUI coding requires quite a bit of core knowledge in most programming languages. REBOL makes it _easy_ (in fact, REBOL provides absolutely the simplest way to create GUIs with code).

### 3.1 Basic Layout Guidelines and Widgets

> To create a program window, paste the the following code into the REBOL editor and press [F5] to save and run:
>     
>     
>     REBOL []
>     view layout [size 600x440]
>     
> 
> To center a program window on your computer screen, use "center-face"
>     
>     
>     REBOL []
>     view center-face layout [size 600x440]
>     
> 
> You can put a title in your program header, which will appear in the title bar of your program window:
>     
>     
>     REBOL [title: "My Program"]
>     view center-face layout [size 600x440]
>     
> 
> By default, REBOL program windows have a gray backdrop. You can change that using the "backdrop" word:
>     
>     
>     REBOL [title: "My Program"]
>     view center-face layout [size 600x440  backdrop white]
>     
> 
> Instead of the "backdrop" word, you can use the following code to change the default color for _all_ items in a GUI. This provides a slightly cleaner feel than REBOL's default grey color:
>     
>     
>     svv/vid-face/color: white
>     
> 
> Here's how you add "widgets" (buttons, text fields, multi-line text areas, drop down lists, etc.) to your program window. Notice that everything in the GUI window code is still contained between square brackets, but it has all been indented 4 spaces. Indentation is not required for multi-line block sections, but makes the code easier to read, and is expected. Notice also that the window sizes automatically to fit the contained widgets:
>     
>     
>     REBOL [title: "My Program"]
>     svv/vid-face/color: white
>     view center-face layout [
>         field "Type Here"
>         area "Multi^/line^/text"
>         text-list data ["first" "second" "third"]
>         image logo.gif   ; this image is built into REBOL
>         btn "Click Me"
>     ]
>     
> 
> You can adjust the size, color, and other properties of a widget by including modifiers next to each widget. Notice the GUI window automatically expands to fit resized widgets:
>     
>     
>     REBOL [title: "My Program"]
>     svv/vid-face/color: white
>     view center-face layout [
>         field 600 "Type Here"
>         area 600 "Multi^/line^/text"
>         text-list 600 data ["first" "second" "third"]
>         image purple logo.gif
>         btn red 100 "Click Me"
>     ]
>     
> 
> By default, REBOL places widgets below one another in the program window. You can align widgets horizontally using the "across" word. You can change back to the default vertical positioning with the word "below":
>     
>     
>     REBOL []
>     view center-face layout [
>         across
>         text-list 194
>         text-list 194
>         text-list 194
>         below
>         field 600
>         area 600
>         across
>         text "" 368
>         btn 50 "First"
>         btn 50 "Next"
>         btn 50 "Prev"
>         btn 50 "Last"
>     ]
>     
> 
> You can change the default starting position of widgets placed on screen using the "origin" word, and adjust default spacing using the "space" word:
>     
>     
>     REBOL []
>     view center-face layout [
>         size 251x251
>         origin 0x0
>         space 100x100
>         across
>         btn 50x50
>         btn 50x50
>         return
>         btn 50x50
>         btn 50x50
>         origin 50x50
>         btn 50x50
>         btn 50x50
>         return
>         btn 50x50
>         btn 50x50
>     ]
>     
> 
> You can place widgets at a specific coordinate using the "at" word:
>     
>     
>     REBOL []
>     view center-face layout [
>         at 20x50 btn
>         at 70x100 btn
>         at 130x150 btn
>     ]
>     

### 3.2 Breathing Life Into GUI Programs - Performing Actions

> Put function words in a block (between square brackets) after GUI widgets, and that function's action will be performed whenever the widget is clicked with a mouse, submitted with the keyboard, or otherwise activated. Notice that the word "value" holds the current/selected value in each widget:
>     
>     
>     REBOL [title: "My Program"]
>     svv/vid-face/color: white
>     view center-face layout [
>         field "Type Here" [alert value]
>         area "Multi^/line^/text" [alert value]
>         text-list data ["first" "second" "third"] [alert value]
>         image logo.gif [alert "Nice logo"]
>         btn "Click Me" [alert "Clicked"]
>     ]
>     
> 
> You can give any widget a variable label and change a labeled widget's text using the "/text" refinement, followed by a colon. Whenever you make changes to a window's appearance, you must use the "show" function to update the display:
>     
>     
>     REBOL []
>     view layout [
>         size 600x400
>         field1: field "field 1"  ; this field is labeled "field1"
>         btn "change field1's text" [
>     
>             ; These actions occur when the button is pressed:
>     
>             field1/text: "You just changed field 1's text!"
>             show field1
>         ]
>     ]
>     
> 
> You can read text from a file into a text area, using the "read" function. In REBOL, file names are always preceded by the percent symbol ("%"):
>     
>     
>     REBOL []
>     view layout [
>         a: area  ; this area is labeled "a"
>         btn "Read" [
>     
>             ; When btn is clicked, a's text is set to data read from file:
>     
>             a/text: read %temp.txt
>             show a
>         ]
>     ]
>     
> 
> You can write text from a text area to a file, using the "write" function:
>     
>     
>     REBOL []
>     view layout [
>         a: area 
>         btn "Save" [
>     
>             ; When btn is clicked, write to temp.txt file, the text in area:
>     
>             write %temp.txt a/text
>             alert "Saved"
>         ]
>     ]
>     
> 
> IMPORTANT: GUI text fields are only able to display _text_ ("string") values. Note that the following program produces errors because the values returned by the requestors are NOT string values, but rather other data types recognized by REBOL (file, date, tuple, etc. values):
>     
>     
>     REBOL []
>     view layout [
>         btn "File" [
>             f1/text: request-file
>             show f1
>         ]
>         f1: field
>         btn "Date" [
>             f2/text: request-date  
>             show f2
>         ]
>         f2: field
>         btn "Color" [
>             f3/text: request-color
>             show f3
>         ]
>         f3: field    
>     ]
>     
> 
> When copying formatted text values into a text area, use the "form" function to convert data to a text string:
>     
>     
>     REBOL []
>     view layout [
>         btn "File" [
>     
>             ; when btn pressed, set text of field 1 to selected file name:
>     
>             f1/text: form request-file   ; FORM converts file name to text
>             show f1
>         ]
>         f1: field
>         btn "Date" [
>     
>             ; set text of field 2 to selected date:
>     
>             f2/text: form request-date   ; FORM converts date value to text
>             show f2
>         ]
>         f2: field
>         btn "Color" [
>     
>             ; set text of field 3 to selected color:
>     
>             f3/text: form request-color  ; FORM converts color value to text
>             show f3
>         ]
>         f3: field    
>     ]
>     
> 
> You can change other properties of a widget, beyond just the text. Change the coordinate position of a widget using the "/offset" refinement, change it's size using the "/size" refinement, just as you alter it's text using the "/text" refinement. The word "face" allows a widget to refer to itself. In the code below, a button widget changes it's own position, size, and text when clicked:
>     
>     
>     REBOL []
>     view layout [
>         size 594x440 
>         btn "click me" [
>             face/offset: 200x300
>             face/size: 150x50
>             face/text: "I've moved and changed!"
>             show face 
>         ]
>     ]
>     
> 
> The "style" word allows you to create _new widgets_ with predefined properties and actions. Here, the label "green-button" is defined as a green btn widget with the text "click me", which when clicked, jumps to a random coordinate within the range 580x420:
>     
>     
>     REBOL []
>     view layout [
>         size 594x440 
>     
>         style green-button btn green "click me" [
>             face/offset: random 580x420
>             show face
>         ]
>     
>         ; The word "green-button" now refers to all the above code.  Every
>         ; "green-button" shares the same color and text properties, and
>         ; PERFORMS THE SAME ACTIONS when clicked.
>     
>         at 254x84 green-button
>         at 19x273 green-button
>         at 85x348 green-button
>         at 498x12 green-button
>         at 341x385 green-button
>     ]
>     
> 
> Here's a little puzzle example, with detailed comments describing the layout and thought processes behind every action in the code:
>     
>     
>     REBOL [title: "Sliding Puzzle"]
>     
>     ; Create a GUI that's centered on the user's screen:
>     
>     view center-face layout [
>     
>         ; Define some basic layout parameters.  "origin 0x0" 
>         ; starts the layout in the upper left corner of the
>         ; GUI window.  "space 0x0" dictates that there's no
>         ; space between adjacent widgets, and "across" lays
>         ; out consecutive widgets next to each other:
>     
>         origin 0x0  space 0x0  across 
>     
>         ; The section below creates a newly defined button
>         ; widget called "piece", with an action block that 
>         ; swaps the current button's position with that of 
>         ; the adjacent empty space.  That action is run
>         ; whenever one of the buttons is clicked:
>     
>         style piece button 60x60 [
>     
>             ; The lines below check to see if the clicked button
>             ; is adjacent to the empty space.  The "offset" 
>             ; refinement contains the position of the given 
>             ; widget.  The word "face" is used to refer to the
>             ; currently clicked widget.  The "empty" button is
>             ; defined later (at the end of the GUI layout).
>             ; It's ok that the empty button is not yet defined,
>             ; because this code is not evaluated until the
>             ; the entire layout is built and "view"ed:
>     
>             distance: (face/offset - empty/offset)
>             if not find [0x60 60x0 0x-60 -60x0] distance [exit]
>     
>             ; In English, that reads 'subtract the position of
>             ; the empty space from the position of the clicked
>             ; button (the positions are in the form of 
>             ; Horizontal x Vertical coordinate pairs).  If that 
>             ; difference isn't 60 pixels on one of the 4 sides,
>             ; then don't do anything.' (60 pixels is the size of
>             ; the "piece" button defined above.)
>     
>             ; The next three lines swap the positions of the 
>             ; clicked button with the empty button.
>     
>             ; First, create a variable to hold the current
>             ; position of the clicked button:
>     
>             temp: face/offset  
>     
>             ; Next, move the button's position to that of the 
>             ; current empty space:
>     
>             face/offset: empty/offset 
>     
>             ; Last, move the empty space (button), to the old
>             ; position occupied by the clicked button:
>     
>             empty/offset: temp
>         ]
>     
>         ; The lines below draw the "piece" style buttons onto 
>         ; the GUI display.  Each of these buttons contains all
>         ; of the action code defined for the piece style above:
>     
>         piece "1"   piece "2"   piece "3"   piece "4" return
>         piece "5"   piece "6"   piece "7"   piece "8" return
>         piece "9"   piece "10"  piece "11"  piece "12" return
>         piece "13"  piece "14"  piece "15"
>     
>         ; Here's the empty space.  Its beveled edge is removed
>         ; to make it look less like a movable piece, and more
>         ; like an empty space:
>     
>         empty: piece 200.200.200 edge [size: 0]
>     ]
>     
> 
> Here's the whole program without comments. It's tiny:
>     
>     
>     REBOL [title: "Sliding Puzzle"]
>     view center-face layout [    
>         origin 0x0 space 0x0 across   
>         style piece button 60x60 [
>             if not find [0x60 60x0 0x-60 -60x0] (face/offset - e/offset)[exit]
>             temp: face/offset
>             face/offset: e/offset 
>             e/offset: temp
>         ]
>         piece "1"   piece "2"   piece "3"   piece "4" return
>         piece "5"   piece "6"   piece "7"   piece "8" return
>         piece "9"   piece "10"  piece "11"  piece "12" return
>         piece "13"  piece "14"  piece "15"
>         e: piece 200.200.200 edge [size: 0]
>     ]
>     

### 3.3 GUI Language Reference

> Here are all the main GUI words built in to REBOL's GUI dialect (called "VID") that you should get to know. The first block of "styles" contains all the predefined widgets available. The layout words affect how and where items are positioned, and other layout preferences. The attribute words adjust the appearance and function of widgets. The style facets adjust some specific options that are available for individual widgets:
>     
>     
>     STYLES-WIDGETS: [
>         face blank-face IMAGE BACKDROP BACKTILE BOX BAR SENSOR KEY BASE-TEXT
>         VTEXT TEXT BODY TXT BANNER VH1 VH2 VH3 VH4 LABEL VLAB LBL LAB TITLE
>         H1 H2 H3 H4 H5 TT CODE BUTTON CHECK CHECK-MARK RADIO CHECK-LINE
>         RADIO-LINE LED ARROW TOGGLE ROTARY CHOICE DROP-DOWN ICON FIELD INFO
>         AREA SLIDER SCROLLER PROGRESS PANEL LIST TEXT-LIST ANIM BTN BTN-ENTER
>         BTN-CANCEL BTN-HELP LOGO-BAR TOG
>     ]
>     
>     LAYOUT-WORDS: [
>         return at space pad across below origin guide tab tabs indent style
>         styles size backcolor backeffect do
>     ]
>     
>     STYLE-FACETS--ATTRIBUTES: [
>         edge font para doc feel effect effects keycode rate colors texts help
>         user-data with bold italic underline left center right top middle
>         bottom plain of font-size font-name font-color wrap no-wrap as-is
>         shadow frame bevel ibevel
>     ]
>     
>     SPECIAL-STYLE-FACETS: [
>         ARROW: [up right down left]  ROTARY: data  CHOICE: data  DROP-DOWN: 
>         [data rows]  FIELD: hide  INFO: hide  AREA: hide  LIST: [supply map
>         data]  TEXT-LIST: data  ANIM: [frames rate]
>     ]
>     
> 
> You can obtain the word lists above using the following lines of code:
>     
>     
>     probe extract svv/vid-styles 2
>     probe remove-each i copy svv/facet-words [function? :i]
>     probe svv/vid-words
>     
> 
> By default, all REBOL GUIs contain the text "REBOL - " in the window title bar. In Windows, you can eliminate that text with the following code. Just set the "tt" variable to hold the title text you want displayed:
>     
>     
>     tt: "Your Title"
>     user32.dll: load/library %user32.dll
>     gf: make routine![return:[int]]user32.dll"GetFocus"
>     sc: make routine![hw[int]a[string!]return:[int]]user32.dll"SetWindowTextA"
>     so: :show show: func[face][so[face]hw: gf sc hw tt]
>     
> 
> The widgets and techniques you've seen so far are enough to create an overwhelming majority of potentially useful windowed business applications. Here's a collection of useful pieces of code demonstrating how to accomplish various common tasks in GUIs, and some other available widgets. Every piece of code in these examples will be explained in greater detail later in the tutorial. For now, just paste and run these examples to see what they do, and keep the code handy for use when needed:
>     
>     
>     REBOL [title: "GUI Reference"]
>     print "GUI Output:^/"
>     view center-face layout [
>         h1 "Some More GUI Widgets:"
>         box red 500x2
>         drop-down 200 data system/locale/months [
>             a/text: join "Month:  " value show a
>         ]
>         a: field
>         slider 200x18 [bar1/data: value show bar1]
>         bar1: progress
>         scroller 200x16 [bar2/data: value show bar2]
>         bar2: progress
>         across 
>         toggle "Click here" "Click again" [print value]
>         rotary "Click" "Again" "And Again" [print value]
>         choice "Choose" "Item 1" "Item 2" "Item 3" [print value]
>         return
>         x: radio y: radio z: radio
>         btn "Get Radio States" [print [x/data y/data z/data]]
>         return
>         led
>         arrow
>         below
>         code "Code text"
>         tt "Typewriter text"
>         text "Little Text" font-size 8
>         title "Centered title" 500
>     ]
>     
>     ; The word "value" refers to data contained in a currently active widget:
>     
>     view layout [
>         text "Some widgets with values and size/color properties.  Try them:"
>         button red "Click Me" [alert "You clicked the red button."]
>         f: field 400 "Type some text here, then press the [Enter] key" [
>             alert value                 ; SAME AS alert f/text
>         ]
>         t: text-list 400x300 "Select this line" "Then this one" "Now this" [
>             alert value                 ; SAME AS alert t/text
>         ]
>         check yellow [alert "You clicked the yellow check box."]
>         button "Quit" [alert "I don't want to stop yet!"]    
>     ]
>     
>     ; List Widget:
>     
>     y: read %.   c: 0   x: copy []
>     foreach i y [append/only x reduce [(c: c + 1) i (size? to-file i)]]
>     slider-pos: 0
>     view center-face layout [
>         across space 0
>         the-list: list 400x400 [
>             across  space 0x0
>             text 50 purple
>             text 250 bold [editor read to-file face/text]
>             text 100 red italic
>             return box green 400x1
>         ] supply [
>             count: count + slider-pos
>             if none? q: pick x count [face/text: none exit]
>             face/text: pick q index
>         ]
>         scroller 16x400 [
>             slider-pos: (length? x) * value
>             show the-list
>         ]
>     ]
>     
>     view layout [
>         h3 "Just a few effects - fit, flip, emboss:"
>         area 400x400 load http://rebol.com/view/bay.jpg effect [
>             Fit Flip Emboss              ; you can fit images on most widgets
>         ]
>     ]
>     
>     effects:  [
>       invert  contrast 40  colorize 0.0.200  gradcol 1x1 0.0.255 255.0.0
>       tint 100  luma -80  multiply 80.0.200  grayscale  emboss  flip 0x1 
>       flip 1x0  rotate 90  reflect 1x1  blur  sharpen  aspect  tile tile-view
>     ]
>     view layout [
>         area 400x400 wrap rejoin [
>             "And there are MANY more effects:" newline newline form effects
>         ]
>     ] 
>     
>     view layout [area effect [gradient red blue]]  ; gradients are color fades
>     view layout [
>         size 500x400
>         backdrop effect [gradient 1x1 tan brown]
>         box effect [gradient 123.23.56 254.0.12]
>         box effect [gradient blue gold/2]
>     ]
>     
>     view layout [
>         btn "Right/Left Click Me" [alert "left click"] [alert "right click"]
>     ]
>     
>     panels: layout [
>         across
>         btn "Fields"      [window/pane: pane1 show window]
>         btn "Text List"   [window/pane: pane2 show window]
>         return
>         window: box 400x200
>     ]
>     pane1: layout/tight [field 400 field 400 area 400]
>     pane2: layout/tight [text-list 400x200 data system/locale/days]
>     window/pane: pane1
>     view center-face panels
>     
>     svv/vid-face/color: white
>     alert "New global background color is now white."
>     
>     ; The word "offset" refers to a widget's coordinate position.
>     ; The word "style" builds a new widget with the specified style & actions:
>     
>     view center-face layout [
>         size 600x440 
>         h3 "Press the left or right arrow key"
>         key keycode [left]  [alert "You pressed the LEFT arrow key"]
>         key keycode [right] [alert "You pressed the RIGHT arrow key"]
>         btn #"a" "Click Me or Press the 'a' Key" [alert "clicked or pressed"]
>     ]
>     
>     ; Here's a little program to show all key codes:
>     
>     insert-event-func func [f e] [if e/type = 'key [print mold e/key] e]
>     view layout [text "Type keys to see their character/keycode"]
>     
>     ; How to refer to the main layout window:
>     
>     view gui: layout [
>         btn1: btn "Button 1"
>         btn2: btn "Remove all widgets from window" [
>             foreach item system/view/screen-face/pane/1/pane [
>                 remove find system/view/screen-face/pane/1/pane item
>             ]
>             show gui
>         ]
>     ]
>     
>     ; "Feel" and "Engage" together detect events:
>     
>     view layout [
>         text "Mouse me." feel [
>             engage: func [face action event] [
>                 if action = 'up [print "You just released the mouse."]
>             ]
>         ]
>     ]
>     
>     print "Click anywhere in the window, then click the text."
>     view center-face layout [
>         size 400x200
>         box 400x200 feel [
>             engage: func [f a e] [     ; f a e = face action event
>                 print rejoin ["Mouse " a " at " e/offset]
>             ]
>         ]
>         origin 
>         text "Click me" [print "Text clicked"] [print "Text right-clicked"]
>         box blue [print "Box clicked"]
>     ]
>     
>     movestyle: [                     ; generic click and drag code
>         engage: func [f a e] [
>             if a = 'down [
>                 initial-position: e/offset
>                 remove find f/parent-face/pane f
>                 append f/parent-face/pane f
>             ]
>             if find [over away] a [
>                 f/offset: f/offset + (e/offset - initial-position)
>             ]
>             show f
>         ]
>     ]
>     view layout/size [
>         style moveable-object box 20x20 feel movestyle
>         at random 600x400 moveable-object (random 255.255.255)
>         at random 600x400 moveable-object (random 255.255.255)
>         at random 600x400 moveable-object (random 255.255.255)
>         at random 600x400 moveable-object (random 255.255.255)
>         at random 600x400 moveable-object (random 255.255.255)
>         text "This text and all the boxes are movable" feel movestyle
>     ] 600x440
>     
>     ; The following box code creates a repeating, multitasking loop in a GUI.
>     ; The "within" function checks for graphic collisions:
>     
>     view center-face layout [
>         size 400x400
>         btn1: btn red
>         at 175x175 btn2: btn green
>         box 0x0 rate 0 feel [engage: func [f a e] [if a = 'time [
>             btn1/offset: btn1/offset + 5x5
>             show btn1
>             if within? btn1/offset btn2/offset 1x1 [alert "Collision" unview]
>         ]]]
>     ]
>     
>     view center-face layout [                    ; follow all mouse movements
>         size 600x440
>         at 270x209 b: btn "Click Me - Aha!" feel [
>             detect: func [f e] [
>                 if e/type = 'move [
>                     if (within? e/offset b/offset 59x22) [
>                         b/offset: b/offset + ((random 50x50) - (random 50x50))
>                         if not within? b/offset -59x-22 659x462 [
>                             b/offset: 270x209
>                         ]
>                         show b
>                     ]
>                 ]
>                 e
>             ]
>         ]
>     ]
>     
>     ; To trap other events (this example traps and responds to close events):
>     
>     closer: insert-event-func [
>         either event/type = 'close [
>             really: request "Really close the program?"
>             if really = true [remove-event-func :closer]
>         ] [event]  ; always return other events
>     ]
>     view center-face layout [
>         text "Close me"
>         size 600x400
>     ]
>     
>     insert-event-func [                    ; this example traps resize events
>         either event/type = 'resize [
>             fs: t1/parent-face/size
>             t1/offset: fs / 2x2
>             t2/offset: t1/offset - 50x25
>             t3/offset: t1/offset - 25x50
>             show gui  none
>         ] [event]
>     ]
>     svv/vid-face/color: white
>     view/options gui: layout [
>         text "Centered in resized window:"
>         across
>         t1: text "50x50"
>         t2: text "- 50x25"
>         t3: text "- 25x50"
>     ] [resize]
>     
>     ; Use "to-image" to create a SCREEN SHOT of any layout:
>     
>     picture: to-image layout [
>         page-to-read: field "http://rebol.com"
>         btn "Display HTML"
>     ]
>     save/png %layout.png picture     ; save the image to a file
>     browse %layout.png
>     
>     flash "Just waiting..."  wait 3  alert "Done waiting!"  unview
>     inform layout [btn "Click Me" [flash "Just waiting..." wait 3 unview]]
>     
>     ; Embed files (images, sounds, etc.) in code:
>     
>     alert "Select a picture from your hard drive:"
>     system/options/binary-base: 64
>     editor picture: compress to-string read/binary to-file request-file/only
>     view layout [image load (to-binary decompress picture)]
>     
>     ; This example embedded image was created with the script above:
>     
>     logo-pic: load to-binary decompress #{
>     789C018A0375FC89504E470D0A1A0A0000000D49484452000000640000001808
>     020000008360CFB90000001374455874536F667477617265005245424F4C2F56
>     6965778FD916780000033249444154789CD599217402310C86F7CE6227B1481C
>     1637874362B1382C1687C4A15168240A89C5A2B058ECDEBE47DFFA429276DCEE
>     10FDCD582F97267FD33F2D7CF47ABDCF32D1ED76E7F3F9ED76FB4EE0743A8D46
>     A3B6A683A80FFE540562381C1E8FC7144D12DBEDB6951C3B9D4E91648DC7E34C
>     41B925465D349C14A2CA230BA65EA729E27C3E37CCB43CB228905A3525B1DBED
>     9A4CED93851C7C193088A0667C0D0603FB5640BFDFB7F648C0D0836B1C41C22E
>     11D7EBF57038F074BFDF534429BE2693891B4626CE1C59BC7CB95CDC99EEF7FB
>     66B349F922D65A4B4A8DE0D0B547B9DD85212B6B4CB4D3E994B055FEE8943566
>     30134626BBDA64052C974BD757A637B1DA2E599959A05EE61F4032D62C55EFBC
>     6EED01878954188DC80AE714C07126D24F91BBBE6265A129B3D96C2A4085BB64
>     459FEBF51A1B2692E5A9FA17A428B562EBE595A1F29650AD5C6B9525FD4621E0
>     A95D73491606F9046C94101A06178B4518E19122023655DA184B03ECA15BE98E
>     6D9D302E536E8D2C96A5FF0061458FEE9EAA045958720EDCFC82CF145A9E2C7C
>     52BC6CF0503B8C2B2200DAACD24698A4B710361E6421930E05A85E9484BE51B3
>     0885AE9727CB22A5591981B73D1AC6A58D2ABD5892DF46C5993DCFF25BC8828E
>     14538AACEB3390A43C59D890213B5D2AA3D2AC3C59ABD54ACE2E85C29E36DE42
>     162B8C0AC47F0942B512972CCCF0D91170ED6594ECC130288549ED44744DE52C
>     771381C571D5AFEDB14B2E79CB022F13C834A056049EFCE35C2A7449877A2B00
>     2D872635082FEA2D267D8BC047AD910D3875CE9247078A826259FC8234F264E1
>     9FAD4AAC52015465D973193B3755B611B417FB562A0C66C77EF7001F5463FD83
>     2CF20F83B2B8E0C22DAE760FA556B32AAF87B86A18C18259CFAA3567C250C7C3
>     1AE72CD95350531BD93FAE3B6CEADB33188174FCBBD77B7B7A0841DAB6C3EBEE
>     F13DE8696B6455E222ADCE23F162ECF644064709A47AA8FD3632BFAD78EA5E92
>     D947500C3BB04CAD419F3D5B05580DC127118E3D2866CAFB8AC6CAFCEB68F895
>     56796455CF47AAD741F5B957D4D751245980BD569729B723D742A964558FFB4D
>     EAB6A440BF6ACE54157EB028F7A730B695BDF749D05EA9C1B612C4CF0F396EDC
>     8E943F5C020000000049454E44AE426082CAEBA2D78A030000
>     }
>     view layout [image logo-pic]
>     
>     write/append %s ""                          ; A very compact GUI program
>     view center-face g: layout [
>         h3 "Name:"   x: field   h3 "Info:"   z: area wrap   across
>         btn "Save" [do-face d 1  save %s  repend f [x/text z/text]]
>         btn "Load" [
>             c: request-list" Select:" extract (f: load %s) 2
>             if c = none [return]
>             x/text: first find f c  z/text: select f x/text  show g
>         ]
>         btn "New" [x/text: copy ""  z/text: copy ""  show g  focus x]
>         d: btn "Delete" [
>             if true = request "Sure?" [
>                 remove/part (find (f: load %s) x/text) 2 save %s f alert "ok"
>             ]
>         ]
>     ]
>     
>     ; Some examples of the "draw" dialect for creating graphics:
>     
>     view layout [
>         box 400x400 black effect [
>             draw [
>                 pen red
>                 line 0x400 400x50
>                 pen white
>                 box 100x20 300x380
>                 fill-pen green
>                 circle 250x250 100
>                 pen blue
>                 fill-pen orange
>                 line-width 5
>                 spline closed 3 20x20 200x70 150x200
>                 polygon 20x20 200x70 150x200 50x300
>             ]
>         ]
>     ]
>     
>     view layout [
>         box 400x220 effect [
>             draw [
>                 fill-pen 200.100.90
>                 polygon 20x40 200x20 380x40 200x80
>                 fill-pen 200.130.110
>                 polygon 20x40 200x80 200x200 20x100
>                 fill-pen 100.80.50
>                 polygon 200x80 380x40 380x100 200x200
>             ]
>             gradmul 180.180.210 60.60.90
>         ]
>     ]
>     view layout [
>         h3 "Draw On Me:"
>         scrn: box black 400x400 feel [
>             engage: func [face action event] [
>                 if find [down over] action [
>                     append scrn/effect/draw event/offset
>                     show scrn
>                 ]
>                 if action = 'up [append scrn/effect/draw 'line]
>             ]
>         ] effect [draw [line]]
>     ]
>     
>     pos: 300x300
>     view layout [
>         scrn: box pos black effect [
>             draw [image logo.gif 0x0 300x0 300x300 0x300]
>         ]
>         btn "Animate" [
>             for point 1 450 4 [
>                 scrn/effect/draw: copy reduce [
>                     'image logo.gif 
>                     (pos - 300x300)
>                     (1x1 + (as-pair 300 point))
>                     (pos - (as-pair 1 point))
>                     (pos - 300x0)
>                 ]
>                 show scrn
>             ]
>             scrn/effect/draw: copy [
>                 image logo.gif 0x0 300x0 300x300 0x300
>             ]
>             show scrn
>         ]
>     ]
>     
> 
> See http://rebol.com/docs/easy-vid.html and http://rebol.com/docs/view-guide.html for some additional information and examples demonstrating basic GUI techniques.

### 3.4 A Telling Comparison

> To provide a quick idea of how much easier REBOL is than other languages, here's a short example. The following code to create a basic program window with REBOL was presented earlier:
>     
>     
>     view layout [size 400x300]
>     
> 
> It works on every type of computer, in exactly the same way.
> 
> Code for the same simple example is presented below in the C++ language. It does the exact same thing as the REBOL one-liner above, except it only works on Microsoft Windows machines. If you want to do the same thing with a Macintosh computer, you need to memorize a completely different page of C++ code. The same is true for Linux or any other operating system. You have to learn enormous chunks of code to do very simple things, and those chunks of code are different for every type of computer. Furthermore, you typically need to spend a semester's worth of time learning very basic things about code syntax and fundamentals about how a computer 'thinks' before you even begin to tackle useful basics like the code below:
>     
>     
>     #include <windows.h>
>     
>     /*  Declare Windows procedure  */
>     LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);
>     
>     /*  Make the class name into a global variable  */
>     char szClassName[ ] = "C_Example";
>     
>     int WINAPI
>     WinMain (HINSTANCE hThisInstance,
>              HINSTANCE hPrevInstance,
>              LPSTR lpszArgument,
>              int nFunsterStil)
>     
>     {
>         HWND hwnd;               
>         /* This is the handle for our window */
>         MSG messages;            
>         /* Here messages to the application are saved */
>         WNDCLASSEX wincl;        
>         /* Data structure for the windowclass */
>     
>         /* The Window structure */
>         wincl.hInstance = hThisInstance;
>         wincl.lpszClassName = szClassName;
>         wincl.lpfnWndProc = WindowProcedure;      
>         /* This function is called by windows */
>         wincl.style = CS_DBLCLKS;                 
>         /* Catch double-clicks */
>         wincl.cbSize = sizeof (WNDCLASSEX);
>     
>         /* Use default icon and mouse-pointer */
>         wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION);
>         wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION);
>         wincl.hCursor = LoadCursor (NULL, IDC_ARROW);
>         wincl.lpszMenuName = NULL;                 
>         /* No menu */
>         wincl.cbClsExtra = 0;                      
>         /* No extra bytes after the window class */
>         wincl.cbWndExtra = 0;                      
>         /* structure or the window instance */
>         /* Use Windows's default color as window background */
>         wincl.hbrBackground = (HBRUSH) COLOR_BACKGROUND;
>     
>         /* Register window class. If it fails quit the program */
>         if (!RegisterClassEx (&wincl))
>             return 0;
>     
>         /* The class is registered, let's create the program*/
>         hwnd = CreateWindowEx (
>                0,                   
>                 /* Extended possibilites for variation */
>                szClassName,         
>                 /* Classname */
>                "C_Example",       
>                 /* Title Text */
>                WS_OVERLAPPEDWINDOW, 
>                 /* default window */
>                CW_USEDEFAULT,       
>                 /* Windows decides the position */
>                CW_USEDEFAULT,       
>                 /* where the window ends up on the screen */
>                400,                 
>                 /* The programs width */
>                300,                 
>                 /* and height in pixels */
>                HWND_DESKTOP,        
>                 /* The window is a child-window to desktop */
>                NULL,                
>                 /* No menu */
>                hThisInstance,       
>                 /* Program Instance handler */
>                NULL                
>                 /* No Window Creation data */
>                );
>     
>         /* Make the window visible on the screen */
>         ShowWindow (hwnd, nFunsterStil);
>     
>         /* Run the message loop. 
>             It will run until GetMessage() returns 0 */
>         while (GetMessage (&messages, NULL, 0, 0))
>         {
>             /* Translate virtual-key messages 
>                 into character messages */
>             TranslateMessage(&messages);
>             /* Send message to WindowProcedure */
>             DispatchMessage(&messages);
>         }
>     
>         /* The program return-value is 0 - 
>             The value that PostQuitMessage() gave */
>         return messages.wParam;
>     }
>     
>     /*  This function is called by the Windows 
>             function DispatchMessage()  */
>     
>     LRESULT CALLBACK
>     WindowProcedure (HWND hwnd, UINT message, 
>         WPARAM wParam, LPARAM lParam)
>     {
>         switch (message)                  
>         /* handle the messages */
>         {
>             case WM_DESTROY:
>                 PostQuitMessage (0);       
>                     /* send a WM_QUIT to the message queue */
>                 break;
>             default:                      
>                 /* for messages that we don't deal with */
>                 return DefWindowProc (hwnd, message, 
>                     wParam, lParam);
>         }
>     
>         return 0;
>     }
>     
> 
> Yuck. Back to REBOL...

## 4\. Quick Review and Clarification

> The list below summarizes some key characteristics of the REBOL language. Knowing how to put these elements to use constitutes a fundamental understanding of how REBOL works:
> 
>   1. To start off, REBOL has hundreds of built-in function words that perform common tasks. As in other languages, function words are typically followed by passed data parameters. Unlike other languages, passed parameters are placed immediately after the function word and are _not_ necessarily enclosed in parentheses. To accomplish a desired goal, functions are arranged in succession, one after another. The value(s) returned by one function are often used as the argument(s) input to another function. Line terminators are not required at any point, and all expressions are evaluated in left to right order, then vertically down through the code. Empty white space (spaces, tabs, newlines, etc.) can be inserted as desired to make code more readable. Text after a semicolon and before a new line is treated as a comment. You can complete significant work by simply knowing the predefined functions in the language, and organizing them into a useful order.
>   2. REBOL contains a rich set of conditional structures, which can be used to manage program flow and data processing activities. If, either, and other typical structures are supported.
>   3. Because many common types of data values are automatically recognized and handled natively by REBOL, calculating, looping, and making conditional decisions based upon data content is straightforward and natural to perform, without any external modules or toolkits. Numbers, text strings, money values, times, tuples, URLs, binary representations of images, sounds, etc. are all automatically handled. REBOL can increment, compare, and perform proper computations on most common types of data (i.e., the interpreter automatically knows that 5:32am + 00:35:15 = 6:07:15am, and it can automatically apply visual effects to raw binary image data, etc.). Network resources and Internet protocols (http documents, ftp directories, email accounts, dns services, etc.) can also be accessed natively, just as easily as local files. Data of any type can be written to and read from virtually any connected device or resource (i.e., "write %file.txt data" works just as easily as "write ftp://user:pass@website.com data", using the same common syntax). The percent symbol ("%") and the syntax "%(/drive)/path/path/.../file.ext" are used cross-platform to refer to local file values on any operating system.
>   4. Any data or code can be assigned a word label. The colon character (":") is used to assign word labels to constants, variable values, evaluated expressions, and data/action blocks of any type. Once assigned, variable words can be used to represent all of the data contained in the given expression, block, etc. Just put a colon at the end of a word, and thereafter it represents all the following data.
>   5. Multiple pieces of data are stored in "blocks", which are delineated by starting and ending brackets ("[]"). Blocks can contain data of _any_ type: groups of text strings, arrays of binary data, other enclosed blocks, etc. Data items contained in blocks are separated by white space. Blocks can be automatically treated as lists of data, called "series", and manipulated using built-in functions that enable searching, sorting, ordering, and otherwise organizing the blocked data. Blocks are used to delineate most of the syntactic structures in REBOL (i.e., actions resulting from conditional evaluations, GUI widget layouts, etc.).
>   6. "Foreach" function can be used to process lists and tables of data. Rows and columns if data in tables can be processed using the format: "foreach [col1 col2 col3...] table-block [do something to each row pof values]". Data can be saved to CSV files by rejoining molded (quoted) text and delimiters. CSV files can be read using the "read/lines" and "parse" functions. Sorting data by column with the sort/compare function requires that rows be saved in nested blocks, rather than as "flat" sequential lists of items. Data stored as (quoted) text string values is sorted alphabetically. Data stored or converted to specific data type values is sorted appropriately for the type.
>   7. The syntax "view layout [block]" is used to create basic GUI layouts. You can add widgets to the layout simply by placing widget identifier words inside the block: "button", "field", "text-list", etc. Color, position, spacing, and other facet words can be added after each widget identifier. Action blocks added immediately after any widget will perform the enclosed functions whenever the widget is activated (i.e., when the widget is clicked with a mouse, when the enter key pressed, etc.). Path refinements can be used to refer to items in the GUI layout (i.e., "face/offset" refers to the position of the selected widget face, "face/text" to it's text, etc.). Those simple guidelines can be used to create useful GUIs for data input and output, in a way that's native (doesn't require any external toolkits) and much easier than any other language.

## 5\. SOME COMPLETE GUI APPLICATION EXAMPLES

> The examples in this section were presented at the very beginning of the tutorial as demonstrations. At this point in the tutorial, _you should now be able to understand every bit of code in each program!_ Every example in this section is documented with detailed line-by-line explanations of what each function, variable, and language construct does. Run every example in the REBOL interpreter, and read every line of code, along with all the comments. Really pay attention to the material in this section - it's one of the most formative in the entire text. Not only are the applications useful as a basis for more personalized production pieces of software, the logic and code patterns demonstrated here will form a strong fundamental understanding about how to create other imagined pieces of software.

### 5.1 Generic Text Field Saver

> Little programs like this form the initial basis for all types of simple data entry app. The entered data is stored in CSV file format, so it can be easily opened by a spreadsheet or other program:
>     
>     
>     REBOL [title: "Text Field Saver"]
>     
>     ; The words "view layout" create a GUI window:
>     
>     view layout [
>     
>         ; Create 3 text fields widgets labeled f1, f2, and f3:
>     
>         f1: field
>         f2: field
>         f3: field
>     
>         ; Create a button widget:
>         btn "Save" [
>     
>             ; When the button is clicked, write to the file fields.txt some
>             ; rejoined text.  The /append refinement of the write function
>             ; ensures that data is ADDED to the end of the existing text file,
>             ; instead of erasing the file and writing totally new data to it.
>             ; If the fields.csv file doesn't exist, it's created:
>     
>             write/append %fields.csv rejoin [
>     
>                 ; The "mold" function surrounds text with quotes.
>                 ; So the concatenated text written to the fields.txt file
>                 ; includes the quoted text from each field widget above, 
>                 ; each separated by a comma and a quote, and completed with
>                 ; a carriage return:
>     
>                 mold f1/text ", " mold f2/text ", " mold f3/text newline
>     
>             ]
>     
>             ; Alert the user when the data has been saved:
>     
>             alert "Saved"
>     
>         ]
>     ]
>     
> 
> Here's the whole program without comments. It's tiny:
>     
>     
>     REBOL [title: "Text Field Saver"]
>     view layout [
>         f1: field
>         f2: field
>         f3: field
>         btn "Save" [
>             write/append %fields.txt rejoin [
>                 mold f1/text ", " mold f2/text ", " mold f3/text newline
>             ]
>             alert "Saved"
>         ]
>     ]
>     

### 5.2 Calculator

> This calculator is as basic as could be, but adding advanced math functions and other useful capabilities is easy. Imagine adding industry specific operations such as amortization calculations. The potential to add genuinely useful unique features is limitless (see the next example below, which performs currency conversion operations _that draw from current live rates on the Internet_, for example). At this point, try to understand the fundamental layout and operation of the GUI widgets:
>     
>     
>     REBOL [title: "Calculator"]
>     
>     ; Create a GUI Window:
>     
>     view layout [
>     
>         ; Set the layout properties so that widgets are placed immediately
>         ; next to one another, starting at the top left corner of the screen:
>     
>         origin 0  space 0x0  across
>     
>         ; Here's a text field, labeled "f".  It's size is 200 pixels across
>         ; and 40 pixels down.  The font size of text in the field is set to
>         ; 20.  After this field widget, the "return" word is used to jump
>         ; to the beginning of a new line:
>     
>         f: field 200x40 font-size 20  return
>     
>         ; The "style" word below is used to create a new widget called "btn",
>         ; which is a button, sized 50 pixels by 50 pixels.  When clicked, the
>         ; button appends the text on it's face to the text field widget above,
>         ; labeled "f", then the display is updated using the "show" function:
>     
>         style btn btn 50x50 [append f/text face/text  show f]
>     
>         ; Below the field widget are 4 lines of buttons, displaying either
>         ; numbers or operators on their face.  Each of these buttons performs
>         ; the actions defined above in the "style" definition (appends its
>         ; face text to the field widget display):
>     
>         btn "1"  btn "2"  btn "3"  btn " + "  return
>         btn "4"  btn "5"  btn "6"  btn " - "  return
>         btn "7"  btn "8"  btn "9"  btn " * "  return
>         btn "0"  btn "."  btn " / "   btn "=" [
>     
>             ; When the "=" button is pressed, the "f" field text is set to the
>             ; result of the expression displayed in the "f" field text (the 
>             ; evaluation is performed using the "do" function), and the
>             ; display is updated with the "show" function.  Remember, the
>             ; "form" function is used to convert the result to a text string
>             ; value, which is the only type of data that text field widgets
>             ; display.  The "attempt" function is used to keep the program
>             ; from crashing if the user tries to enter an illegal expression,
>             ; such as division by zero or incomplete expressions (i.e., 1 + ):
>     
>             attempt [f/text: form do f/text  show f]
>     
>         ]
>     ]
>     
> 
> Here's the whole program, without comments:
>     
>     
>     REBOL [title: "Calculator"]
>     view layout [
>         origin 0  space 0x0  across
>         f: field 200x40 font-size 20 return
>         style btn btn 50x50 [append f/text face/text  show f]
>         btn "1"  btn "2"  btn "3"  btn " + "  return
>         btn "4"  btn "5"  btn "6"  btn " - "  return
>         btn "7"  btn "8"  btn "9"  btn " * "  return
>         btn "0"  btn "."  btn " / "   btn "=" [
>             attempt [f/text: form do f/text  show f]
>         ]
>     ]
>     
> 
> The following example downloads and parses the current (live) US Dollar exchange rates from http://x-rates.com and allows the user to select from a list of currencies to convert to, then performs and displays the conversion from USD to the selected currency. This example will likely be a bit too advanced to understand completely at this point in the tutorial, but it's good to run it in the REBOL interpreter and browse through the code to recognize functions such as "read", "find", "parse", "attempt", etc., to which you've already been introduced. See if you can get a general concept of what the code is doing:
>     
>     
>     REBOL [title: "Currency Rate Conversion Calculator"]
>     view center-face layout [
>         origin 0  space 0x0  across
>         f: field 200x40 font-size 20
>         return
>         style btn btn 50x50 [append f/text face/text  show f]
>         btn "1"  btn "2"  btn "3"  btn " + "  return
>         btn "4"  btn "5"  btn "6"  btn " - "  return
>         btn "7"  btn "8"  btn "9"  btn " * "  return
>         btn "0"  btn "."  btn " / "   btn "=" [
>             attempt [f/text: form do f/text  show f]
>         ] return
>         btn 200x35 "Convert" [
>             x: copy []
>             html: read http://www.x-rates.com/table/?from=USD&amount=1.00
>             html: find html "src='/themes/bootstrap/images/xrates_sm_tm.png'"
>             parse html [
>                 any [
>                     thru {from=USD} copy link to {</a>} (append x link)
>                 ] to end 
>             ]
>             rates: copy []
>             foreach rate x [
>                 parse rate [thru {to=} copy c to {'>}]
>                 parse rate [thru {'>} copy v to end]
>                 if not error? try [to-integer v] [append rates reduce [c v]]
>             ]  
>             currency: request-list "Select Currency:" extract rates 2
>             rate: to-decimal select rates currency
>             attempt [alert rejoin [currency ": " (rate * to-decimal f/text)]]
>         ]
>     ]
>     

### 5.3 File Editor

> Next is an example of a text editor that allows you to read, edit, and save any text file. Here's the GUI layout code. It consists of a "h1" header text widget displaying the text "Text Editor:", a 600 pixel wide field widget labeled "f" containing the text "filename.txt", a 600x350 pixel area widget labeled "a", and two buttons aligned across the screen (next to each other):
>     
>     
>     REBOL []
>     view layout [
>         h1 "Text Editor:"
>         f: field 600 "filename.txt"
>         a: area 600x350 
>         across 
>         btn "Load" []
>         btn "Save" []
>     ]
>     
> 
> And here's the full code that makes it run:
>     
>     
>     REBOL []
>     view layout [
>         h1 "Text Editor:"
>         f: field 600 "filename.txt"
>         a: area 600x350 
>         across 
>         btn "Load" [
>     
>             ; When the load button is pressed, request a file name from the
>             ; user, and display it in the "f" field.  Be sure to update the
>             ; display using the "show" function:
>     
>             f/text: request-file
>             show f
>     
>             ; In order to load the file, the text version of file name
>             ; displayed in the field must be converted from text to a file
>             ; value:
>     
>             filename: to-file f/text
>     
>             ; Set text in the area widget to the data read from file location,
>             ; and update the display:
>     
>             a/text: read filename 
>             show a
>     
>         ]
>         btn "Save" [
>     
>             ; When the save button is clicked, request a file name from the
>             ; user.  The default file name shown in the requestor is the text
>             ; currently displayed in the "f" field: 
>     
>             filename: to-file request-file/save/file f/text
>     
>             ; Write to the selected file name, the text contained in the "a"
>             ; area widget:
>     
>             write filename a/text
>     
>             ; Alert the user when the file is saved:
>     
>             alert "Saved"
>     
>         ]
>     ]
>     
> 
> Here's the whole program without comments:
>     
>     
>     REBOL [title: "Text Editor"]
>     view layout [
>         h1 "Text Editor:"
>         f: field 600 "filename.txt"
>         a: area 600x350 
>         across 
>         btn "Load" [
>             f/text: request-file
>             show f
>             filename: to-file f/text
>             a/text: read filename 
>             show a
>         ]
>         btn "Save" [
>             filename: to-file request-file/save/file f/text
>             write filename a/text
>             alert "Saved"
>         ]
>     ]
>     

### 5.4 Web Page Editor

> REBOL can read and write to FTP (web site) servers just as easily as it can to local files. All you need to know is an account username/password, folder location on the server (often "public_html"), and a file name to edit. Here's a variation of the program above repurposed as a web page editor:
>     
>     
>     REBOL [title: "Web Page Editor"]
>     view layout [
>         h1 "Web Page Editor:"
>         f: field 600 "ftp://user:pass@site.com/public_html/file.txt"
>         a: area 600x350 
>         across 
>         btn "Load" [
>     
>             ; Be sure to convert the file name text in "a" area widget to a
>             ; URL data value.  Set text in the area widget to the data read
>             ; from the URL location:
>     
>             a/text: read to-url f/text 
>             show a
>     
>         ]
>         btn "Save" [
>     
>             ; Covert the text in "a" area widget to a URL value and write the
>             ; data in the "a" area widget to the URL:
>     
>             write (to-url f/text) a/text
>             alert "Saved"
>     
>         ]
>     ]
>     
> 
> Here's the whole program without comments:
>     
>     
>     REBOL [title: "Web Page Editor"]
>     view layout [
>         h1 "Web Page Editor:"
>         f: field 600 "ftp://user:pass@site.com/public_html/page.html"
>         a: area 600x350 
>         across 
>         btn "Load" [
>             a/text: read to-url f/text 
>             show a
>         ]
>         btn "Save" [
>             write (to-url f/text) a/text
>             alert "Saved"
>         ]
>     ]
>     

### 5.5 Inventory List Creator

> This is another simple GUI field example. It's very similar to the first example, but improved a bit with text labels for each field and repurposed to satisfy a very concise specialized task. It creates an inventory list using a simple GUI form. The file created is a list that can be used as needed to re-order required items, to calculate inventory and sales tax due, etc. Here's the GUI layout code:
>     
>     
>     REBOL [title: "Inventory"]
>     view layout [
>         text "SKU:"
>         f1: field
>         text "Cost:"
>         f2: field "1.00"
>         text "Quantity:"
>         f3: field
>         across
>         btn "Save" []
>         btn "View Data" []
>     ]
>     
> 
> And here's the code that makes the entire inventory program run:
>     
>     
>     REBOL [title: "Inventory"]
>     view layout [
>         text "SKU:"
>         f1: field
>         text "Cost:"
>         f2: field "1.00"
>         text "Quantity:"
>         f3: field
>         across
>         btn "Save" [
>             write/append %inventory.txt rejoin [
>                 mold f1/text " " mold f2/text " " mold f3/text newline
>             ]
>             alert "Saved"
>         ]
>     
>         ; A button is added to allow viewing/editing of the saved data, using
>         ; REBOL text editor function:
>     
>         btn "View Data" [editor %inventory.txt]
>     ]
>     
> 
> Here's whole program without comments:
>     
>     
>     REBOL [title: "Inventory"]
>     view layout [
>         text "SKU:"
>         f1: field
>         text "Cost:"
>         f2: field "1.00"
>         text "Quantity:"
>         f3: field
>         across
>         btn "Save" [
>             write/append %inventory.txt rejoin [
>                 mold f1/text " " mold f2/text " " mold f3/text newline
>             ]
>             alert "Saved"
>         ]
>         btn "View Data" [editor %inventory.txt]
>     ]
>     

### 5.6 Inventory Sorter and Viewer

> The inventory program creates lists of data that look like this (saved in the file "inventory.txt"):
>     
>     
>     "932984729812" "1.00" "14"
>     "392328389483" "2.59" "93"
>     "602374822852" "4.92" "3"
>     
> 
> This little program allows users to view the inventory data, sorted by a chosen column. You've already seen most of the important code patterns in this example, during the discussion about sorting columns of values in a table:
>     
>     
>     REBOL [title: "Sort Inventory"]
>     
>     ; Load the data block from the inventory.txt file and label it
>     : "inventory":
>     
>     inventory: load %inventory.txt
>     
>     ; Create a new empty block named "blocked":
>     
>     blocked: copy []
>     
>     ; Convert the "flat" data in the "inventory" block to "blocked" format
>     ; (with rows delineated as separate blocks).  Remember, as shown earlier,
>     ; the "append/only" function refinement makes this easy to do.  Just run
>     ; a "foreach" function on every 3 items in the "inventory" block, and
>     ; add each group of three items as a new block within the "blocked" block.
>     ; Notice that during the process, the "cost" and "qty" are converted from
>     ; strings to money and number values:
>     
>     foreach [sku cost qty] inventory [
>         append/only blocked reduce [
>             sku 
>             to-money cost
>             to-integer qty
>         ]
>     ]
>     
>     ; Use the "request-list" function to allow the user to select a column to
>     ; sort by.  Assign the response to the variable "field-name":
>     
>     field-name: request-list "Choose Field To Sort By:" [
>         "sku" "cost" "qty"
>     ]
>     
>     ; The "select" function chooses the next value in a list, selected by the
>     ; user.  In this case if the field-name variable equals "sku", the "field"
>     ; variable is set to 1.  If field-name="cost", the "field" variable is set
>     ; to 2.  If field-name="qty", then "field" is set to 3: 
>     
>     field: select ["sku" 1 "cost" 2 "qty" 3] field-name
>     
>     ; Use the "request-list" function to allow the user to select an order to
>     ; sort by.  Assign the response to the label "order":
>     
>     order: request-list "Ascending or Descending:" ["ascending" "descending"]
>     
>     ; Sort by the appropriate "field" column, ascending or descending, 
>     ; depending on the value of the "order" variable:
>     
>     either order = "ascending" [
>         sort/compare blocked func [a b] [(at a field) < (at b field)]
>     ][
>         sort/compare blocked func [a b] [(at a field) > (at b field)]
>     ]
>     
>     ; Use the foreach function to loop through the sorted "blocked" block of
>     ; data.  Print the 3 items in each block within the "blocked" block:
>     
>     foreach item blocked [
>         print rejoin [
>             "SKU:  " item/1           ; The 1st item in each block is the SKU.
>             "  COST: " item/2         ; 2nd item is the cost.
>             "  QTY: " item/3          ; 3rd item is the quantity.
>             newline                   ; print a carriage return at the end
>         ]
>     ]
>     halt
>     
> 
> Here's the whole program without comments:
>     
>     
>     REBOL [title: "Sort Inventory"]
>     inventory: load %inventory.txt
>     blocked: copy []
>     foreach [sku cost qty] inventory [
>         append/only blocked reduce [
>             sku 
>             to-money cost
>             to-integer qty
>         ]
>     ]
>     field-name: request-list "Choose Field To Sort By:" [
>         "sku" "cost" "qty"
>     ]
>     field: select ["sku" 1 "cost" 2 "qty" 3] field-name
>     order: request-list "Ascending or Descending:" ["ascending" "descending"]
>     either order = "ascending" [
>         sort/compare blocked func [a b] [(at a field) < (at b field)]
>     ][
>         sort/compare blocked func [a b] [(at a field) > (at b field)]
>     ]
>     foreach item blocked [
>         print rejoin [
>             "SKU:  " item/1 
>             "  COST: " item/2 
>             "  QTY: " item/3 
>             newline
>         ]
>     ]
>     halt
>     

### 5.7 Contacts Viewer

> Here's a contact database app that displays user information in a tabular display:
>     
>     
>     REBOL [title: "Contacts"]
>     
>     ; First create a block of user data.  15 values - 5 rows, 3 columns:
>     
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     
>     ; Next, define a GUI layout block.  White background, widgets positioned
>     ; next to each other horizontally, a new "header" text widget style which
>     ; is 200 pixels wide, and 3 of those widgets containing appropriate header
>     ; labels for each column of data, followed by a new GUI line:
>     
>     gui: [
>         backdrop white
>         across
>         style header text 200
>         header "Name:" header "Address:" header "Phone:" return
>     ]
>     
>     ; Use the foreach function to loop through each row in the user block:
>     
>     foreach [name address phone] users [
>     
>         ; For each row in the user block, add the following code to the GUI
>         ; layout block:
>     
>         append gui compose [
>     
>             ; Add a new field widget containing each row's name, address, and
>             ; phone values.  The "compose" function above converts the
>             ; parenthesized words below to evaluated values (the text data
>             ; in each row, instead of the text "name", "address", "phone"):
>     
>             field (name) field (address) field (phone) return
>     
>         ]
>     ]
>     
>     ; Show the constructed GUI block:
>     
>     view layout gui
>     
> 
> Here's the whole program without comments:
>     
>     
>     REBOL [title: "Contacts"]
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     gui: [
>         backdrop white
>         across
>         style header text black 200
>         header "Name:" header "Address:" header "Phone:" return
>     ]
>     foreach [name address phone] users [
>         append gui compose [
>             field (name) field (address) field (phone) return
>         ]
>     ]
>     view layout gui
>     
> 
> This app combines some the techniques used in the previous two examples, to create a prettier sorted inventory display:
>     
>     
>     REBOL [title: "Sort Inventory"]
>     
>     ; First, load some data created by the inventory app.  Assign the loaded
>     ; block to the variable label "inventory":
>     
>     inventory: load %inventory.txt
>     
>     ; Create a new empty block:
>     
>     blocked: copy []
>     
>     ; Create a block of blocks, so that the data can be sorted by columns,
>     ; with column data converted from text to money and integer values.
>     ; The "reduce" function works just like "compose", but does not require
>     ; parentheses:
>     
>     foreach [sku cost qty] inventory [
>         append/only blocked reduce [
>             sku 
>             to-money cost
>             to-integer qty
>         ]
>     ]
>     
>     ; Use the "request-list" requestor to get a sort column from the user.
>     ; Assign the user's response to the variable label "field-name":
>     
>     field-name: request-list "Choose Field To Sort By:" [
>         "sku" "cost" "qty"
>     ]
>     
>     ; Used the "select" function to assign a number value to the column
>     ; chosen above.  Assign that number to variable label "field":
>     
>     field: select ["sku" 1 "cost" 2 "qty" 3] field-name
>     
>     ; Use the "request-list" requestor to get a sort order from the user.
>     ; Assign the user's response to the variable label "order":
>     
>     order: request-list "Ascending or Descending:" ["ascending" "descending"]
>     
>     ; If the chosen sort order is "ascending", sort the block of blocks in
>     ; ascending order, based on the chosen "field" column.  Otherwise, sort
>     ; it in descending order:
>     
>     either order = "ascending" [
>         sort/compare blocked func [a b] [(at a field) < (at b field)]
>     ][
>         sort/compare blocked func [a b] [(at a field) > (at b field)]
>     ]
>     
>     ; Create a GUI block with some 200 pixel wide text headers:
>     
>     gui: [
>         backdrop white
>         across
>         style header text black 200
>         header "SKU:" header "Cost:" header "Qty:" return
>     ]
>     
>     ; For each row in the block of blocks, append 3 fields containing the
>     ; name, address, and phone text, to the GUI layout:
>     
>     foreach row blocked [
>         append gui compose [
>             field (form row/1) field (form row/2) field (form row/3) return
>         ]
>     ]
>     
>     ; View the GUI layout:
>     
>     view center-face layout gui
>     
> 
> Here's the whole program without comments:
>     
>     
>     REBOL [title: "Sort Inventory"]
>     inventory: load %inventory.txt
>     blocked: copy []
>     foreach [sku cost qty] inventory [
>         append/only blocked reduce [
>             sku 
>             to-money cost
>             to-integer qty
>         ]
>     ]
>     field-name: request-list "Choose Field To Sort By:" [
>         "sku" "cost" "qty"
>     ]
>     field: select ["sku" 1 "cost" 2 "qty" 3] field-name
>     order: request-list "Ascending or Descending:" ["ascending" "descending"]
>     either order = "ascending" [
>         sort/compare blocked func [a b] [(at a field) < (at b field)]
>     ][
>         sort/compare blocked func [a b] [(at a field) > (at b field)]
>     ]
>     gui: [
>         backdrop white
>         across
>         style header text black 200
>         header "SKU:" header "Cost:" header "Qty:" return
>     ]
>     foreach row blocked [
>         append gui compose [
>             field (form row/1) field (form row/2) field (form row/3) return
>         ]
>     ]
>     view center-face layout gui
>     

### 5.8 Minimal Retail Cash Register and Sales Report System

> The example below is a trivial POS ("Point of Sale", or retail cash register) program:
>     
>     
>     REBOL [title: "Minimal Cash Register"]
>     view gui: layout [
>     
>         ; Create a new widget style named "fld".  It's just a text field, 
>         ; 80 pixels wide:
>     
>         style fld field 80
>     
>         ; Place consecutive widgets next to each other:
>     
>         across
>     
>         ; Here are 3 text labels and 3 text entry fields to allow users to
>         ; enter a cashier name, item name, and price.  The text entry fields
>         ; are labeled appropriately:
>     
>         text "Cashier:"   cashier: fld 
>         text "Item:"      item: fld 
>         text "Price:"     price: fld [
>     
>             ; When the user enters a price, perform the following operations:
>             ; First, check to make sure the price entered can be converted to
>             ; a money value.  If not, alert the user with an error message and
>             ; exit the action block:
>     
>             if error? try [to-money price/text] [alert "Price error" return]
>     
>             ; Otherwise, add the quoted item text, and the price to the area
>             ; widget (separated by a few spaces):
>     
>             append a/text reduce [mold item/text "    " price/text newline]
>     
>             ; Then erase the text in the item and price entry fields:
>     
>             item/text: copy "" price/text: copy ""
>     
>             ; Now, compute a subtoal of all the entered items.  Update the
>             ; subtotal, tax, and total amount fields with the appropriate
>             ; computed values:
>     
>             sum: 0
>             foreach [item price] load a/text [sum: sum + to-money price]
>             subtotal/text: form sum
>             tax/text: form sum * .06
>             total/text: form sum * 1.06 
>     
>             ; Put the cursor back in the "item" field, and update the display:
>     
>             focus item
>             show gui
>     
>         ]
>     
>         ; On a new row, put an area widget, 600 pixels across and 300 tall,
>         ; labeled "a":
>     
>         return
>         a: area 600x300
>     
>         ; On a new line, 3 more text and field widgets, labeled appropriately,
>         : and a button with the text "Save":
>     
>         return
>         text "Subtotal:"   subtotal: fld 
>         text "Tax:"        tax: fld 
>         text "Total:"      total: fld
>         btn "Save" [
>     
>             ; When the button is pressed, do the following:
>             ; first create a quoted block of items in the area widget.
>             ; Replace all the newline characters with a space, so that all
>             ; the data is on one line.  Label the whole chunk of data "items":
>     
>             items: replace/all (mold load a/text) newline " "
>     
>             ; Append the "items" data, the cashier name, and the date to the
>             ; file "sales.txt" (all separated by carriage returns):
>     
>             write/append %sales.txt rejoin [
>                 items newline cashier/text newline now/date newline
>             ]
>     
>             ; Erase all the text in every field widget, erase the text in the
>             ; the area widget, and update the display:
>     
>             clear-fields gui
>             a/text: copy ""             
>             show gui             
>     
>         ]
>     ]
>     
> 
> The code below reports the total sum of cash register sales for the current day:
>     
>     
>     REBOL [title: "Daily Total"]
>     
>     ; Read in each line of the "sales.txt" block, and label it "sales":
>     
>     sales: read/lines %sales.txt
>     
>     ; Label a variable to hold a computed sum, and set it initially to $0:
>     
>     sum: $0
>     
>     ; Use a foreach loop to go through every 3 items in the sales data
>     ; (remember each group of items, cashier, and date were separated by a 
>     ; newline in the code above):
>     
>     foreach [items cashier date] sales [
>     
>         ; If the today's date is foun in any saved date entry:
>     
>         if now/date = to-date date [
>     
>            ; Use a foreach loop to go through the values in the "items" data:
>     
>             foreach [item price] load items [
>     
>                 ; Add the price value to the computed sum:
>     
>                 sum: sum + to-money price
>     
>             ]
>         ]
>     ]
>     
>     ; Alert the user with the computed sum:
>     
>     alert rejoin ["Total sales today: " sum]
>     
> 
> The report below shows the total of all items sold on any chosen day, by any chosen cashier:
>     
>     
>     REBOL [title: "Cashier Report"]
>     
>     ; Start by requesting a selected date and the name of a cashier:
>     
>     report-date: request-date
>     report-cashier: request-text/title "Cashier:" 
>     
>     ; Read in the lines of the "sales.txt" file:
>     
>     sales: read/lines %sales.txt
>     
>     ; Prepare to compute a sum value:
>     
>     sum: $0
>     
>     ; Use a foreach loop to go through each entry in the sales data:
>     
>     foreach [items cashier date] sales [
>     
>         ; Perform 2 conditional evaluations to check for any entries in which
>         ; the selected cashier name and date match:
>     
>         if ((report-cashier = cashier) and (report-date = to-date date)) [
>     
>             ; For any entry that matches, add to the sum:
>     
>             foreach [item price] load items [
>                 sum: sum + to-money price
>             ]
>     
>         ]
>     ]
>     
>     ; Alert the user with a concatenated message:
>     
>     alert rejoin ["Total for " report-cashier " on " report-date ": " sum]
>     
> 
> Here are all 3 programs, without comments:
>     
>     
>     REBOL [title: "Minimal Cash Register"]
>     view gui: layout [
>         style fld field 80
>         across
>         text "Cashier:"   cashier: fld 
>         text "Item:"      item: fld 
>         text "Price:"     price: fld [
>             if error? try [to-money price/text] [alert "Price error" return]
>             append a/text reduce [mold item/text "    " price/text newline]
>             item/text: copy "" price/text: copy ""
>             sum: 0
>             foreach [item price] load a/text [sum: sum + to-money price]
>             subtotal/text: form sum
>             tax/text: form sum * .06
>             total/text: form sum * 1.06 
>             focus item
>             show gui
>         ]
>         return
>         a: area 600x300
>         return
>         text "Subtotal:"   subtotal: fld 
>         text "Tax:"        tax: fld 
>         text "Total:"      total: fld
>         btn "Save" [
>             items: replace/all (mold load a/text) newline " "
>             write/append %sales.txt rejoin [
>                 items newline cashier/text newline now/date newline
>             ]
>             clear-fields gui
>             a/text: copy ""             
>             show gui             
>         ]
>     ]
>     
>     REBOL [title: "Daily Total"]
>     sales: read/lines %sales.txt
>     sum: $0
>     foreach [items cashier date] sales [
>         if now/date = to-date date [
>             foreach [item price] load items [
>                 sum: sum + to-money price
>             ]
>         ]
>     ]
>     alert rejoin ["Total sales today: " sum]
>     
>     REBOL [title: "Cashier Report"]
>     report-date: request-date
>     report-cashier: request-text/title "Cashier:" 
>     sales: read/lines %sales.txt
>     sum: $0
>     foreach [items cashier date] sales [
>         if ((report-cashier = cashier) and (report-date = to-date date)) [
>             foreach [item price] load items [
>                 sum: sum + to-money price
>             ]
>         ]
>     ]
>     alert rejoin ["Total for " report-cashier " on " report-date ": " sum]
>     

### 5.9 Email

> This example is a complete graphical email client that can be used to read and send messages. It has a button feature which allows the user to enter all necessary email account settings:
>     
>     
>     REBOL [Title: "Little Email Client"] 
>     
>     ; The line below creates the program's GUI window:
>     
>     view layout [
>     
>         ; This line adds a text label to the GUI:
>     
>         h1 "Send Email:"
>     
>         ; This line adds a button to the GUI:
>     
>         btn "Server settings" [
>     
>             ; When the button is clicked, the following lines are run.
>             ; These lines set all the email user account information
>             ; required to send and receive email.  The settings are gotten
>             ; from the user with the "request-text" function, and assigned
>             ; to their appropriate locations in the REBOL system:
>     
>             system/schemes/default/host: request-text/title "SMTP Server:"
>             system/schemes/pop/host:     request-text/title "POP Server:"
>             system/schemes/default/user: request-text/title "SMTP User Name:"
>             system/schemes/default/pass: request-text/title "SMTP Password:"
>             system/user/email: to-email request-text/title "Your Email Addr:"
>     
>         ]
>     
>         ; This line creates a text entry field, containing the default text
>         ; "recipient@website.com".  The variable word "address" is assigned to
>         ; this widget:
>     
>         address: field "recipient@website.com"
>     
>         ; Heres another text entry field, for the email subject line:
>     
>         subject: field "Subject" 
>     
>         ; This line creates a larger, multi-line text entry area for the body
>         ; text of the email:
>     
>         body: area "Body"
>     
>         ; Here's a button displaying the word "send".  The functions inside
>         ; its action block are executed whenever the button is clicked:
>     
>         btn "Send" [
>     
>             ; This line does most of the work.  It uses the REBOL "send" 
>             ; function to send the email.  The send function, with its
>             ; "/subject" refinement accepts three parameters.  It's passed the
>             ; current text contained in each field labeled above (referred to
>             ; as "address/text" "body/text" and "subject/text").  The
>             ; "to-email" function ensures that the address text is treated as
>             ; an email data value:
>     
>             send/subject (to-email address/text) body/text subject/text
>     
>             ; This line alerts the user when the previous line is complete:
>     
>             alert "Message Sent."
>     
>         ]
>     
>         ; Here's another text label:
>     
>         h1 "Read Email:"
>     
>         ; Here's another text entry field.  The user's email account info is
>         ; entered here.
>     
>         mailbox: field "pop://user:pass@site.com"
>     
>         ; This last button has an action block that reads messages from a
>         ; specified mailbox.  It only takes one line of code:
>     
>         btn "Read" [
>     
>             ; The "to-url" function ensures that the text in the mailbox field
>             ; is treated as a URL.  The contents of the mailbox are read and
>             ; displayed using REBOL's built-in text editor:
>     
>             editor read to-url mailbox/text
>     
>         ]
>     ]
>     
> 
> Here's the whole program without comments:
>     
>     
>     view layout[
>         h1 "Send:"
>         btn "Server settings" [
>             system/schemes/default/host: request-text/title "SMTP Server:"
>             system/schemes/pop/host:     request-text/title "POP Server:"
>             system/schemes/default/user: request-text/title "SMTP User Name:"
>             system/schemes/default/pass: request-text/title "SMTP Password:"
>             system/user/email: to-email request-text/title "Your Email Addr:"
>         ]
>         a: field "user@website.com"
>         s: field "Subject" 
>         b: area
>         btn "Send"[
>             send/subject to-email a/text b/text s/text
>             alert "Sent"
>         ]
>         h1 "Read:" 
>         f: field "pop://user:pass@site.com"
>         btn "Read" [editor read to-url f/text]
>     ]
>     

### 5.10 Scheduler

> Here's the GUI code for a scheduling app that allows users to create events on any day. Later, the user can click any day on the calendar to see the scheduled events:
>     
>     
>     view center-face gui: layout [
>         btn "Date" []
>         date: field
>         text "Event Title:"
>         event: field
>         text "Time:"
>         time: field
>         text "Notes:"
>         notes: field
>         btn "Add Appoinment" []
>         a: area
>         btn "View Schedule" []
>     ]
>     
> 
> Here's the final code that makes the whole scheduling app run. This entire program is really nothing more complex than the field saver, inventory, cash register, and other GUI examples you've seen so far. There are just a few more widgets, and of course a date requester to allow the user to select dates, but the same GUI, file reading/writing, and foreach block management are repurposed to enter, save, load, and display calendar data:
>     
>     
>     view center-face gui: layout [
>         btn "Date" [date/text: form request-date  show date]
>         date: field
>         text "Event Title:"
>         event: field
>         text "Time:"
>         time: field
>         text "Notes:"
>         notes: field
>         btn "Add Appoinment" [
>             write/append %appts.txt rejoin [
>                 mold date/text newline
>                 mold event/text newline
>                 mold time/text newline
>                 mold notes/text newline 
>             ]
>             date/text: "" event/text: "" time/text: "" notes/text: ""
>             show gui
>             alert "Added"
>         ]
>         a: area
>         btn "View Schedule" [
>             today: form request-date
>             foreach [date event time notes] load %appts.txt [
>                 if date = today [
>                     a/text: copy ""
>                     append a/text form rejoin [
>                         date newline
>                         event newline
>                         time newline
>                         notes newline newline
>                     ]
>                     show a
>                 ]
>             ]
>         ]
>     ]
>     

### 5.11 Parts Database

> Here's an application that allows workers to add, delete, edit, and view manufactured parts. This is another quintessential simple text field storage application. It can be used as shown here, to save parts information, but by adjusting just a few lines of code and text labels, it could be easily adapted to store contacts information, or any other type of related fields of blocked text data. Be sure to pay special attention to how the text-list widget is used, and be particularly aware of how the "pick" function is used to select consecutive values after a found index:
>     
>     
>     REBOL [title: "Parts]
>     
>     ; The line below writes a new empty data file to the hard drive, if it
>     ; doesn't already exist.  If the file DOES already exist, then this
>     ; function simply writes an empty string to it (i.e., leaves the file
>     ; alone):
>     
>     write/append %data.txt ""
>     
>     ; This line loads all saved records from the database file:
>     
>     database: load %data.txt
>     
>     
>     ; Here's the GUI window:
>     
>     view center-face gui: layout [
>     
>         ; Here's a text label to instruct the user:
>     
>         text "Load an existing record:"
>     
>         ; This text list displays an alphabetically sorted list of the
>         ; names found in the database (every forth item).  The number
>         ; pair indicates the widget's pixel size:
>     
>         name-list: text-list blue 400x100 data (sort extract database 4) [
>     
>             ; The following line is included to avoid potential errors.
>             ; When an item in the text list is clicked, we first check that
>             ; the selected data (represented by the word "value") is NOT
>             ; equal to nothing.  If so, exit the widget's action block 
>             ; (the "return" word quits the text-list's action routine):
>     
>             if value = none [return]
>     
>             ; The following code finds the selected part in the loaded
>             ; database.  The display fields in the GUI are then set
>             ; to show the found part, and each of the 3 items after
>             ; it in the database (part name = field 1, manufacturer = 
>             ; field 2, SKU = field 3, notes = field 4):
>     
>             marker: index? find database value
>             n/text: pick database marker
>             a/text: pick database (marker + 1)
>             p/text: pick database (marker + 2)
>             o/text: pick database (marker + 3)
>     
>             ; Update the display to show the changed text fields (notice
>             ; the "gui" label defined above - it refers to the entire GUI
>             ; layout):
>     
>             show gui
>         ]
>     
>         ; Here are the text display fields, and some text labels to show
>         ; what should be typed into each field:
>     
>         text "Part Name:"       n: field 400
>         text "Manufacturer:"    a: field 400
>         text "SKU:"             p: field 400
>         text "Notes:"           o: area  400x100
>     
>         ; The "across" word adds widgets to the GUI next to one another,
>         ; instead of beneath one another, which is the default behavior
>         ; (the following 3 buttons will appear next to each other):
>     
>         across
>     
>         ; Here's a GUI button to let the user save the contents of the
>         ; text fields to the database:
>     
>         btn "Save" [
>     
>             ; When this button is clicked, make sure the required field
>             ; contains some text.  If not, notify the user, and then exit
>             ; this button's routine (the "return" word quits the save 
>             ; button's action block):
>     
>             if n/text = "" [alert "You must enter a part name." return]
>     
>             ; Now run through every forth item in the database to check if
>             ; the part already exists.  If so, give the user the option to
>             ; overwrite that record.  If they respond yes, delete the old
>             ; record from the database ("remove/part" deletes 4 items at
>             ; the location where the selected part is found).  If the user
>             ; responds no, escape out of the save button's routine:
>     
>             if find (extract database 4) n/text [
>                 either true = request "Overwrite existing record?" [
>                    remove/part (find database n/text) 4
>                 ] [
>                    return
>                 ]
>             ]
>     
>             ; Now update the database with the new data, and write it to
>             ; the hard drive.  The "repend" function appends the evaluated
>             ; variables inside the brackets (in this case a block of 4
>             ; separate text strings contained in the GUI fields) to the
>             ; database:
>     
>             save %data.txt repend database [n/text a/text p/text o/text]
>     
>             ; Update the text-list to show the added record:
>     
>             name-list/data: sort (extract copy database 4)
>             show name-list
>         ]
>     
>         ; This button allows the user to clear the screen and enter a
>         ; new record:
>     
>         btn "Delete" [
>     
>             ; When this button is clicked, the code below gives the user
>             ; the option to delete the selected record.  If the user
>             ; selects "yes", the "remove/part" function deletes 4 items
>             ; from the database, at the location where the selected part
>             ; is found.  The database is saved, and the text fields are
>             ; cleared ("do-face" runs the action block of the 
>             ; "clear-button" widget above, to clear the GUI fields), then
>             ; the part name list is updated:
>     
>             if true = request rejoin ["Delete " n/text "?"] [
>                 remove/part (find database n/text) 4
>                 save %data.txt database
>                 do-face clear-button 1
>                 name-list/data: sort (extract copy database 4)
>                 show name-list
>             ]
>         ]
>     
>         clear-button: btn "New" [
>     
>             ; When this button is clicked, set the text of each field to an
>             ; empty string:
>     
>             n/text: copy  ""
>             a/text: copy  ""
>             p/text: copy  ""
>             o/text: copy  "" 
>     
>             ; As always, when any on data in the GUI is changed, the
>             ; screen must be updated: 
>     
>             show gui
>         ]
>     ]
>     
> 
> Here's the whole program without comments:
>     
>     
>     REBOL [title: "Parts"]
>     write/append %data.txt ""
>     database: load %data.txt
>     view center-face gui: layout [
>         text "Parts in Stock:"
>         name-list: text-list blue 400x100 data sort (extract database 4) [
>             if value = none [return]
>             marker: index? find database value
>             n/text: pick database marker
>             a/text: pick database (marker + 1)
>             p/text: pick database (marker + 2)
>             o/text: pick database (marker + 3)
>             show gui
>         ]
>         text "Part Name:"       n: field 400
>         text "Manufacturer:"    a: field 400
>         text "SKU:"             p: field 400
>         text "Notes:"           o: area  400x100
>         across
>         btn "Save" [
>             if n/text = "" [alert "You must enter a part name." return]
>             if find (extract database 4) n/text [
>                 either true = request "Overwrite existing record?" [
>                    remove/part (find database n/text) 4
>                 ] [
>                    return
>                 ]
>             ]
>             save %data.txt repend database [n/text a/text p/text o/text]
>             name-list/data: sort (extract copy database 4)
>             show name-list
>         ]
>         btn "Delete" [
>             if true = request rejoin ["Delete " n/text "?"] [
>                 remove/part (find database n/text) 4
>                 save %data.txt database
>                 do-face clear-button 1
>                 name-list/data: sort (extract copy database 4)
>                 show name-list
>             ]
>         ]
>         clear-button: btn "New" [
>             n/text: copy  ""
>             a/text: copy  ""
>             p/text: copy  ""
>             o/text: copy  ""
>             show gui
>         ]
>     ]
>     
> 
> Here's the same program as above, repurposed as a contacts database app (quite a bit more versatile than the earlier example). _The field labels have simply been changed_:
>     
>     
>     REBOL [title: "Contacts"]
>     write/append %data.txt ""
>     database: load %data.txt
>     view center-face gui: layout [
>         text "Existing Contacts:"
>         name-list: text-list blue 400x100 data sort (extract database 4) [
>             if value = none [return]
>             marker: index? find database value
>             n/text: pick database marker
>             a/text: pick database (marker + 1)
>             p/text: pick database (marker + 2)
>             o/text: pick database (marker + 3)
>             show gui
>         ]
>         text "Name:"       n: field 400
>         text "Address:"    a: field 400
>         text "Phone:"      p: field 400
>         text "Notes:"      o: area  400x100
>         across
>         btn "Save" [
>             if n/text = "" [alert "You must enter a name." return]
>             if find (extract database 4) n/text [
>                 either true = request "Overwrite existing record?" [
>                    remove/part (find database n/text) 4
>                 ] [
>                    return
>                 ]
>             ]
>             save %data.txt repend database [n/text a/text p/text o/text]
>             name-list/data: sort (extract copy database 4)
>             show name-list
>         ]
>         btn "Delete" [
>             if true = request rejoin ["Delete " n/text "?"] [
>                 remove/part (find database n/text) 4
>                 save %data.txt database
>                 do-face clear-button 1
>                 name-list/data: sort (extract copy database 4)
>                 show name-list
>             ]
>         ]
>         clear-button: btn "New" [
>             n/text: copy  ""
>             a/text: copy  ""
>             p/text: copy  ""
>             o/text: copy  ""
>             show gui
>         ]
>     ]
>     

### 5.12 Time Clock and Payroll Report

> Here's a time clock program that can be used to log employee punch-in and punch-out times for shift work. The GUI allows for easy addition and deletion of employee names, and a full audit history backup of every entry made to the sign ins, is saved to the hard drive each time any employee signs in or out.
>     
>     
>     REBOL [title: "Time Clock"]
>     
>     ; First, check to see if an employee file has been created.  If not,
>     ; create it.  This list will be displayed in a text-list widget.  It
>     ; contains the item "(Add New...)", which will be used to allow users to
>     ; add new names to the list:
>     
>     unless exists? %employees [write %employees {"John Smith" "(Add New...)"}]
>     
>     ; Initialize a current-employee value to an empty string:
>     
>     cur-employee: copy ""
>     
>     view center-face layout [
>     
>         ; Here's the text list widget that displays the employee names, sorted
>         ; alphabetically.  It's labeled "tl1":
>     
>         tl1: text-list 400x400 data sort load %employees [
>     
>             ; When the user selects a name from the list, set the
>             ; "cur-employee" variable to hold the selected name:
>     
>             cur-employee: value
>     
>             ; If the user selected "(Add New...)", run the code required to
>             ; add a name to employee list:
>     
>             if cur-employee = "(Add New...)" [
>     
>                 ; First, request the name from the user, and save the quoted
>                 ; value to the %employees file:
>     
>                 write/append %employees mold trim request-text/title "Name:"
>     
>                 ; Reload the new employee list into the text-list widget, and
>                 ; update the display:
>     
>                 tl1/data: sort load %employees  show tl1
>             ]
>         ]
>     
>         ; The "key" widget does not display any face in the GUI.  It just
>         ; waits for a key to be pressed, and performs the desired actions:
>     
>         key #"^~" [
>     
>             ; First, get the name of the employee to be deleted, and assign
>             ; it the variable label "del-emp":
>     
>             del-emp: copy to-string tl1/picked
>     
>             ; Next, load the employee list and assign it the label "temp-emp":
>     
>             temp-emp: sort load %employees
>     
>             ; Confirm that the user actually wants to delete the employee:
>     
>             if true = request/confirm rejoin ["REMOVE " del-emp "?"] [
>     
>                 ; Find the employee name in the employee list, remove the
>                 ; name, and assign the variable label "new-list" to the
>                 ; pruned employee list:
>     
>                 new-list: head remove/part find temp-emp del-emp 1
>     
>                 ; Save the pruned employee list to the %employees file:
>     
>                 save %employees new-list
>     
>                 ; Update the text-list widget and alert the user that the
>                 ; action has been completed:
>     
>                 tl1/data: sort load %employees show tl1
>                 alert rejoin [del-emp " removed."]
>             ]
>         ]
>     
>         ; Here's a button to allow employees to clock in and out of shifts:
>     
>         btn "Clock IN/OUT" [
>     
>             ; First make sure that a name is selected.  If not, alert the user
>             ; and exit the button's action routine:
>     
>             if ((cur-employee = "") or (cur-employee = "(Add New...)")) [
>                 alert "You must select your name." return
>             ]
>     
>             ; Concatenate the quoted name and time values inside square
>             ; brackets, and beginning with a carriage return.  Assign that
>             ; text the variable label "record":
>     
>             record: rejoin [
>                 newline {[} mold cur-employee { "} mold now {"]}
>             ]
>     
>             ; Confirm with the employee that the selected name and clock time
>             ; are correct:
>     
>             either true = request/confirm rejoin [
>                 record " -- IS YOUR NAME AND THE TIME CORRECT?"
>             ] [
>     
>                 ; This routine saves a backup of the current time sheet in
>                 ; a folder named "clock_history".  First, the folder is
>                 ; created if it doesn't exist:
>     
>                 make-dir %./clock_history/
>     
>                 ; Next, a file name is created by rejoining the folder name
>                 ; and the current day and time.  Illegal file name characters
>                 ; are replaced (i.e., "/" and ":" can't be used in file names
>                 ; on most operating systems).  The text of the existing
>                 ; %time_sheet.txt file is written to the date stamped backup
>                 ; file name:
>     
>                 write rejoin [
>                     %./clock_history/ 
>                     replace/all replace form now "/" "--" ":" "_"
>                 ] read %time_sheet.txt
>     
>                 ; Write the new record to the %time_sheet.txt file:
>     
>                 write/append %time_sheet.txt record
>     
>                 ; Alert the user that the operation is complete:
>     
>                 alert rejoin [
>                     uppercase copy cur-employee ", YOUR TIME IS LOGGED."
>                 ]
>             ] [
>     
>                 ; If the user replied negatively to the confirmation above,
>                 ; alert the user that the action is cancelled, and exit the
>                 ; routine:
>     
>                 alert "CANCELED"
>                 return
>     
>             ]
>         ]
>     ]
>     
> 
> Here's the whole program without comments:
>     
>     
>     REBOL [title: "Time Clock"]
>     unless exists? %employees [write %employees {"John Smith" "(Add New...)"}]
>     cur-employee: copy ""
>     view center-face layout [
>         tl1: text-list 400x400 data sort load %employees [
>             cur-employee: value
>             if cur-employee = "(Add New...)" [
>                 write/append %employees mold trim request-text/title "Name:"
>                 tl1/data: sort load %employees show tl1
>             ]
>         ]
>         key #"^~" [
>             del-emp: copy to-string tl1/picked
>             temp-emp: sort load %employees
>             if true = request/confirm rejoin ["REMOVE " del-emp "?"] [
>                 new-list: head remove/part find temp-emp del-emp 1
>                 save %employees new-list
>                 tl1/data: sort load %employees show tl1
>                 alert rejoin [del-emp " removed."]
>             ]
>         ]
>         btn "Clock IN/OUT" [
>             if ((cur-employee = "") or (cur-employee = "(Add New...)")) [
>                 alert "You must select your name." return
>             ]
>             record: rejoin [
>                 newline {[} mold cur-employee { "} mold now {"]}
>             ]
>             either true = request/confirm rejoin [
>                 record " -- IS YOUR NAME AND THE TIME CORRECT?"
>             ] [
>                 make-dir %./clock_history/
>                 write rejoin [
>                     %./clock_history/ 
>                     replace/all replace form now "/" "--" ":" "_"
>                 ] read %time_sheet.txt
>                 write/append %time_sheet.txt record
>                 alert rejoin [
>                     uppercase copy cur-employee ", YOUR TIME IS LOGGED."
>                 ]
>             ] [
>                 alert "CANCELED"
>                 return
>             ]
>         ]
>     ]
>     
> 
> Here's a program that creates payroll reports of hours worked by employees, logged by the program above, between any selected start and end dates:
>     
>     
>     REBOL [title: "Payroll Report"]
>     
>     ; Request start and end dates from a user:
>     
>     timeclock-start-date: request-date
>     timeclock-end-date: request-date
>     
>     ; Initials a "totals" variable to an empty string.  This string will be
>     ; used to collect (aggregate) the entire output report text:
>     
>     totals: copy ""
>     
>     ; Load the employee list, and assign it the variable label "names":
>     
>     names: load %employees
>     
>     ; Load all the saved time sheet information, and assign it the variable
>     ; label "log":
>     
>     log: load %time_sheet.txt
>     
>     ; Use a foreach loop to collect the log information for each employee:
>     
>     foreach name names [
>     
>         ; Don't try to collect info for the "(Add New...)" entry in the list:
>     
>         if name <> "(Add New...)" [
>     
>             ; Create a new block to hold report information for the current
>             ; employee, initially just containing the employee name.  Assign
>             ; the variable label "times" to the block:
>     
>             times: copy reduce [name]
>     
>             ; Use foreach to loop through every entry in the time sheet log:
>     
>             foreach record log [
>     
>                 ; If the current employee name matches the name in the current
>                 ; entry in the log file, add the record to the report:
>     
>                 if name = log-name: record/1 [
>     
>                     ; Split up the date and time in the current date/time
>                     ; entry (data/time is the second item in each log entry).
>                     ; Assign the variable "date-time" to the result:
>     
>                     date-time: parse record/2 "/"
>     
>                     ; Convert the date portion of the result above to a REBOL
>                     ; date value.  Assign the label "log-date" to that value:
>     
>                     log-date: to-date date-time/1
>     
>                     ; Convert the time portion of the result above to a REBOL
>                     ; time value.  Assign the label "log-time" to that value:
>     
>                     log-time: to-time first parse date-time/2 "-"
>     
>                     ; If the date in the current timesheet entry is within the
>                     ; start and end date period selected by the user, add the
>                     ; current entry to the employee's report:
>     
>                     if (
>                         (log-date >= timeclock-start-date) and 
>                         (log-date <= timeclock-end-date)
>                     ) [
>                         append times log-date
>                         append times log-time
>                     ] 
>                 ]
>             ]
>     
>             ; Append the employee name and a carriage return to the final
>             ; report text:
>     
>             append totals rejoin [name ":" newline]
>     
>             ; Initialize a sum variable to 0:
>     
>             total-hours: 0
>     
>             ; Go through the entire collected "times" block created above
>             ; to calculate end-times - start-times.  Remember that the first
>             ; item in the block was the user's name, so start this process at
>             ; the second item:
>     
>             foreach [in-date in-time out-date out-time] (at times 2) [
>     
>                 ; Append some nicely formatted text containing the start and
>                 ; end days and times, to the final report text:
>     
>                 append totals rejoin [
>                     newline 
>                     "    in: " in-date ", " in-time 
>                     "  out: " out-date ", " out-time "    "
>                 ]
>     
>                 ; Add the total hours worked to the "total-hours" sum.  Wrap
>                 ; this routine in an error check, just in case a start or end
>                 ; time is missing:
>     
>                 if error? try [
>                     total-hours: total-hours + (out-time - in-time)
>                 ] [
>                     alert rejoin [
>                         "Missing login or Missing logout: " name
>                     ]
>                 ]
>             ]
>     
>             ; Append the employee's total computed hours to the final report,
>             ; along with some concatenated text and carriage returns, to
>             ; create a nicely formatted printout: 
>     
>             append totals rejoin [
>                 newline newline
>                 "    TOTAL HOURS: " total-hours
>                 newline newline newline
>             ]
>     
>         ]
>     ]
>     
>     ; Write the final report to a file name containing the start and end dates
>     ; chosen for the report, and open it using Window's "notepad" application
>     ; (you could simply use REBOL's "editor" function to do this):
>     
>     write filename: copy rejoin [
>         %timeclock_report-- timeclock-start-date 
>         "_to_" timeclock-end-date ".txt"
>     ] totals
>     call/show rejoin ["notepad " to-local-file filename]
>     
> 
> Here's the whole program without comments:
>     
>     
>     REBOL [title: "Payroll Report"]
>     timeclock-start-date: request-date
>     timeclock-end-date: request-date
>     totals: copy ""
>     names: load %employees
>     log: load %time_sheet.txt
>     foreach name names [
>         if name <> "(Add New...)" [
>             times: copy reduce [name]
>             foreach record log [
>                 if name = log-name: record/1 [
>                     date-time: parse record/2 "/"
>                     log-date: to-date date-time/1
>                     log-time: to-time first parse date-time/2 "-"
>                     if (
>                         (log-date >= timeclock-start-date) and 
>                         (log-date <= timeclock-end-date)
>                     ) [
>                         append times log-date
>                         append times log-time
>                     ] 
>                 ]
>             ]
>             append totals rejoin [name ":" newline]
>             total-hours: 0
>             foreach [in-date in-time out-date out-time] (at times 2) [
>                 append totals rejoin [
>                     newline 
>                     "    in: " in-date ", " in-time 
>                     "  out: " out-date ", " out-time "    "
>                 ]
>                 if error? try [
>                     total-hours: total-hours + (out-time - in-time)
>                 ] [
>                     alert rejoin [
>                         "Missing login or Missing logout: " name
>                     ]
>                 ]
>             ]
>             append totals rejoin [
>                 newline newline
>                 "    TOTAL HOURS: " total-hours
>                 newline newline newline
>             ]
>         ]
>     ]
>     write filename: copy rejoin [
>         %timeclock_report-- timeclock-start-date 
>         "_to_" timeclock-end-date ".txt"
>     ] totals
>     call/show rejoin ["notepad " to-local-file filename]
>     

### 5.13 Blogger

> This program allows users to create and add entries to an online blog page. The GUI has text fields which allow the user to enter a title, link, and blog text, as well as a button to select an image file which will be uploaded and included in the blog entry. When the "Upload" button is clicked, an HTML code file is created and uploaded to the user's web server, along with the image (you'll learn more about HTML later in the tutorial - for now just pay attention to the fact that a bunch of foreign HTML code is concatenated together with values entered by the user). Be sure to edit the ftp-url and html-url variables to represent actual user account information (you'll need a user name, password, and folder on a web server to run this example).
>     
>     
>     REBOL [title: "Blogger"]
>     
>     ; Store the blog file name in a variable:
>     
>     page: "blog.html"
>     
>     ; Store the FTP account address, with username and password:
>     
>     ftp-url: ftp://user:pass@site.com/public_html/folder/
>     
>     ; Store the blog's web page URL in a variable: 
>     
>     html-url: join http://site.com/folder/ page
>     
>     ; Create a 1 pixel blank image to upload, for when the user
>     ; doesn't want to upload any image for a given blog entry:
>     
>     save/png %dot.png to-image layout/tight [box white 1x1]
>     
>     ; Here's the GUI:
>     
>     view center-face gui: layout [
>     
>         ; Display the blog URL in the GUI (the "form" function converts
>         ; the URL data type created above, to a string data type required
>         ; by the h2 widget):
>     
>         h2 (form html-url)
>     
>         ; Here's a descriptive header and a text entry field where the user
>         ; can enter a title for the blog.  The field is labeled by the
>         ; variable word "t":
>     
>         text "Title:"       t: field 400
>     
>         ; Header and entry field for a URL link to be included in the blog:
>     
>         text "Link:"        l: field 400
>     
>         ; Header and selection button for an image to be included in the
>         ; blog.  When the button is clicked, a file requestor pops up.  The
>         ; button's text is set to display the selected file name:
>     
>         text "Image:"       i: btn 400 [i/text: request-file show i]
>     
>         ; Header and text entry field for the blog text:
>     
>         text "Text:"        x: area  400x100
>     
>         ; Layout all the following widgets across the screen:
>     
>         across
>     
>         ; Here's the GUI button which does most of the work:
>     
>         btn "Upload" [
>     
>             ; When the button is clicked, first try to read the existing
>             ; blog text (HTML source).  If it's readable, assign that data
>             ; the variable label "existing-text".  If it's not readable,
>             ; create the folder and an empty blog file on the FTP server,
>             ; then assign the "existing-text" variable an emptry string:
>     
>             if error? try [existing-text: read html-url] [
>                 make-dir ftp-url
>                 write (join ftp-url page) ""
>                 existing-text: copy ""
>             ]
>     
>             ; Assign the variable word "picture" to the image file name
>             ; chosen above ("last split-path" trims off the directory path
>             ; portion of the file name (i.e., %/C/folder/myimage.jpg would
>             ; be trimmed to %myimage.jpg)): 
>     
>             picture: last split-path to-file i/text
>     
>             ; Write the image to the FTP server:
>     
>             write/binary (join ftp-url picture) (read/binary to-file i/text)
>     
>             ; Write the following rejoined HTML to the blog file on the FTP
>             ; server:
>     
>             write (join ftp-url page) rejoin [
>     
>                 ; First add the title, enclosed in "h1" tags:
>     
>                 {<h1>} t/text {</h1>}
>     
>                 ; Now add a link to the uploaded picture, followed by 2
>                 ; HTML line break tags:
>     
>                 {<img src="} picture {"><br><br>}
>     
>                 ; Add the date and time, followed by 5 spaces, no line breaks:
>     
>                 now/date { } now/time { &nbsp; &nbsp; }
>     
>                 ; Add a link tag (because there were no line breaks above,
>                 ; this link appears on the same line as the date and time in
>                 ; the blog), followed by 2 line breaks:
>     
>                 {<a href="} l/text {">} l/text {</a><br><br>}
>     
>                 ; Put the blog text inside a table which takes up 80% of the
>                 ; screen.  Center the table on the screen (so it's indented).
>                 ; Use the "pre" tag to make sure that the text is formatted
>                 ; exactly the way it was typed in by the user (with carriage
>                 ; returns and spaces as entered into the area widget above),
>                 ; and use the "strong" tag to bold the text.  Follow that
>                 ; entire section of HTML with a line break and then a
>                 ; "horizontal rule" tag (a separator line):
>     
>                 {<center><table width=80%><tr><td><pre><strong>}
>                     x/text 
>                 {</strong></pre></td></tr></table></center><br><hr>}
>     
>                 ; Add the previously existing blog HTML below the new entry:
>     
>                 existing-text
>     
>             ]
>     
>             ; After the blog has been updated, open the blog URL in the
>             ; browser:
>     
>             browse html-url
>     
>         ]
>     
>         ; Add a GUI button to open the blog URL in the browser:
>     
>         btn "View" [browse html-url]
>     
>         ; This GUI button allows the user to edit the existing blog file
>         ; (the HTML data created by this program), using REBOL's built in
>         ; text editor.  Remember that REBOL's editor has the ability to
>         ; read and SAVE data directly to/from FTP files, so this editor
>         ; enables the user to actually edit and MAKE CHANGES to the blog
>         ; file on the FTP server:
>     
>         btn "Edit" [editor (join ftp-url page)]
>     
>     ]
>     
> 
> Here's the whole program, without comments:
>     
>     
>     REBOL [title: "Blogger"]
>     page: "blog.html"
>     ftp-url: ftp://user:pass@site.com/public_html/folder/
>     html-url: join http://site.com/folder/ page
>     save/png %dot.png to-image layout/tight [box white 1x1]  ; blank image
>     view center-face gui: layout [
>         h2 (form html-url)
>         text "Title:"       t: field 400
>         text "Link:"        l: field 400
>         text "Image:"       i: btn 400 [i/text: request-file show i]
>         text "Text:"        x: area  400x100
>         across
>         btn "Upload" [
>             if error? try [existing-text: read html-url] [
>                 make-dir ftp-url
>                 write (join ftp-url page) ""
>                 existing-text: copy ""
>             ]
>             picture: last split-path to-file i/text
>             write/binary (join ftp-url picture) (read/binary to-file i/text)
>             write (join ftp-url page) rejoin [
>                 {<h1>} t/text {</h1>}
>                 {<img src="} picture {"><br><br>}
>                 now/date { } now/time { &nbsp; &nbsp; }
>                 {<a href="} l/text {">} l/text {</a><br><br>}
>                 {<center><table width=80%><tr><td><pre><strong>}
>                     x/text 
>                 {</strong></pre></td></tr></table></center><br><hr>}
>                 existing-text
>             ]
>             browse html-url
>         ]
>         btn "View" [browse html-url]
>         btn "Edit" [editor (join ftp-url page)]
>     ]
>     

### 5.14 FTP Group Chat

> This example is a simple chat application that lets users send instant text messages back and forth across the Internet. The chat "rooms" are created by dynamically creating, reading, appending, and saving text files via ftp (to use the program, you'll need access to an available ftp server: ftp address, username, and password. Nothing else needs to be configured on the server). This enables unlimited private conversation spaces that can be used to connect any number of individuals or teams within a group. This program runs entirely in the REBOL console (i.e., there is no graphic user interface - it's all printed text), so it can be used even on simple devices which don't have GUI support. It includes password protected access for administrators to erase chat contents. It also allows users to pause activity momentarily, and requires a username/password to continue (["secret" "password"], in this example case).
>     
>     
>     REBOL [title: "FTP Chat Room"]
>     
>     ; The following line gets the URL of a text file on the user's web server
>     ; to use for the chat.  The ftp username, password, domain, and filename
>     ; must be entered in the format shown:
>     
>     webserver: to-url ask trim/lines {
>         URL of text file on your server (ftp://user:pass@site.com/chat.txt):  
>     }
>     
>     ; The following line gets the user's name:
>     
>     name: ask "Enter your name:  "
>     
>     ; The following line writes some text to the webserver file (obtained 
>     ; above), indicating that the user has entered the chat.  The "/append"
>     ; refinement adds to the existing text in the webserver file (as opposed
>     ; to erasing what's already there).  Using "rejoin", the text written to
>     ; the webserver is the combined value of the user's name, some static
>     ; text, the current date and time, and a carriage return.  If the file
>     ; doesn't exist, it is created.  Any number of "room" files can be
>     ; automatically created on the web server:
>     
>     write/append webserver rejoin [now ": " name " has entered the room.^/"]
>     
>     ; Now the program uses a "forever" loop to continually wait for user
>     ; input, and to do appropriate things with that input:
>     
>     forever [
>     
>         ; First, read the messages that are currently in the "webserver" text
>         ; file, and assign the variable word "current-chat" to that text:
>     
>         current-chat: read webserver 
>     
>         ; Clear the screen:
>     
>         prin "^(1B)[J"
>     
>         ; Display a greeting and some instructions:
>     
>         print rejoin [ 
>             "--------------------------------------------------"
>             newline {You are logged in as: } name newline 
>             {Type "room" to switch chat rooms.} newline
>             {Type "lock" to pause/lock your chat.} newline
>             {Type "quit" to end your chat.} newline 
>             {Type "clear" to erase the current chat.} newline 
>             {Press [ENTER] to periodically update the display.} newline 
>             "--------------------------------------------------" newline
>         ]
>     
>         print rejoin ["Here's the current chat text at: " webserver newline]
>         print current-chat
>     
>         ; In the line below, the "ask" function is used to get some text from
>         ; the user.  The returned text (the text entered by the user) is
>         ; assigned the label "entered-text", and concatenated with the user's
>         ; name and the text " says: ".  This prepares it to be added to the
>         ; webserver file and displayed in the chat.  Notice that the user
>         ; must first respond to the "ask" function, before the rejoin
>         ; evaluation can occur:
>     
>         sent-message: copy rejoin [
>             name " says: "
>             entered-text: ask "You say:  "
>         ]
>     
>         ; The "switch" structure below is used to check for commands in the
>         ; text entered by the user.  If the user enters "quit", "clear", 
>         ; "room", or "lock", appropriate actions occur:
>     
>         switch/default entered-text [   ; "switch" handles multiple "if" cases
>     
>             ; If the user typed "quit", stop the forever loop (exit the
>             ; program):
>     
>             "quit" [break] 
>     
>             ; If the user typed "clear", erase the current text chat.  But
>             ; first, ask user for the administrator username/password:
>     
>             "clear" [
>     
>                 ; "if/else" does the same thing as "either" (deprecated):
>     
>                 adminu: ask "Admin Username:  "
>                 adminp: ask "Admin Password:  "
>                 if/else ((adminu = "secret") and (adminp = "password")) [
>                     write webserver ""
>                 ] [
>                     ask trim/auto {
>                         ^LYou must know the administrator password to clear
>                         the room!
>                     }
>                 ]
>             ]
>     
>             ; If the user typed "room", request a new FTP address, and run
>             ; some code that was presented earlier in the program, using the
>             ; newly entered "webserver" variable, to effectively change chat
>             ; "rooms":
>     
>             "room" [
>     
>                 ; Add a message the chat file, indicating that the user has
>                 ; left the chat:
>     
>                 write/append webserver rejoin [
>                     now ": " name " has left the room." newline
>                 ]
>     
>                 ; Get the URL of a new chat text file (the new room address).
>                 ; Use the old address as the default displayed URL:
>     
>                 webserver: to-url ask rejoin [
>                     {New Web Server Address (} to-string webserver {):  }
>                 ]
>     
>                 ; Display a message in the newly chosen chat text file,
>                 ; showing that the user has entered the chat:
>     
>                 write/append webserver rejoin [
>                     now ": " name " has entered the room." newline
>                 ]
>     
>             ]
>     
>             "lock" [
>     
>                 ; Display a message to the user that the program will be
>                 ; paused:
>     
>                 ask trim/lines {
>                     ^LPress [Enter] to resume.  You'll need the correct
>                     username and password to continue.
>                 }
>     
>                 ; Don't go on until the user gets the password right:
>     
>                 forever [
>     
>                     ; The while loop below continually asks the user for
>                     ; a password, until correct:
>     
>                     while [
>                         adminu: ask "Admin Username:  "
>                         adminp: ask "Admin Password:  "
>                         ((adminu <> "secret") or (adminp <> "password"))
>                     ][
>                         ask "^LIncorrect password - look in the source!"
>                     ]
>     
>                     ; After the user has entered the correct username and
>                     ; password, exit the forever loop and continue with
>                     ; the program:
>     
>                     break
>     
>                 ]
>             ]
>         ][
>     
>             ; The following line is the default case for the switch structure:
>             ; as long as the entered message is not blank ([Enter]), write the
>             ; entered message to the web server (append it to the current chat
>             ; text):
>     
>             if entered-text <> "" [
>                 write/append webserver rejoin [sent-message newline]
>             ]
>         ]
>     ]
>     
>     ; When the "forever" loop is exited, do the following:
>     
>     prin "^(1B)[J"   ; clear screen
>     print "Goodbye!" 
>     write/append webserver rejoin [now ": " name " has closed chat." newline]
>     wait 1
>     
> 
> The bulk of this program runs within the "forever" loop, and uses the conditional "switch" structure to decide how to respond to user input. This is a classic outline that can be adjusted to match a variety of generalized situations in which the computer repeatedly waits for and responds to user interaction at the command prompt.

### 5.15 Group Reminder

> This program operates along the same lines as the FTP Chat app. It stores reminder notes for a group of users in a text file accessible by FTP. Unlike the FTP chat application, this program makes use of GUI features, and focuses on popping up when new messages are sent to the group. Users can run the program at any time to type a new text reminder into a text area widget. The program can also be started and minimized to run in the background and listen for reminders. In listen mode, a GUI window will pop up with a message whenever someone else in the group adds a new reminder. The system can be used to share event reminders, notes, task lists, or any other relevant and time sensitive information. This app only requires that someone in the group has access to an FTP server. Just like the FTP chat program, nothing needs to be configured on the server. All that's required is a username and password, and a connection to the Internet.
>     
>     
>     REBOL [title: "Group Reminder System"]
>     
>     ; This variable is set to store the username, password, folder, file and
>     ; URL of the FTP server at which the reminder texts are stored:
>     
>     group-url: ftp://user:pass@site.com/public_html/reminders.txt
>     
>     ; The request-list function here allows the user to choose between adding
>     ; a new reminder text, or listening in the background.  The user's
>     ; response is stored in the variable "menu":
>     
>     menu: request-list "" ["Create New Reminder" "Listen For Reminders"]
>     
>     ; The code pattern below was demonstrated earlier in the "Parts" program.
>     ; It creates a new file, if the file doesn't exist.  Otherwise, it does
>     ; nothing:
>     
>     write/append %reminders.txt ""
>     
>     ; If the user chose to create a new reminder, do the following code:
>     
>     if menu = "Create New Reminder"  [
>     
>         ; Create a GUI window with some header text, an area widget, and a
>         ; button:
>     
>         view center-face layout [
>     
>             h3 "Add a new reminder for the group:"
>             a: area wrap
>             btn "Submit" [
>     
>                 ; When clicked, run the following code with an error check,
>                 ; just in case an Internet connection isn't available:
>     
>                 if error? try [
>     
>                     ; Attempt to write the area widget text to the FTP file:
>     
>                     write/append group-url mold a/text
>     
>                 ; If there's an error writing, alert the user and quit:
>     
>                 ] [alert "ERROR: Not Saved (check Internet connection)" quit]
>     
>                 ; Otherwise, alert with user with a success message, and end:
>     
>                 alert "Saved"
>                 quit
>     
>             ]
>         ]
>     ]
>     
>     ; If the user chose to listen for reminders, do the following code:
>     
>     if menu = "Listen For Reminders" [
>     
>         ; Print a waiting message in the console.  This can be minimized:
>     
>         print "Listening for reminders..."
>     
>         ; Repeat the following code endlessly:
>     
>         forever [
>     
>             ; Waiting a few seconds saves a lot of bandwidth:
>     
>             wait 5
>     
>             ; "Attempt" is just like "if error? try" - it just doesn't do
>             ; anything if an error occurs.  The point of attempting the
>             ; following code is to ensure the program continues to run if
>             ; the Internet connection is disabled, or the FTP file can't be
>             ; read for any other reason:
>     
>             attempt [
>     
>                 ; Read the text in the FTP file, and assign it the label
>                 ; "reminders":
>     
>                 reminders: read group-url
>     
>                 ; If a new reminder has been added by anyone in the group,
>                 ; the "reminders" text will not match the text stored in the
>                 ; file reminders.txt:
>     
>                 if reminders <> read %reminders.txt [
>     
>                     ; If that's the case, update the reminders.txt file, with
>                     ; the new text read from the FTP file:
>     
>                     write %reminders.txt reminders
>     
>                     ; Create a blank string to store the current reminders:
>     
>                     remind: copy {}
>     
>                     ; Reverse the order of all reminders in the FTP file, so
>                     ; that the newest messages are first, then loop through
>                     ; them with the "foreach" function:
>     
>                     foreach reminder (reverse load reminders) [
>     
>                         ; Append each reminder to the blank text string
>                         ; created above, separated by 2 blank lines:
>     
>                         append remind rejoin [reminder newline newline]
>     
>                     ]
>     
>                     ; Open a GUI window and display the formatted reminder
>                     ; text in an area widget:
>     
>                     view center-face layout [
>                         h3 "Reminders for the group:"
>                         area remind
>                     ]
>     
>                 ]
>             ]
>         ]
>     ]
>     
> 
> Here's the whole program without comments:
>     
>     
>     REBOL [title: "Group Reminder System"]
>     group-url: ftp://user:pass@site.com/public_html/reminders.txt
>     menu: request-list "" ["Create New Reminder" "Listen For Reminders"]
>     write/append %reminders.txt ""
>     if "" = read group-url [write group-url {""}]
>     if menu = "Create New Reminder"  [
>         view center-face layout [
>             h3 "Add a new reminder for the group:"
>             a: area wrap
>             btn "Submit" [
>                 if error? try [
>                     write/append group-url mold a/text
>                 ] [alert "ERROR: Not Saved (check Internet connection)" quit]
>                 alert "Saved"
>                 quit
>             ]
>         ]
>     ]
>     if menu = "Listen For Reminders" [
>         print "Listening for reminders..."
>         forever [
>             wait 5
>             attempt [
>                 reminders: read group-url
>                 if reminders <> read %reminders.txt [
>                     write %reminders.txt reminders
>                     remind: copy {}
>                     foreach reminder (reverse load reminders) [
>                         append remind rejoin [reminder newline newline]
>                     ]
>                     view center-face layout [
>                         h3 "Reminders for the group:"
>                         area remind
>                     ]
>                 ]
>             ]
>         ]
>     ]
>     

### 5.16 A Univeral Report Generator, For Paypal and any other CSV Table Data

> This example creates reports on columns and rows of data in a .csv table. The script demonstrates typical CSV file operations using parse, foreach, and simple series functions. The code performs sums upon columns, and selective calculations upon specified fields, based upon conditional evaluations, searches, etc. Practical column and row based reporting capabilities such as this are a simple and useful skill in REBOL. Using basic permutations of techniques shown here, it's easy to surpass the capabilities of spreadsheets and other "office" reporting tools.
> 
> Actual data for use in testing this example can be downloaded as follows:
> 
>   1. Log into your Paypal account
>   2. Click on My Account -> History -> Download History
>   3. Pick a range of dates
>   4. Select "Comma Delimited - All Activity" (where it's labeled "File Types to Download")
>   5. Save the file to %Download.csv.
> 
> At the time this example code was created, the author's CSV file download contained the following fields ("A" through "AP" - 42 columns).
> 
> Date, Time, Time Zone, Name, Type, Status, Currency, Gross, Fee, Net, From Email Address, To Email Address, Transaction ID, Counterparty Status, Address Status, Item Title, Item ID, Shipping and Handling Amount, Insurance Amount, Sales Tax, Option 1 Name, Option 1 Value, Option 2 Name, Option 2 Value, Auction Site, Buyer ID, Item URL, Closing Date, Escrow Id, Invoice Id, Reference Txn ID, Invoice Number, Custom Number, Receipt ID, Balance, Address Line 1, Address Line 2/District/Neighborhood, Town/City, State/Province/Region/County/Territory/Prefecture/Republic, Zip/Postal Code, Country, Contact Phone Number
> 
> The code automatically handles tables with _any arbitrary number of columns_, allowing fields to be referred to by labels present in the first line of the .csv file.
> 
> The script is simple to understand:
>     
>     
>     REBOL [title: "Paypal Reports"]
>     
>     ; First, read in the lines of the CSV file
>     ; (as described earlier in the CSV/parse section of this tutorial):
>     
>     filename: request-file/only/file %Download.csv
>     lines: read/lines filename
>     
>     ; The first row contains column labels.  Let's convert that CSV line to a
>     ; block, using the parse/all function:
>     
>     labels: copy parse/all lines/1 ","
>     
>     ; Remove extra spaces from each of the labels in the "labels" block:
>     
>     foreach label labels [trim label]
>     
>     ; Now we'll convert the CSV lines into a REBOL data block.  First,
>     ; create an empty block to store the data:
>     
>     database: copy []
>     
>     ; The data values start at line two of the CSV file.  Use foreach and
>     ; parse/all to separate the individual values in each line, and collect
>     ; them into a block of blocks (as described in the CSV/parse section):
>     
>     foreach line (at lines 2) [
>         parsed: parse/all line ","
>         append/only database parsed
>     ]
>     
>     ; For the first report, let's get a list of every person in the "Name"
>     ; Column.  Find the index number of the "Name" column in the "labels"
>     ; block.  We'll use that to pick out name values from each row:
>     
>     name-index: index? find labels "Name"
>     
>     ; Create an empty text string to collect the names:
>     
>     names: copy {}
>     
>     ; Loop through the database, picking the item at the name-index location
>     ; from each row
>     
>     foreach row database [
>         append names rejoin ["Name:  " (pick row name-index) newline]
>     ]
>     
>     ; Display the results:
>     
>     editor names
>     
>     ; Now let's view every transaction in which the name field includes
>     ; "Netflix".  It's basically the same routine as above, only now with an
>     ; added conditional evaluation that uses the "find" function.  And for
>     ; this report, I want to see the amount paid.  I'll set a variable to
>     ; refer to the index position of the "Net" column:
>     
>     net-index: index? find labels "Net"
>     amounts: copy {}
>     foreach row database [
>         if find/only (pick row name-index) "Netflix" [
>             append amounts rejoin ["Amount:  " (pick row net-index) newline]
>         ]
>     ]
>     editor amounts
>     
>     ; Now, let's get a sum of every Netflix transaction between January and
>     ; December, 2012.  The dates are stored in a column labeled "Date", with
>     ; a format like: "12/26/2012" (month/day/year).  We'll need to convert
>     ; that to REBOL's internal format (day-month-year)
>     
>     date-index: index? find labels "Date"
>     
>     ; You've seen earlier how to collect sums.  Start by setting a sum
>     ; variable to 0.  We'll add values to the sum to get a total:
>     
>     sum: $0
>     
>     ; Now loop through the database and perform some conditional evaluations
>     ; on every row:
>     
>     foreach row database [
>         if find/only (pick row name-index) "Netflix" [
>     
>             ; We'll use "parse" to separate the date text at the
>             ; "/" character:
>     
>             date: parse (pick row date-index) "/"
>     
>             ; Pick the month using the values in system/locale/months
>     
>             month:  pick system/locale/months to-integer date/1
>     
>             ; Then rearrange and put back together the date pieces using
>             ; "rejoin":
>     
>             reb-date: to-date rejoin [date/2 "-" month "-" date/3]
>     
>             ; If the date is within the chosen range, add the value to
>             ; the sum:
>     
>             if ((reb-date >= 1-jan-2012) and (reb-date <= 31-dec-2012)) [
>                 sum: sum + (to-money pick row net-index)
>             ]
>         ]
>     ]
>     
>     ; Show the answer:
>     
>     alert form sum
>     
> 
> Here's the entire program without comments:
>     
>     
>     REBOL [title: "Paypal Reports"]
>     filename: request-file/only/file %Download.csv
>     lines: read/lines filename
>     labels: copy parse/all lines/1 ","
>     foreach label labels [trim label]
>     database: copy []
>     foreach line (at lines 2) [
>         parsed: parse/all line ","
>         append/only database parsed
>     ]
>     name-index: index? find labels "Name"
>     names: copy {}
>     foreach row database [
>         append names rejoin ["Name:  " (pick row name-index) newline]
>     ]
>     editor names
>     net-index: index? find labels "Net"
>     amounts: copy {}
>     foreach row database [
>         if find/only (pick row name-index) "Netflix" [
>             append amounts rejoin ["Amount:  " (pick row net-index) newline]
>         ]
>     ]
>     editor amounts
>     date-index: index? find labels "Date"
>     sum: $0
>     foreach row database [
>         if find/only (pick row name-index) "Netflix" [
>             date: parse (pick row date-index) "/"
>             month:  pick system/locale/months to-integer date/1
>             reb-date: to-date rejoin [date/2 "-" month "-" date/3]
>             if ((reb-date >= 1-jan-2012) and (reb-date <= 31-dec-2012)) [
>                 sum: sum + (to-money pick row net-index)
>             ]
>         ]
>     ]
>     alert form sum
>     
> 
> If you want to use this example to create reports for any other CSV file, just copy and paste the first part of the script. It loads and parses a user selected CSV file, and creates a block of labels from the first line:
>     
>     
>     REBOL [title: "Reports"]
>     filename: request-file/only/file %filename.csv
>     lines: read/lines filename
>     labels: copy parse/all lines/1 ","
>     foreach label labels [trim label]
>     database: copy []
>     foreach line (at lines 2) [
>         parsed: parse/all line ","
>         append/only database parsed
>     ]
>     
> 
> You can use this line of code to view the list of column labels in the CSV file:
>     
>     
>     editor labels
>     
> 
> Next, assign variable(s) to the column label(s), on which you want to perform computations:
>     
>     
>     name-index: index? find labels "Name"
>     date-index: index? find labels "Date"
>     net-index: index? find labels "Net"
>     
> 
> Set any initial variables needed to perform computations (sum, max/min, etc.), or to hold blocks of collected values:
>     
>     
>     sum: $0
>     names: copy {}
>     amounts: copy {}
>     
> 
> Use foreach loop(s) to perform conditional evaluations and desired computations on every row of data:
>     
>     
>     foreach row database [
>         append names rejoin ["Name:  " (pick row name-index) newline]
>     ]
>     foreach row database [
>         if find/only (pick row name-index) "Netflix" [
>             append amounts rejoin ["Amount:  " (pick row net-index) newline]
>         ]
>     ]
>     foreach row database [
>         if find/only (pick row name-index) "Netflix" [
>             date: parse (pick row date-index) "/"
>             month:  pick system/locale/months to-integer date/1
>             reb-date: to-date rejoin [date/2 "-" month "-" date/3]
>             if ((reb-date >= 1-jan-2012) and (reb-date <= 31-dec-2012)) [
>                 sum: sum + (to-money pick row net-index)
>             ]
>         ]
>     ]
>     
> 
> Display all the computed or collected results:
>     
>     
>     editor names
>     editor amounts
>     alert form sum
>     
> 
> Of course, the computations above involve quite a bit of evaluation and data processing, in order to demonstrate useful reusable code snippets (such as converting dates to REBOL values that can be manipulated intelligently). In most cases, simple sums, averages, searches, and other common computations will require far less code. You can shorten code even further by using numbers to refer to columns. Simple reports rarely require much more code than the first example in this tutorial:
>     
>     
>     sum: $0
>     foreach line at read/lines http://re-bol.com/Download.csv 2 [
>         sum: sum + to-money pick (parse/all line ",") 8
>     ]
>     alert form sum
>     

### 5.17 Reviewing and Using the Code You've Seen To Model New Applications

> You're already well on your way to understanding how to build useful business applications. At this point, it's wise to go back and review every section in the tutorial. The perspective you have now will help to clarify the value of concepts that were skimmed during a first read. Focus on experimenting with individual lines of code, memorizing functions, and understanding the details of syntax that may have been confusing the first time around. Try repurposing, altering, and editing the complete programs you've seen to far, to be useful in data management activities that apply to your own interests. Here are some ideas for experimentation:
> 
>   1. Add columns to data blocks in the existing apps (i.e, perhaps "email" and "mobile", "home", "work" fields to the contacts examples, or "name" a "title" fields to messages in the reminder app).
>   2. Add new computations to the reporting examples (perhaps average, max, and min functions to columns in the Paypal reports).
>   3. Apply the CSV, sorting, computing, and reporting code patterns you've seen to columns of data exported from other desktop applications and web sites.
>   4. Apply new and more complex conditional operations to computations (perhaps apply tax only to items in a Paypal file that were shipped from a certain state, or apply a fee to prices of items that are made by a certain manufacturer in the "Parts" database app).
>   5. Create a few small GUI apps that _save_ CSV files which can be imported into a spreadsheet (perhaps add a CSV export feature to the "Contacts" or "Parts" examples, and especially try exporting _computed reports_ as CSV files).
>   6. Add list features to the email program (perhaps allow email addresses to be chosen from a contact list, or send emails to a group of users).
>   7. Add useful features to the file editor and web page editor programs (maybe try storing a history of edited files, or FTP login credentials).
>   8. Combine the Inventory and Cash Register programs, so that users can select inventory items from a drop down list in the cash register app.
>   9. Add unique computation routines to the calculator app.
>   10. Experiment with the "parse" and "find" functions (perhaps try adding a search feature to the schedule and email programs, or send pre-formed responses to email messages that contain a given string of text in the subject).
>   11. Experiment with printing and displaying formatted data in the console and in GUI fields (perhaps build an email program that parses the header of each email message, and displays each part on separately printed lines in the console or in separate area widgets in a GUI).
>   12. Add image and file sharing features to the Group Reminders app.
>   13. Add images to stored records in the Parts database app.
>   14. Build GUI versions of the FTP chat and Paypal Reports applications. Use text-list widgets to display messages in chat and to select column names and computation options in reports.
>   15. Experiment with GUI layouts. Position text headers, fields, buttons, areas, text lists, etc. in ways that allow data to be arranged coherently and pleasantly on screen, and which invite intuitive user interactions and natural work flow patterns.
>   16. Experiment with how colors, fonts, widget sizes, images, and other cosmetic features can be used to change the appearance of applications.
> 
> You'll see much more about _how_ to approach tasks like this, as the tutorial progresses, but _exploring creatively_ and learning to use the tools you've seen so far, will go a long way towards building fundamental coding ability. If you learn nothing more than the code presented up to this point, you will already be able to create a wide variety of practical business applications that would be impossible to implement quite so personally using generic off-the-shelf software products. Continue learning, and that potential will increase dramatically.

## 6\. User Defined Functions and Imported Code Modules

> ### 6.1 "Do", "Does", and "Func"

> REBOL's built-in functions satisfy many fundamental needs. To achieve more complex or specific computations, you can create your own function definitions.
> 
> Data and function words contained in blocks can be evaluated (their actions performed and their data values assigned) using the "do" word. **Because of this, _any_ block of code can essentially be treated as a function**. That's a powerful key element of the REBOL language design:
>     
>     
>     some-actions: [
>         alert "Here is one action." 
>         print "Here's a second action."
>         write %/c/anotheraction.txt "Here's a third action."
>         alert "Writing to the hard drive was the third action."
>     ]
>     
>     do some-actions
>     
> 
> New function words can also be defined using the "does" and "func" words. "Does" is included directly after a word label definition, and forces a block to be evaluated every time the word is encountered:
>     
>     
>     more-actions: does [
>         alert "Counting some more actions:  4" 
>         alert "And another:  5"
>         alert "And finally:  6"
>     ]
>     
>     ; Now, to use that function, just type the word label:
>     
>     more-actions
>     
> 
> Here's a useful function to clear the command line screen in the REBOL interpreter.
>     
>     
>     cls: does [prin "^(1B)[J"]
>     
>     cls
>     
> 
> #### 6.1.1 "Func"
> 
> The "func" word creates an executable block in the same way as "does", but additionally allows you to pass your own specified parameters to the newly defined function word. The first block in a func definition contains the name(s) of the variable(s) to be passed. The second block contains the actions to be taken with those variables. Here's the "func" syntax:
>     
>     
>     func [names of variables to be passed] [
>         actions to be taken with those variables
>     ]
>     
> 
> This function definition:
>     
>     
>     sqr-add-var: func [num1 num2] [print square-root (num1 + num2)]
>     
> 
> Can be used as follows. _Notice that no brackets, braces, or parentheses are required to contain the data arguments_. Data parameters simply follow the function word, on the same line of code:
>     
>     
>     sqr-add-var 12 4      ; prints "4",  the square root of 12 + 4  (16)
>     sqr-add-var 96 48     ; prints "12", the square root of 96 + 48 (144)
>     
> 
> Here's a simple function to display images:
>     
>     
>     display: func [filename] [view layout [image load to-file filename]]
>     
>     display (request-file)
>     

### 6.2 Return Values

> By default, the last value evaluated by a function is returned when the function is complete:
>     
>     
>     concatenate: func [string1 string2] [join string1 string2]
>     
>     string3: concatenate "Hello " "there."
>     print string3
>     
> 
> You can also use the word "return" to end the function with a return value. This can be helpful when breaking out of loops (the "for" function performs a count operation - it will be covered in depth in a later section of this tutorial):
>     
>     
>     stop-at: func [num] [
>         for i 1 99 1 [
>             if (i = num) [return i]
>             print i
>         ]
>         return num
>     ]
>     print stop-at 38
>     

### 6.3 Scope

> _By default_, values used inside functions are treated as _global_, which means that if any variables are changed inside a function, they will be changed throughout the rest of your program:
>     
>     
>     x: 10
>     
>     change-x-globally: func [y z] [x: y + z]
>     
>     change-x-globally 10 20
>     print x
>     
> 
> You can change this default behavior, and specify that any value be treated as _local_ to the function (not changed throughout the rest of your program), by using the "/local" refinement:
>     
>     
>     x: 10
>     
>     change-x-locally: func [y z /local x] [x: y + z]
>     
>     change-x-locally 10 20     ; inside the function, x is now 30
>     print x                    ; outside the function, x is still 10
>     
> 
> You can specify refinements to the way a function operates, simply by preceding optional operation arguments with a forward slash ("/"):
>     
>     
>     compute: func [x y /multiply /divide /subtract] [
>         if multiply [return x * y]
>         if divide   [return x / y]
>         if subtract [return x - y]
>         return x + y
>     ]
>     
>     compute/multiply 10 20
>     compute/divide 10 20
>     compute/subtract 10 20
>     compute 10 20
>     

### 6.4 Function Documentation

> The "help" function provides usage information for any function, including user defined functions:
>     
>     
>     help for
>     help compute
>     
> 
> You can include documentation for any user defined function by including a text string as the first item in it's argument list. This text is included in the description displayed by the help function:
>     
>     
>     doc-demo: func ["This function demonstrates doc strings"] [help doc-demo]
>     doc-demo
>     
> 
> Acceptable data types for any parameter can be listed in a block, and doc strings can also be included immediately after any parameter:
>     
>     
>     concatenate-string-or-num: func [
>         "This function will only concatenate strings or integers."
>         val1 [string! integer!] "First string or integer"
>         val2 [string! integer!] "Second string or integer"
>     ] [
>         join val1 val2
>     ]
>     
>     help concatenate-string-or-num
>     concatenate-string-or-num "Hello " "there."  ; this works correctly
>     concatenate-string-or-num 10 20              ; this works correctly
>     concatenate-string-or-num 10.1 20.3          ; this creates an error
>     

### 6.5 Doing Imported Code

> You can "do" a module of code contained in any text file, _as long as it contains the minimum header "**REBOL [ ]**"_ (this includes HTML files and any other files that can be read via REBOL's built-in protocols). For example, if you save the previous functions in a text file called "myfunctions.r":
>     
>     
>     REBOL []  ; THIS HEADER TEXT MUST BE INCLUDED AT THE TOP OF ANY REBOL FILE
>     
>     sqr-add-var: func [num1 num2] [print square-root (num1 + num2)]
>     display: func [filename] [view layout [image load filename]]
>     cls: does [prin "^(1B)[J"]
>     
> 
> You can import and use them in your current code, as follows:
>     
>     
>     do %myfunctions.r
>     
>     ; now you can use those functions just as you would any other
>     ; native function:
>     
>     sqr-add-var
>     display
>     cls
>     
> 
> Here's an example function that plays a .wave sound file. Save this code as C:\play_sound.r:
>     
>     
>     REBOL [title: "play-sound"]  ; you can add a title to the header
>     
>     play-sound: func [sound-file] [
>         wait 0
>         ring: load sound-file
>         sound-port: open sound://
>         insert sound-port ring
>         wait sound-port
>         close sound-port
>     ]
>     
> 
> Then run the code below to import the function and play selected .wav files:
>     
>     
>     do %/c/play_sound.r
>     
>     play-sound %/C/WINDOWS/Media/chimes.wav
>     play-sound to-file request-file/file %/C/WINDOWS/Media/tada.wav
>     
> 
> Imported files can contain data definitions and any other executable code, including that which is contained in additional nested source files imported with the "do" function. Any code or data contained in a source file is evaluated when the file is "do"ne.

### 6.6 Separating Form and Function in GUIs - The Check Writer App

> One common use for functions is to help keep GUI layout code clean and easy to read. Separating widget layout code from action block code helps to clarify what each widget does, and simplifies the readability of code which lays out screen design.
> 
> For example, the following buttons all perform several slightly different actions. The first button counts from 1 to 100 and then alerts the user with a "done" message, the second button counts from 101 to 200 and alerts the user when done, the third button counts from 201 to 300 and alerts the user when done (the "for" function performs a count operation):
>     
>     
>     view layout [
>         btn "Count 1" [
>             for i 1 100 1 [print i]
>             alert "Done"
>         ]
>         btn "Count 2" [
>             for i 101 200 1 [print i]
>             alert "Done"
>         ]
>         btn "Count 3" [
>             for i 201 300 1 [print i]
>             alert "Done"
>         ]
>     ]
>     
> 
> The action blocks of each button above can all be reduced to a common function that counts from a start number to an end number, and then alerts the user. That function can be assigned a label, and then only that label needs to be used in the GUI widget action blocks:
>     
>     
>     count: func [start end] [
>         for i start end 1 [print i]
>         alert "Done"
>     ]
>     view layout [
>         btn "Count 1" [count 1 100]
>         btn "Count 2" [count 101 200]
>         btn "Count 3" [count 201 300]
>     ]
>     
> 
> In large applications where the actions can become complex, separating function code from layout code improves clarity. You'll see this outline often:
>     
>     
>     action1: func [args] [
>         actions
>         actions
>         actions
>     ]
>     action2: func [args] [
>         other actions
>         other actions
>         other actions
>     ]
>     action3: func [args] [
>         more actions
>         more actions
>         more actions
>     ]
>     view layout [
>         widget [action1]
>         widget [action2]
>         widget [action3]
>     ]
>     
> 
> Here's a simple check writing example that takes amounts and names entered into an area widget and creates blocks of text to be written to a check. One function is created to "verbalize" the entered amounts for printing on the check (it converts number values to their spoken English equivalent, i.e., 23482194 = "Twenty Three million, Four Hundred Eighty Two thousand, One Hundred Ninety Four"). Another function is created to loop through each bit of raw check data and to create a block containing the name, the numerical amount, the verbalized amount, some memo text, and the date. The GUI code consists of only 4 lines:
>     
>     
>     REBOL [title: "Check Writer"] 
>     verbalize: func [a-number] [
>         if error? try [a-number: to-decimal a-number] [
>             return "** Error **  Input must be a decimal value"
>         ]
>         if a-number = 0 [return "Zero"]
>         the-original-number: round/down a-number
>         pennies: a-number - the-original-number
>         the-number: the-original-number
>         if a-number < 1 [
>             return join to-integer ((round/to pennies .01) * 100) "/100"
>         ] 
>         small-numbers: [
>             "One" "Two" "Three" "Four" "Five" "Six" "Seven" "Eight"
>             "Nine" "Ten" "Eleven" "Twelve" "Thirteen" "Fourteen" "Fifteen"
>             "Sixteen" "Seventeen" "Eighteen" "Nineteen"
>         ]
>         tens-block: [
>             { } "Twenty" "Thirty" "Forty" "Fifty" "Sixty" "Seventy" "Eighty"
>             "Ninety"
>         ]
>         big-numbers-block: ["Thousand" "Million" "Billion"]    
>         digit-groups: copy []
>         for i 0 4 1 [
>             append digit-groups (round/floor (mod the-number 1000))
>             the-number: the-number / 1000
>         ]    
>         spoken: copy ""
>         for i 5 1 -1 [
>             flag: false
>             hundreds: (pick digit-groups i) / 100
>             tens-units: mod (pick digit-groups i) 100
>             if hundreds <> 0 [
>                 if none <> hundreds-portion: (pick small-numbers hundreds) [
>                     append spoken join hundreds-portion " Hundred "
>                 ]
>                 flag: true
>             ]
>             tens: tens-units / 10
>             units: mod tens-units 10
>             if tens >= 2 [
>                 append spoken (pick tens-block tens)
>                 if units <> 0 [
>                     if none <> last-portion: (pick small-numbers units) [
>                         append spoken rejoin [" " last-portion " "]
>                     ]
>                     flag: true
>                 ]
>             ]
>             if tens-units <> 0 [
>                 if none <> tens-portion: (pick small-numbers tens-units) [
>                     append spoken join tens-portion " "
>                 ]
>                 flag: true
>             ]
>             if flag = true [
>                 commas: copy {}    
>                 case [
>                     ((i = 4) and (the-original-number > 999999999)) [
>                         commas: {billion, }
>                     ]
>                     ((i = 3) and (the-original-number > 999999)) [
>                         commas: {million, }
>                     ]
>                     ((i = 2) and (the-original-number > 999)) [
>                         commas: {thousand, }
>                     ]
>                 ]
>                 append spoken commas
>             ]
>         ]
>         append spoken rejoin [
>             "and " to-integer ((round/to pennies .01) * 100) "/100"
>          ]
>         return spoken
>     ]
>     write-checks: does [
>         checks: copy []
>         data: to-block a1/text
>         foreach [name amount] data [
>             check: copy []
>             append/only checks reduce [
>                 rejoin ["Pay to the order of: "  name  "   "]
>                 rejoin ["$"  amount  newline]
>                 rejoin ["Amount: " verbalize amount newline]
>                 rejoin ["Sales for November    "  now/date  newline newline]
>             ]
>         ]
>         a2/text: form checks
>         show a2
>     ]
>     view layout [
>         text "Amounts and Names:"
>         a1: area {"John Smith" 582 "Jen Huck" 95 "Sue Wells" 71 "Joe Lask" 38}
>         btn "Create Check Data" [write-checks]
>         a2: area
>     ]
>     
> 
> One of the clear benefits of using functions is that you don't have to remember, or even understand, _how they work_. Instead, you only really need to know _how to use them_. In the example above, you don't have to understand exactly how all computations in the "verbalize" function work. You just need to know that if you type "verbalize (number)", it spits out text representing the specified dollar amount. You can use that function in any other program where it's useful, blissfully unaware of how the verbalizing magic happens. Just paste the verbalize code above, and use it like any other function built into the language. This is true of any function you create, or any function that someone else creates. Working with functions in this way helps improve code re-usability, and the power of the language, dramatically. It also encourages clear code structures that others can read more easily.
> 
> Note: The verbalize algorithm was partially derived from the article at http://www.blackwasp.co.uk/NumberToWords.aspx (C# code):

### 6.7 A Full Featured Group Note Sharing App

> In the previous section, the "Group Reminders" and "FTP Chat" applications demonstrated how to save text messages to a web server, so they can be shared with a group of connected users. This application builds on the same idea, adding a number of useful features. The message list display can be updated manually or automatically, at any chosen interval. A repeated beep can be played as an alarm to notify users of new messages (a beep is created with the code: call "echo ^G"). Beep notifications can be turned on and off. Messages are stamped with a time and date, and numbered. Messages can be erased individually by number, or the entire note list can be removed at once. An unlimited number of private "rooms" can be created, simply by changing the URL. A new file will be automatically created at the entered URL, if it doesn't exist.
> 
> All of the features in this program are implemented as separate functions. The "update" function, in particular is called not only when the user clicks the update button, but also by other functions, any time a change is made which requires updating the display (when erasing messages, when autoupdate is turned on, etc). Notice that the GUI layout is kept clean, and each widget simply calls a function:
>     
>     
>     REBOL [title: "Group Notes"]
>     url: ftp://user:pass@site.com/public_html/Notes
>     beep: false   autoupdt: false   call ""
>     write/append %notes.txt ""
>     update: does [
>         if error? try [notes: copy read/lines url] [write url notes: ""]
>         if ((beep = true) and (notes <> read/lines %notes.txt)) [
>             loop 4 [call "echo ^G" wait 1]
>         ]
>         write/lines %notes.txt notes
>         display: copy {}
>         count: 0
>         foreach note reverse notes [
>             either note = "" [
>                 note: newline
>             ] [
>                 count: count + 1
>                 note: rejoin [count ") "note]
>             ]
>             append display note
>         ]
>         a/text: display
>         if a/text = "" [a/text: copy " "]
>         show a
>     ]
>     autoupdate: does [
>         either autoupdt: not autoupdt [
>             time: request-text/title/default "Refresh display (seconds):" "10"
>             b/text: join "Auto Update:  " autoupdt  show b
>             forever [
>                 either autoupdt = true [wait to-integer time update] [break]
>             ]
>         ] [
>             b/text: join "Auto Update:  " autoupdt  show b
>         ]
>     ]
>     submit: does [
>         if f/text = "" [focus f  return]
>         if error? try [
>             write/lines/append url rejoin [
>                 "^/^/" now " (" n/text "):  " f/text
>             ]
>         ] [alert "ERROR: Not Saved (check Internet connection)" return]
>         update
>         f/text: copy ""  show f  focus f
>     ]
>     erase: func [arg] [
>         if true = request rejoin ["Really erase " arg "?"] [
>             write/lines to-file replace/all replace form now "/" "--" ":" "_"
>                 notes
>             if arg = "all" [write url ""]
>             if arg = "" [
>                 indx: (
>                     3 * to-integer request-text/title/default "Index:" "1"
>                 ) - 2
>                 remove/part at notes indx 3 
>                 write/lines url reverse notes 
>             ]
>             update
>         ]
>     ]
>     changeurl: does [
>         url: to-url u/text  
>         update
>         focus f
>     ]
>     setbeep: does [
>         beep: not beep  
>         p/text: join "Beep: " beep
>         show p
>     ]
>     insert-event-func [either event/type = 'close [quit][event]] 
>     view center-face layout [
>         h3 "Current notes for:"
>         u: field 600 form url [changeurl]
>         a: area 600x260
>         h3 "Name:"
>         n: field 600
>         h3 "New Note:"
>         f: field 600 [submit]
>         across
>         btn "Update" [update]
>         b: btn join "Auto Update: " autoupdt [autoupdate]
>         p: btn join "Beep: " beep [setbeep]
>         btn "Erase" [erase ""]
>         btn "Erase All" [erase "all"]
>         do [update focus f]
>     ]
>     
> 
> Later in this text, a web based CGI version of this application will be presented, so that users can view and enter notes with either this desktop version of the program, or with a browser based interface, to share and interact with the exact same live data on any platform. Enabling different interfaces can be useful on mobile OSs or on any system where an executable program can't be installed.

## 7\. A Few Useful Data Visualization Tools

> ### 7.1 Displaying and Sorting Data Using Spreadsheet-Like GUI Grids

> As you've already seen in the "Contacts" example, it's possible to dynamically construct GUIs using foreach loops, to display data in GUI fields. We'll build on examples such as the following in a later chapter:
>     
>     
>     REBOL [title: "Display a Table of Data"]
>     
>     ; Build 500 rows of 3 columns of random data:
>     x: copy[] for i 1 500 1[append x reduce [i random "abcd" random 1-1-2012]]
>     
>     ; Display it:
>     grid: copy [across space 0]
>     foreach [indx text date] x [
>         append grid compose [
>             field 50 (form indx)
>             field 70 (form text)
>             field 110 (form date)
>             return
>         ]
>     ]
>     view center-face layout [
>         across
>         g: box 230x200 with [pane: layout/tight grid pane/offset: 0x0]
>         scroller [g/pane/offset/y: g/size/y - g/pane/size/y * value show g]
>     ]
>     
> 
> Using raw building blocks of GUI field widgets, even the simple example above requires quite a bit of thought to display a small grid filled with table data, and normal features such as column resizing, sorting, etc., require advanced coding skill. To load, display, sort, and save flat lists and blocked table data, the following compressed code is provided to simplify the required code. Just define a block of header labels, assign the variable label "x" to your grid data, and include the compressed grid code, and you've got a fully functional data grid:
>     
>     
>     REBOL [title: "Table/Grid/Listview Example"]
>     
>     headers: ["Numbers" "Text" "Dates"]
>     
>     x: [
>         [1   "1"   1-1-2012]
>         [11  "11"  1-2-2012]
>         [2   "2"   1-3-2012]
>     ]
>     
>     do decompress #{
>     789CC518C98EDB36F4AEAF78500FB11228B2074D0AA8B3A01F904BAF860EB245
>     D9CAD0A2225133720CFF7B1F77D24BE324456A60C626F9F69D1C5B4A86015E4A
>     3A922778B3199B7445D9FA1996F6670E8763118D21E004CB298735EBF6B02CCE
>     4EC9AEE3FB74E8CA3581A5B7C8615E447B8D3741B46674DCB5430E94B41BBE7D
>     822D292BD20F91FA36FC25F8E118F5A423258706341E2C23C04FD975A4ADC0C7
>     819E7C664D0BCB781B237C9C713271888BA83821CD9946F0B7A355734AEFCDB0
>     1F38D945949595DA22550EF5D8AE615995BC4CEB8612C87AF26524032FB4644D
>     0D7AC783CACD9E5C65ACA5FB4C625B8842A9C5B9309D26253ED672FA5B08E3B0
>     2CD8B065AF401BB9161A0FE50BF945320B56C2A6E1194C2885B45C4D4BFECBCD
>     56A3BDAE98CAC5303870D663C82C606682B29E929388331FC12908D265119C0B
>     529F610E33839EC22241D2211517C28E1E740DFEAB279835F00E3E271060845C
>     14B2B40826554FAA11D3CE91B2B09E8E3692FE3D68FE37775D720A29D75BE851
>     CAE9C47EDA78B5D51D819CD24E43119B4E8B7A72BAB29EA7CA4546DBBA21B432
>     0A92866F490F128CF55814726819F7D69E4062335BB35D57F618F79A5A092BA4
>     35C3DA5582A49CC02388E54A2F9594C50FD0B9BF484719CEF8B4889E0956E075
>     CF28350AAA555AEED8D85A4F0E69C7B01ACB2F0CBB00C6B85A1D3EBAF4C0EC58
>     6A44BB5584D0F798030666AE2B05CD842F0CB32CA01788AF7F0C14F5E8C9D07C
>     25E9A66F6C25EB48BF262D2F37C468213A970043DAB268672F0D79CD501942DA
>     B4C6369475654BB2452680E04F9194F3692E516983012BB6B345EE2FE02D383E
>     279077B9E598DD2131AFDF4948AE85E9D18A15AAE951F5B4F6BB4D92681369CC
>     126D54363D2C3EFA6C25CCD84AE564EEA314A0561D6F18561B212FD2142A032D
>     F76CE4E0357865CBC259B56E30D92B46861FB1A3C4F0DC03336B14A1A7AF750A
>     EF1709B22DAB2AA54D4B0CD3B014600B9E647F6E50890DE698A927A29567BCE1
>     58552A529723C5C6FE5755A9E163C082228BC46F79EC178F9D4F89BDF4E9DA45
>     B4E0040F22447BC2C7BE5501DA92D754910C6BFB597B083C278ABBAE478E80C2
>     8F639D15ED4030B7A5CB44EE4E5280C48777992B9CB363588AFF2343FD8D7439
>     0345348FE1E76C8407BC1F09DC3FDA0E6007AFBF150B88552B535A42FC141721
>     0D254A60095FFD33E52512A355FA5D7A7F123CEA9EEDBE2B38844B6E60A3C90B
>     BB7AC4D138B399A1206C970086CECC882E7792DBEDF929B4A625736E5161B20C
>     855126358089D5C66F0C3BAC5463D7511C08825E475E48FB84718B851F9BA1C8
>     75EC8F0C1BDFEBB6E1A2D2FA7B77BFCFDFCBBF0F1F9404122FD7E8EF5489370A
>     B6ACC52BC297DC28E2F31026CD4DB600991A6EEDA2DD8256BB20D4DD1C99CF3D
>     01E4A1EA2F6BDBBC3C1692F717116E44CCA6036D2A34F65E8C2DDA0CED062BBD
>     9D06B0DF12BF3B3762E701DE8C1DF635373D288238318AFB831E46826B442DF9
>     BB99643DAAF29CDF88E90B6070E1F1012ED5A230287CA94BCAD38ABD62540DBC
>     94C2E31493034E69753D104F3C214D8AF1A0653C0463573F7CC5D140F8B96E7A
>     8CD4966C4A8E898CB54F51C442EFD14F02648C3BE90ED36BC335621AEA01165A
>     7966D44E2CEEA5DD5B2860642E12ADF3299DF0EC766A9764F24FF0F7454ADBAB
>     525D3BB926D329BC91E8F2FE35796485D04E399DC44E288939C1E21EED2FBCAC
>     530112C4101C9CA78E36826FC691FC8E10AE2F86B748CC4B0187C11A6CDB6075
>     E11F5EB590A8854173DD9FB640F3A95828F5C905448C59A46A785064B04EF7AE
>     C4B093023363508A81D1543E6C0AB5AC69A26BE8CD5C6F190F19664AB59B4B58
>     7869D53532E873A691AAC3E0B6182AF9EDA1514EDD29CCA70FF3C88E856E86C6
>     A39919783FCEFD693A89BE3511FFD0A86DEE25105CF0641F066B66D1B5223DD8
>     B9195A154429B5151F4ABC350D628693CF5FE666211DAF59C36AE49CB5560B25
>     2476315861F83FAB1E0B2BECDCD1B71EBD9C2C6650B03E39887FDB23621E72C3
>     F888C301354F5B4396E319D48450701DF028E604317059979EB1928C0C79FBB6
>     2173F1DC44B9D156E916F7312CFE9850D72014A5B91FECD483D32366E2536C1F
>     19F797225CE5A1BE8EA9FB9A0B07FF2E2D6DBF2694828C5E0D2015B74969A1CF
>     FDF7B34E101F44D4AE90721C3D35507DF3702AE799C15E211C6139A5AA53F45A
>     7199BB71DC05971DF4C3801AF6C08E7DFAA299EBBBBE78E5A0DA7C3A2FFC7BF9
>     5B252884CED06E385EE3FA4CF6E26FCD2AA43A765884DC7304A40BF35A118089
>     F12404BC0CD761894BCF68DECDAF039F5356D0C7C87BF1B6CFC2764FBD093BD5
>     CC83F03FD2FC2B1641170000
>     }
>     view center-face gui: layout gui-block
>     
> 
> Other options such as coloring rows, and specifying column data types, using the compressed table code above, are demonstrated in the following example. This is a critically useful tool for data entry, visualization, and demonstration:
>     
>     
>     REBOL [title: "Table/Grid/Listview Example With Expanded Features"]
>     
>     headers: ["Numbers" "TEXT (Note Sort)" "Dates"] ; REQUIRED COLUMN LABELS
>     
>     ; ALL THESE ADDITIONAL SETUP PARAMETERS ARE *** OPTIONAL ***:
>     
>     x: [[1 "1" 1-1-2012][11"11"1-2-2012][2"2"1-3-2012]]  ; some default data
>     
>     colors: [blue black red]    ; specify column colors like this
>     empty-space: 235            ; size of blank GUI area to appear below grid
>     svv/vid-face/color: white   ; default GUI face color
>     
>     ; Here's how to include GUI layout code to appear above the grid: 
>     
>     gui-block: {
>         h3 "RIGHT-CLICK/DRAG HEADERS TO RESIZE COLUMNS.  RESIZE WINDOW..."
>         text "Click headers to sort (note that sort is DATA-TYPE SPECIFIC)."
>         text "Notice Arrow Keys, PgUp/PgDn Keys, Scroll Bar, and highliting"
>         text "Click any cell to edit data. Buttons load and save data to HD."
>     }
>     
>     ; The following line automatically fits grid to resized GUI window:
>     
>     insert-event-func [either event/type = 'resize [resize-fit none] [event]]
>     
>     do decompress #{
>         789CC518C98EDB36F4AEAF78500FB11228B2074D0AA8B3A01F904BAF860EB245
>         D9CAD0A2225133720CFF7B1F77D24BE324456A60C626F9F69D1C5B4A86015E4A
>         3A922778B3199B7445D9FA1996F6670E8763118D21E004CB298735EBF6B02CCE
>         4EC9AEE3FB74E8CA3581A5B7C8615E447B8D3741B46674DCB5430E94B41BBE7D
>         822D292BD20F91FA36FC25F8E118F5A423258706341E2C23C04FD975A4ADC0C7
>         819E7C664D0BCB781B237C9C713271888BA83821CD9946F0B7A355734AEFCDB0
>         1F38D945949595DA22550EF5D8AE615995BC4CEB8612C87AF26524032FB4644D
>         0D7AC783CACD9E5C65ACA5FB4C625B8842A9C5B9309D26253ED672FA5B08E3B0
>         2CD8B065AF401BB9161A0FE50BF945320B56C2A6E1194C2885B45C4D4BFECBCD
>         56A3BDAE98CAC5303870D663C82C606682B29E929388331FC12908D265119C0B
>         529F610E33839EC22241D2211517C28E1E740DFEAB279835F00E3E271060845C
>         14B2B40826554FAA11D3CE91B2B09E8E3692FE3D68FE37775D720A29D75BE851
>         CAE9C47EDA78B5D51D819CD24E43119B4E8B7A72BAB29EA7CA4546DBBA21B432
>         0A92866F490F128CF55814726819F7D69E4062335BB35D57F618F79A5A092BA4
>         35C3DA5582A49CC02388E54A2F9594C50FD0B9BF484719CEF8B4889E0956E075
>         CF28350AAA555AEED8D85A4F0E69C7B01ACB2F0CBB00C6B85A1D3EBAF4C0EC58
>         6A44BB5584D0F798030666AE2B05CD842F0CB32CA01788AF7F0C14F5E8C9D07C
>         25E9A66F6C25EB48BF262D2F37C468213A970043DAB268672F0D79CD501942DA
>         B4C6369475654BB2452680E04F9194F3692E516983012BB6B345EE2FE02D383E
>         279077B9E598DD2131AFDF4948AE85E9D18A15AAE951F5B4F6BB4D92681369CC
>         126D54363D2C3EFA6C25CCD84AE564EEA314A0561D6F18561B212FD2142A032D
>         F76CE4E0357865CBC259B56E30D92B46861FB1A3C4F0DC03336B14A1A7AF750A
>         EF1709B22DAB2AA54D4B0CD3B014600B9E647F6E50890DE698A927A29567BCE1
>         58552A529723C5C6FE5755A9E163C082228BC46F79EC178F9D4F89BDF4E9DA45
>         B4E0040F22447BC2C7BE5501DA92D754910C6BFB597B083C278ABBAE478E80C2
>         8F639D15ED4030B7A5CB44EE4E5280C48777992B9CB363588AFF2343FD8D7439
>         0345348FE1E76C8407BC1F09DC3FDA0E6007AFBF150B88552B535A42FC141721
>         0D254A60095FFD33E52512A355FA5D7A7F123CEA9EEDBE2B38844B6E60A3C90B
>         BB7AC4D138B399A1206C970086CECC882E7792DBEDF929B4A625736E5161B20C
>         855126358089D5C66F0C3BAC5463D7511C08825E475E48FB84718B851F9BA1C8
>         75EC8F0C1BDFEBB6E1A2D2FA7B77BFCFDFCBBF0F1F9404122FD7E8EF5489370A
>         B6ACC52BC297DC28E2F31026CD4DB600991A6EEDA2DD8256BB20D4DD1C99CF3D
>         01E4A1EA2F6BDBBC3C1692F717116E44CCA6036D2A34F65E8C2DDA0CED062BBD
>         9D06B0DF12BF3B3762E701DE8C1DF635373D288238318AFB831E46826B442DF9
>         BB99643DAAF29CDF88E90B6070E1F1012ED5A230287CA94BCAD38ABD62540DBC
>         94C2E31493034E69753D104F3C214D8AF1A0653C0463573F7CC5D140F8B96E7A
>         8CD4966C4A8E898CB54F51C442EFD14F02648C3BE90ED36BC335621AEA01165A
>         7966D44E2CEEA5DD5B2860642E12ADF3299DF0EC766A9764F24FF0F7454ADBAB
>         525D3BB926D329BC91E8F2FE35796485D04E399DC44E288939C1E21EED2FBCAC
>         530112C4101C9CA78E36826FC691FC8E10AE2F86B748CC4B0187C11A6CDB6075
>         E11F5EB590A8854173DD9FB640F3A95828F5C905448C59A46A785064B04EF7AE
>         C4B093023363508A81D1543E6C0AB5AC69A26BE8CD5C6F190F19664AB59B4B58
>         7869D53532E873A691AAC3E0B6182AF9EDA1514EDD29CCA70FF3C88E856E86C6
>         A39919783FCEFD693A89BE3511FFD0A86DEE25105CF0641F066B66D1B5223DD8
>         B9195A154429B5151F4ABC350D628693CF5FE666211DAF59C36AE49CB5560B25
>         2476315861F83FAB1E0B2BECDCD1B71EBD9C2C6650B03E39887FDB23621E72C3
>         F888C301354F5B4396E319D48450701DF028E604317059979EB1928C0C79FBB6
>         2173F1DC44B9D156E916F7312CFE9850D72014A5B91FECD483D32366E2536C1F
>         19F797225CE5A1BE8EA9FB9A0B07FF2E2D6DBF2694828C5E0D2015B74969A1CF
>         FDF7B34E101F44D4AE90721C3D35507DF3702AE799C15E211C6139A5AA53F45A
>         7199BB71DC05971DF4C3801AF6C08E7DFAA299EBBBBE78E5A0DA7C3A2FFC7BF9
>         5B252884CED06E385EE3FA4CF6E26FCD2AA43A765884DC7304A40BF35A118089
>         F12404BC0CD761894BCF68DECDAF039F5356D0C7C87BF1B6CFC2764FBD093BD5
>         CC83F03FD2FC2B1641170000
>     }
>     
>     ; APPEND ANY WIDGETS AND/OR GUI CODE TO APPEAR BELOW THE GRID, HERE:
>     
>     append gui-block [
>     
>         ; REPLACE 'BTN' WITH 'KEY' TO HIDE BTNS AND STILL USE KEY SHORTCUTS.
>         ; CHANGE/REMOVE BUTTONS AND/OR KEYBOARD SHORTCUTS AS NEEDED:
>     
>         text "" return
>         btn "Insert (Ins)" keycode [insert] [add-line] 
>         btn "Remove (Del)" #"^~" [remove-line]  
>         btn "Move (CTRL+M)" #"^M" [move-line]
>         btn "Grow (+)" #"+" [resize-grid 1.333]
>         btn "Shrink (-)" #"-" [resize-grid .75]
>         btn "Fit (CTRL+R)" #"^R" [resize-fit]
>         return
>         btn "Load Blocked (CTRL+O)" #"^O" [load-blocked/request %blocked.txt]
>         btn "Save Blocked (CTRL+S)" #"^S" [save-blocked/request %blocked.txt]
>         btn "Load Flat (CTRL+U)" #"^U" [load-flat/request %flat.txt]
>         btn "Save Flat (CTRL+F)" #"^F" [save-flat/request %flat.txt]
>     
>     ; LOAD A DEFAULT DATA *FILE HERE (instead of specifying it in code above):
>     ; Not that the "load-flat" and "save-flat" functions load "flat" blocks,
>     ; which are simply long sequences of data values.  The "load-blocked" and
>     ; "save-blocked" functions load block which have rows enclosed inside
>     ; deliniated blocks.  All of those functions provide an optional
>     ; "/request" refinement that allows the user to select a file:
>     
>         ;  do [load-blocked %blocked.txt] 
>     
>     ]
>     view/options center-face gui: layout gui-block [resize]
>     
> 
> Details about how to build GUI grids from native REBOL code, including the compressed code above, will be examined fully in later sections of this tutorial. For now, the general solution above is immediately functional, and can be applied to the majority of situations where a visual grid tool is required to enter, display, sort, load, save, and otherwise manipulate table data.

### 7.2 Creating Graphs, Plots, and Charts with "Q-Plot"

> REBOL's complete graphics toolkit will be fully explored in detail, in future sections of this tutorial. For the moment, the "q-plot" dialect by Matt Licholai is a simple solution for creating bar, line, pie and other charts from block data. You can download and run the q-plot dialect like this:
>     
>     
>     REBOL []
>     if not exists? %q-plot.r [write %q-plot.r read http://re-bol.com/q-plot.r]
>     do %q-plot.r
>     
> 
> Once q-plot is downloaded, graphing a block of values is as simple as this:
>     
>     
>     view quick-plot [
>         600x400                            ; set the program window size
>         bars [5 3 8 2 10 3 4 9 5 7]        ; set graph type and data to plot
>     ]
>     
> 
> Using the code above, here's a complete bar graph example:
>     
>     
>     REBOL [title: "Minimal Bar Graph Example"]
>     if not exists? %q-plot.r [write %q-plot.r read http://re-bol.com/q-plot.r]
>     do %q-plot.r
>     view quick-plot [
>         600x400
>         bars [5 3 8 2 10 3 4 9 5 7]
>     ]
>     
> 
> Notice that the q-plot dialect syntax looks very much like REBOL's build in VID dialect for building GUIs. The primary difference is that "view layout" is replaced with "view quick-plot". Here's an example that demonstrates how to adjust colors, add text labels, and attach scales for each XxY data axis:
>     
>     
>     REBOL [title: "Another Bar Graph Example"]
>     if not exists? %q-plot.r [write %q-plot.r read http://re-bol.com/q-plot.r]
>     do %q-plot.r
>     view center-face quick-plot [
>         600x300
>         y-min 0                           ; minimum value to display on y axis
>         fill-pen blue                     ; set fill color
>         pen green                         ; set outline and text color
>         bar-width 80                      ; set bar width
>         bars [5 3 8 2 10 3 4 9 5 7]
>         pen black                         ; set outline and text color
>         label "Fat Bars"                  ; optionally add labels
>         y-axis 11                          
>         x-axis 10
>     ]
>     
> 
> Pie charts are just as simple to create. Here's a pie chart example with 2 specified sections of the pie "exploded" out for emphasis (the "explode [3 5]" code is optional):
>     
>     
>     REBOL [title: "Exploded Pie Chart"]
>     if not exists? %q-plot.r [write %q-plot.r read http://re-bol.com/q-plot.r]
>     do %q-plot.r
>     view center-face quick-plot [
>         400x400
>         pie [10 3 6 1 8] labels [A B C D E] explode [3 5]
>         title "Exploded Sections C and E" style vh2
>     ]
>     
> 
> Line graphs are also simple to create:
>     
>     
>     REBOL [title: "Simple Line Graph Example"]
>     if not exists? %q-plot.r [write %q-plot.r read http://re-bol.com/q-plot.r]
>     do %q-plot.r
>     view quick-plot [
>         400x400
>         line [1 2 4 8 16 32 64 128 256]
>     ]
>     
> 
> Here's a more complex line graph example that demonstrates how to plot a predefined block of data, how to add a title, how to add text with a font and defined position (up and over a percentage of the window), and how to attach a scaled grid to the display:
>     
>     
>     REBOL [title: "Another Line Graph Example"]
>     if not exists? %q-plot.r [write %q-plot.r read http://re-bol.com/q-plot.r]
>     do %q-plot.r
>     my-block: copy [2]
>     loop 10 [append my-block (2 * last my-block)]
>     option-font: make face/font [
>         size: 30
>         style: [italic bold underline]
>         name: font-serif
>     ]
>     view center-face quick-plot [
>         500x500
>         scale linear 
>         line [(data: copy my-block)]
>         title style vh1 "Linear scale"
>         x-axis 7 border
>         y-axis 7 border
>         x-grid 7
>         y-grid 7
>         text font option-font "Formatted Text" color red up 50 over 40
>     ]
>     
> 
> Here's an extension of the "Paypal Reports" program you've seen earlier in this text. It plots all the gross transaction numbers using a bar graph, and makes a pie chart of transactions with Saoud Gorn:
>     
>     
>     REBOL [title: "Paypal Reports Charts"]
>     transactions: copy []
>     saoud: copy []
>     dates: copy []
>     foreach line at read/lines http://re-bol.com/Download.csv 2 [
>         row: parse/all line ","
>         append transactions to-integer row/8
>         if find row/4 "Saoud" [
>             append saoud to-integer row/8
>             append dates replace row/1 "/2012" ""
>         ]
>     ]
>     if not exists? %q-plot.r [write %q-plot.r read http://re-bol.com/q-plot.r]
>     do %q-plot.r
>     view quick-plot [
>         594x400
>         bars [(data: copy transactions)]
>         label "All Paypal Transactions"
>     ]
>     view center-face quick-plot [
>         495x530
>         pen blue
>         pie [(data: copy saoud)] labels [(data: copy dates)] explode [1 2 3]
>         title "Saoud" style vh2     
>     ]
>     
> 
> This example demonstrates how to include several plots in one window. The default alignment for multi-plots is vertical. The "multi-plot/across" refinement lays them out horizontally:
>     
>     
>     REBOL [title: "Multi-Plots"]
>     if not exists? %q-plot.r [write %q-plot.r read http://re-bol.com/q-plot.r]
>     do %q-plot.r
>     m-plots: multi-plot/across 594x200 [ 
>         [
>             title "2 to a Power"
>             pen green 
>             line [0 2 4 8 16 32 64 128] 
>         ]
>         [
>             title "Rizing"
>             pen white
>             line [0 5 10 15 20 25] 
>         ]
>         [
>             title "Falling"
>             pen blue    
>             line [25 20 15 10 5 0] 
>         ] 
>     ]
>     view m-plots
>     
> 
> This example demonstrates how to place plots in sub-panels for easy switching:
>     
>     
>     REBOL [title: "Switching Plots"]
>     if not exists? %q-plot.r [write %q-plot.r read http://re-bol.com/q-plot.r]
>     do %q-plot.r    
>     window: layout [
>         vh2 "Switching Plots"
>         guide 
>         pad 20
>         button "Sine Wave"   [graph/pane: plot1 show graph]
>         button "Parabola"    [graph/pane: plot2 show graph]
>         button "Cubic Curve" [graph/pane: plot3 show graph]
>         return
>         box 2x204 blue
>         return
>         graph: box 354x204 coal
>     ]
>     data1: copy []
>     data2: copy []
>     data3: copy []
>     for i -400 400 .5 [
>         append data1 sine i
>         append data2 (i * i)
>         append data3 (i ** 3)
>     ]
>     graph-size: 350x200
>     plot1: quick-plot [
>         (graph-size)
>         line [(data1)]
>         title "Sine Wave"
>     ]
>     plot2: quick-plot [
>         (graph-size)
>         line [(data2)]
>         title "Parabola"
>     ]
>     plot3: quick-plot [
>         (graph-size)
>         line [(data3)]
>         title "Cubic Function"
>     ]
>     plot1/offset: 2x2
>     plot2/offset: 2x2
>     plot3/offset: 2x2
>     graph/pane: plot1
>     view window
>     
> 
> Be aware that instead of downloading and running the q-plot dialect from an external file, you can include the compressed q-plot code directly in your program:
>     
>     
>     REBOL [title: "Q-Plot Compressed"]
>     do decompress #{
>     789CED7DFB93E3B871F0EFFB57E0A6F2D5483BC779DDAD1F5ADF6DD93EA77229
>     3B71EE6C5752AA498A92A0197A299126A91DCA17FFEFE9071E0D02943433BB4E
>     3E27AABB5989041A40BFD16800DFFDEA17FFFC6B357FA5E0F3BBA22BF54C9DFD
>     CBAE58BE57BF2DAB4E7D53E4A55E7667F4FE9BBC83D7376FB2BFD78BECF6FAFA
>     969EFE41376D516D67EAFAF2E6F29A1EFD7D8170FEDF9FB21A605C36F4ECE7BB
>     EEA16A00FA6FF2AE53BF2E960F5599170CF8BBE2FEA16BE1DD64395500F8E673
>     84AE7E733928F7FB36BF07C03FFCBED52A6F55AE1665053D5D6BBD2AB6F7EA3B
>     1ACB1FBEFD46ADB8DB974A7DAFB5D27F361D51EBAA512BDDE545D9FE8520FE76
>     D7D4558B307FDB541F8A15C0557FA2E1E7DB95D279BB575DA576D09E01492010
>     5A872D165B6E9481FDB2DA6CF4B60360BFABB26F2AF5D557F4587EFE0146AAB2
>     2C7AFE1BBDC2C7FF9EFD7B261F5FA8DFD72BC0FAD5AFFA9A3AE446B2AA963B6C
>     2CEF00F711B85F578F004E25E0FD7CB5526D972FDF43838BBC51CB87BCE9DAA8
>     E06BF59D7EAC9AF7AA576575AFDA655EC278A91D1EEB3F146D5735FB999A5F5F
>     02E1D5FCE63AFB462F912D6ED4D9B7DBA2037C39A42DF216DAABB66AB327E4A9
>     F56EBBC49EB767778AE021945B80F2A580F28BBC2D9640E81A40B40ABB037DB8
>     9435BE801A3FF6357EF8E543BEBD879680668DEE76CD16C859E6FB6AD7A96AF1
>     4700F3B9DAE408057AD6D6F006495CE8E6F22F02E8976AFE26FBC77C4B2CAECE
>     7E59EA7C0B3077B55A56C82040872553BAFD5CE5AB15BC03E4E8AC06C6D64D38
>     A437D04101EC875F564D03DD802AB9AA9B6A51EA8D7A2CBA0755ADD7AD66A6EA
>     1EB48A286A3F3D52AFE9545D15DB8EFAB205742EA133BAC1CA40D3560EE647D0
>     811F253B10345FE60B5DB604EF43DE14D5AE558BDDBD5A17BD0EC0FD18C0FD54
>     20E7E734FCCDAEEC8A2C20AC44C24FD4FCF64654FA4DB105215A225E33C02A36
>     DAE84DF50118A65AABFBB25AC03720F72A40E54F018A68FA87EF090F4C712478
>     BE75342E3630B80F5AD5800CCD4AE2F3518C02051D8F6B46C112FEC0F70EF500
>     B039FC2531F18800454784B58A10F1BAA94B8D785D528F5AEC12B5FF3981643E
>     591047D7858E01DE10A104C090EDAE2CCB0968BA0794E317071068F5EA8E40FE
>     6A034A0E74F026CBDA2C2B8D1ACDB2426B9D6555C3B2EC9052168B262771F68F
>     F4070D10E605B2D606342CE8A13B5F03A4A7035DB8811279598A17DDBE067D3A
>     37A27FE79EAF2AE8129889F97D93D70FC5B2B5DAA105990416BCDF15BE7007D8
>     D7AB6CB75D69B019DB6A2B44A2DDD575D574C3C73046BD45553E280DE3CDCBB6
>     025C38ED492F1153AF48D7D3D3CCF466861A421B56FA0CF0C1AAFD0FDF67DFAE
>     40B3ABBFC37FAC65FBFC83BAB9FCE20BB459B757F0DFCD4FC13CCEBEB89EDDFC
>     0407D529D0DBEAEF4065BAEED097B7A09C871FF3E26CA59765DEE83316005006
>     7907225A966AA1D10EADD0E6A086E00E9A5A60BB1F8A56C17F5BB085AC00EB06
>     08083A82E104B5D4BAA936AEEA62B758A0764756837A46FE88FC4A4D48090385
>     F754BFCD37647ACFA12B024007D4D5EDF6BC8376BAA65AED966848B7FAD18001
>     B12E8094C65C5D4E4DD541A7573B1664543DEF6C8F1F4149B3615F361A581014
>     1380B2C6089B478B8C83841A2D5A70675B48B515562DB497A6C6F7BA43C8A019
>     DEEB7D123DD00964A2515A196A81C2CEF6D90699DA1537CFF27EF0AC4F94EB07
>     E53AF6BFC2DF19A8C5563C244D9D6D1BF108747EF658ACBA07F16C9F81DF908B
>     07FDF0419DB5C59F6573EB5D590E9F35BA05DD2E1E0086C0D0351BD9A5955EE7
>     502A5B57DB402AEDF3655556617F41E6860F1D10E075F17857C725ABC76D0C13
>     C8A86334F419BF0830133DEA333000191980A060EA2913A5EDF6C1D3D57E9B6F
>     8A65541A9E67F5D222F000438D7E4C1DE35101758CBD0496754F1E1FF4D608D1
>     739A606A7978331221610AE6CBBC5B3E78ED7C0516352FDD4FE26D45DCAC481E
>     D4DE7C5F15EB35FC435869EC9755F667DD54501E547C4DCC4B5F3ABDA9B345F9
>     9E95B36FBC58AB89E3BAA99A1BC7CE3DBA83E1B6EF8B9A04D80D82140D3B6C00
>     E0519F833B9097A041567B6020E0D0A20B75F233F036201243F827DD83CE8549
>     C7B6DD0195487F234A906A8414FAD6839B55EED0DD8032A00B040014CDA6AA75
>     032AD7F9CD383634ACA849518EB185DC330114BD2F40DB5F8670BEA9C83B0457
>     A8510D4F6E406F376441CB42AFB813971F71FC1A342E366035A39A1B05E99EDC
>     09BE1235585F0DDEB11452FD75D1B484C862B3DB64D5DA5688CA03B551D6DE19
>     4E8C01E2C7F21AF40B3C0960937A6F00268B3F3EC08456CD05DCE128467BEC5B
>     DA2263044C3EFCDC454FC32777A76307EC5EB362DF353DACBF6534BD8ABF8D30
>     28C8E3DC586BF7E4190C8AF50D09F2FE290C8AED7F0ACCC7A318EDF1A767D024
>     765ABDACB62773E8DF1A9E4EE45036ACF3DEABD0FE800AEDC738B41F5112FD11
>     C4F74F540D23F0F013203E3988D10E7F6206356DDD3C9740C89ABD5721FD0115
>     72884049213981404F928C2710E8B064F49F4A32F0738C62C714B2E860A9B7F7
>     DDC3BB319590009EA8BCAE764DF77048558D4BB7F4C7806CE8A4B9B0356A410A
>     2ED54DB1D4EDE714E1E4701CBA7BCBB26A752BDD60F4E5ECA8EDFC2EEA9C6813
>     AA04F39234574E26F9A2354A3633EEC095F9FD5ADD5C5F4FD5D7761E334DDA3F
>     314DEA9A9D3E6E12448535CC6EF571F4F15402E057D94A2F8B4D5E7A3670D0D2
>     E3CBB77B3537E3F94A5D9B11C2B7148323AC9B6B3509D0313D9525A9A90937F0
>     F55718B59C5A503FE39FD0A6AD9364BDB7C15C013DFC4505E47DC83F681F7F69
>     8BFB38E48F1F24E46462C6E0A83A8571D871998730A6E9A9D2107669D9546DAB
>     7002972C6C1B370D5FA8B03300E874E109BB135024CD223CCD9CA989E0128E72
>     5CEDA7C4D3C84452263996BEAC36F5CE85DE8359EA50E91FE536C75D18210E40
>     E102D975521C82426EB6FC3A41B41154E1A7589BB67F063C7EB495ADBECFBBB1
>     B1862001EB5FAB78301307024B5C593EBFB0A47FED517F3285C306042606A3BF
>     53C1A4BDC030A96E50B3E2A2424331C3AE52ED43F508862DEFCE5BB5D0B4EA83
>     337F2CFA6EC836B655DB691A88448E8876F05ACDCC9B750E28A9B90C4281A45F
>     DFC95A18E448F2668FBC299F4F42B385F27BA3A612167246BEFAA3E8C2185B4A
>     B843B0D0EAF5E5ED1B94D2F0CD1885ECFA2E93D17DB5219C678D4E4DC5C84474
>     B1D114459E9FBB8812FC3DB78125FC7BEEE24EF8867D21FA1BF4F97C187E6ADC
>     2313880A7F9D9BB894F9E7DCC5A7DC3043F0961D1C5FE023431F4FA914DA8681
>     AC57FC1EFF9EB05EE02283E17AAA9AE06A3886E12BB56AF247BBC8323D04E815
>     0B02AE62B647837FD6032127E6B33B75F60BEBCDEC6D500B571FA05767AECE20
>     60B8CF6AC4172EF8C1FF30FAA2E1E5B70C676FF89810C283173C685843443E61
>     44F78072FD41377B8CF5DFA313BEAB3FB7EE9209F93908A61554B3CB5DD3EC19
>     E455C802C1B306CD0434B1E300A37966F11DCF0E68583303C3F184353508620D
>     1AAAD4EB4EC5958B6DABB1545E9426F4AECE912A52F68BEDB2D19C6710889B69
>     10399444CE3E301CE8857A5D014E960F4C85A417FD1615E579C7AC854E0DC5F4
>     0D7127F9BA030CB86E20D2FBD03291E100E0B119B2E4264F8EE86EE51CC7824B
>     8DF7A4CEA01CB84E9E27EA6E7A64A230823EDBE001CB69283609502B7EA0291B
>     E0125426B36F629E98E8C45CE607DCC9DE1B71777FF6D97D53AC8E0B212B5735
>     C7A17DE61F6F1B16625EB505548A77910C7A39736CEA110EA37FBEF8BD3A1919
>     C45918C137E1F247CD5A6B592163ED300F8106F4EAD34B308D392553D6F374BF
>     C0DC9084396C837D9E0A09B5FE41A8035E85A89F4978523356ADF04200B2F457
>     093738086C57E5AC4F6086D0551B45515F4D323B44FF985AA1C106521889D4C4
>     767FAAA484523FA777D343848E804FAC4B40E27310AC1FF40E18A18459D3C055
>     240C320F5F30E90605088F8151090A84FAEAC5687A0AAA3E01BA46474625704A
>     10786EFEAFFFD3FFD5340F6B4E52B02FB5F347ACEE8508EBF509F1B6F8CDD46D
>     2CD0F060A0F64F576B42A3459A2CA293E1F0133992636ED4DA5D8267622B7AFD
>     1CD64B18633F9D0BE105E67336C419184F46BDB3997165985F4A5E8F89383DC2
>     BB928BF3BE783613BB0C88147B6FF2E6FD69EC6DE60FC8DFFBEC416372AB637A
>     14C7DA7C47F4B000141FC1D4BE550F94B6C646AE061E874696796BD203AA6D69
>     03C03861A69FB7AAE8F4A6152070CEDC740888D26A6C4A22CFB168E13A986081
>     A39797A89D0D608C3E99D99D7932555F8170DD0D15B8488961864E84A6458A8C
>     592D4A144AE5A3784A0C525EFC0BE412CB059EEA8ECA09B7EEF499BC8332A245
>     3C201298438B03036C22340B7D6C8E6EC061D6F03BD7747A1DC74D11A47FD373
>     C473388ED07F4EC04A4C4522B0EA18DC4378B7A234F3042307E9F6CD9815908E
>     556F1CAB50B78CCEC0C6156FA7FBEEA8E245B31CA3C88EE088DF0490DA8E9279
>     5303198E88554A622033E54D7ED2898212456022050A8FAD58D5981A6BDE36D5
>     6EBBCAAED5A40065CFBAFE18B7489EB85002756C45004E7128D6190CFDC24BA4
>     51BDF17CED39AEDF617AA73DC08809D244170DA7091F08319B8E39FD7337676C
>     DFF2D3BBF1813172C0B27A69416934389A0E4D6A50BF588711458E54F9826F29
>     693A07146D31AC881989642ED0F2A0D053A400A6EF404A4CB4C2459EB2C51477
>     5ED8C24C6555E1081F0BB1F8F31611F840B649A389420C71AA2A556BC88E6A30
>     03958023D666B03E06F87583937653BB622CB691C4BD9CE203CC3E41F1DACF9B
>     37C957230B31F8F92930F7E4269419B34C50B3E45AFE104A385645D4CAC7D050
>     2946152DDFCD6BCFA649AF6DFF2287ED096ED99E750347369C01E01924CF92F6
>     DE217BF984E47F68BC2261788541B1818B1BD1C85342153FFA78F634E6CDE707
>     223CBB86C2B14F1BD6FFDE88C373CCCECB020F317A8E74FEF4A002FDE1DC84EA
>     A15C1E15F3C1CAC2BCAA61E6F2807BE6CAEA913322EE1405AF8B56E65170687A
>     74BD01C1B404A74540ADC9AD008EEFD88FC1F158CAD990A825F0C75103D4053B
>     D9096631D42D37C5095E615F6726973378C1FD77D91FC13B21CF38BA99301593
>     60950054C2974A08CE1A198910F2339CB8CC6DFD9B3B0132E5455F98A686331B
>     D9D88B02B811D70F65759C574D6EB8DBB1891A95DD13182FB826B8FB04FD8DC9
>     AAA96ADA5A407B60C4563C4A6AD2252D05B4D13A0713D4F0532C9E2264BBCAF7
>     E7CC84D802F273ABEF116854E9C4E0CF912594E41C043F6E5985A111FF255657
>     12CD9FD0E2103AB2F03458AF4F9269802B927B831EC496F7FF8CEF87FB6833DC
>     E54AAB631F0B81479DFA09AB8ACC30FC341A2E89F92743E618F443A824D61CE2
>     92961F3F292A9FC78B2C472FC7DFC44F0D994ECF6EFCC00C0BD774756D512AD5
>     046E27232BF5412F3B988100A639C72FA86F4C0255A4EFC15B6316E82D7D0FDE
>     B265A097F83578678D03BD1D6411468388A6D2EC54C6515C13C43D840EDCB449
>     79375A6CBAA1B566DC91F8A0E5E48DE390DB21080556BDD1359098370B020083
>     C31F08457F09CA233BBC1BE0EE090BB1D265A1BF30ABFD0F74BCAC9FD2F566F3
>     0CB8E2BBB6A10D6EC6B75080AFA29329849173202DABAB3D4FF40AF3CF5048E7
>     546262CB82DA4CCCCDA9DD78F95C2AA9F158FA6B1ECE15A57586A88CEBEF71AE
>     892541DFED6A53494D0F22D80D05D10890B0B3E895F6DD89F518057247E1344D
>     278A3A5842199AF4661E17BB73BC6B12E5F5903BE71D2FB7C9D27E0B02651EDA
>     2C405C94B875A56EDF60229F01123A5B020C785CB730479B4BC0B791DB25E7FC
>     BEEAEBD0A91BD27CE0DF99A0905CFA7A2382B4864FA6C3445F8F90305CE82891
>     90BF97387A83D914851B4DAA8A18FAA159666A3197987228398269EE0C7060D7
>     E1740635529721ABCC68AFB3C04F6A0942D4A428D113AB13FA12BB86C5F360E7
>     B07D3EDC8D2C9E07E587F3344C6DA36DF947676867E458E414A000558E478850
>     4531F90A26715ED8D2119C68F10C8901262D2317655767ECF6719486C3912E23
>     EF53258905228305DC06EBA158889DD75EA4AE128AE00233380FC65C5F4998AC
>     015836A2B4C3F4240C0689C7D4B8E410E063F0E9C01ABBDC71BDBA27E4B5EA0C
>     03B2188FF5447B3B0236F363446D76798DC1DFB2AD68BB3182A7D3124C38D69C
>     C471EEAAC4A3DBDBC4FF672805F7C566B0215724D3D768CE47A6CEFB1A07A67B
>     3ED52BE1AA16145E48EE15602E3D96CBC69E3C27B13207CBC89C7D769DF07A2D
>     FB275A50F1ACE442F0E9D4A54F63E79F903B77D4DF5F54FD5D2CA0077CE68187
>     39C2D4A7BB6D0A4F08C8C0E7B37EC12B11653227B7FCD5024DF678028F4F7F3A
>     817FF6F2701456618C5359A31557F99E9BFABF40D5C70B5445DD7B891FE319E5
>     7F78A02A1542D078F00FDA1252EFC4D276950F384F4D30FB638B53035C64C30E
>     C1D378A6ED9874E6779CC970066E8D9A04337020A995ABBBB997A75889E575AD
>     E9308CC11CC22808C0956D7BAA06BF4FD08887A22A7F03C1BC97C4F212A8B9E7
>     5375800ACD5637AD9DE783B9F0137ACBA9ACA5E19D70BAECC769BAD8E8A511F0
>     31C27342A91EB6E61F2FB0849F431C2670E43D19246F569E16AB4B4D80901A49
>     5372C07E0FB5D4FFBE98D728A0016AFE3F8B7F914A0CCE688A5C2B1A24BB574B
>     AA143956380EDCEDED9DA91F6868EC31F52003E065804776450FDA2B942C318A
>     F621AF41C4F0102EA8AA7EE0DFD6CAB4FBCDA22AED7622516BBF31B349B7EC0F
>     55F181C1EE58C568B6490714F5C3738978C5BDE7FD31F0A7EEA259A6CD2DA47D
>     F5F33B39C1095E785569272D752790165A694130935B55775737A365F6AECCED
>     A199E578984BCCFE9E77DC8F4B54E8ED11A1D85ABE41CFA17D31F47E74D3F7F8
>     7EC760D3B74C44C4ADDF322BE7C806F003A991A1AE3CB2195C36E9B6844BE0FF
>     3D1BC36576D0607BB81CEBA7DD241E7422D82A2EB1167761C4580DBA364A4121
>     2B82D50E6C1EA7B4DEFEA4CDE3812A71654FE5DA017FE216F200E0D816F24121
>     A7C15E8F12F680BD07CB25FB91DE4E3E68D1EC054F8F3E05D86E2A4FF2C700B8
>     DD692E2B5F85427411F2D26B4FB9E772CF481F046A93E864EF783075EC91243C
>     754C9B9A174D350F4E31D17CD9C97CE210945EBC36C9F583EA26831EDDAA647D
>     F13E05A04EF9D3D1ACDCA0892D6EBCEF3304194EFADAC7A203A36AFC88D8B12F
>     9A25481B7CE674C8ABF90DCD581FE204AF1CBD66FE3010FCFD3408AB22DF60D0
>     C442B0BF9F0685D5AA180CFD7E1A8C7FA514400FC3FC7E1A103E7C5A74C461F5
>     664CBC2238ECBB0E784A0670FCDE8DD8B97AD0F96A5857BAACF8E7ADF5025D48
>     C56D92A7F7A2E7D6ABC52DCBBC3EA186EEE5C0731CBA83662FBF3BB440F09943
>     A9313796859EDEE8AEE6791B465F9B6ED805F376868D6604CABDE20AF4E6227C
>     33EC37B276D84CDC7766999775DF058F3FEA680860AC70B8C2951BD9D5FE2E00
>     968E36D8C2BD6950D61AA28D565C42BC99ADA3E1606364920C3F0B9735B704FF
>     341DFD8056E0DF0422534AB8C6814DE0EFDEA0771AE2E4489D8BA80EB79ED2F6
>     1D2D3353799CAB48341EAA7291AE3282798F0D8377EE0F3711AE14480DFC7F98
>     7F36E6EBAADCDF575B83108309468B453EBD1A20BF70DA76B008E3E7ABC14AB1
>     7FDEE00964923267F81B66FCB8C24E5DF6EB327C9F41189838F3E903620547F7
>     F5A018872EDC396CDBDD66A1299E45D3F716CF99C7C882397D7F34E9B88129D1
>     8A2D65BBDBA81A0FBAC70ED3DE4F3E2BE55635B743AEC1104C3B1BB832F755B9
>     0AADA71E24685765F1218C082E1AB9D2C1B8DF860F1EC1A50D936BEB5D539721
>     9C0F4555EA3040F8FE217F5F0C1AAB1EB7830EAD9A7C113C2A75BE0E1E2CC103
>     D4616B5D1E82D9E4F718090B9E6DF30F61DCB86A70E939F412FFB40B2B61F8A5
>     ED06B09BAA4A4E072DE5ECF6065CFA1607F7CC68B66B0B81C4B8AF89240220BE
>     DC8A7764ED9A4A23BF5CA8610EBEE81F32930F319D08DA38CEC48872968BC5AF
>     B0CD83F90947D75AFCA9EE42398DD432EED1C4E20D7C7E402ACEAA58C839D74C
>     0E38A1AC04FE83FC354F0C507ECDD1BEF0090FA2273CE7B0B596D50EF9C01390
>     F681E0DC5CF92040DEC16476A5EF1BAD5BD554E69A03195FFB37323B2DAF93B9
>     3D6D5D55ABB65205DE81516C776D444A4406116C3E101CEA14FD136DE1C47936
>     544BCFAF815E48243BE9236D131502D9E5ED2EC882D15B545C182E5F623EE1CD
>     4F1015D304BB3A5C99925FFC88825FE9823D53BF2DF89CA1E8FD9EDF2FABD112
>     497396E20A3A4E631A2E1C052C333CB00E3FA90E4F1A28FC662ABA7D9BEAB72F
>     E67B1F176439FAA86318E933B0CBF5299DB6E50EF59AD3E5FECAA87F921C1F85
>     F6F62D1EB7BFD46DCB71544D5344BFE86E0EDF7777ED94459B58E4C5F5F5EDCA
>     39132C98E9E856F37A66926A85AE43CD972CDD43E9E6F54172E1676F8B1DA216
>     7E003FAF0F660F87C47A3DAA58F7AF131C4608C59C3A73F1414F21E13DDF72D0
>     D12D36F64603663073E3D44867C7D92BECD56BEEECD00ABCE68E8EF4F3A84133
>     AA32C14407AA5BAF1819F1F54855B3BC0506DA285A32C16F0E9DB72CD423D51C
>     2D192ACAC3655F8ED831C82172EA5860F0730A5EB1B1A85882A02F20E658D5B2
>     AA5654AF4C9F3E67924775D354CD3BD5357BDA2F600DAB9F808CAC988C34CB79
>     F396F17943A7D99D4949F4C97E702CCDCC1C28164BDF79FCAD0997D1F7B8BAEF
>     A85D5B770F06DE67F8EDCEDE66A368CF3ECF0E3157CE46D95803E089D7AC59DD
>     A5261CCBB6A7455A28F4A1E3116DFD026F0873DBF9D7F6CA935D8BC8C8FD9D6D
>     04C104CCA3F5E933B7A91ADFE39D2734B1E3A70868596DC187DB76624A1886DB
>     E7C64F1649CB0EE6E09D20F5D1F382CD749ABBBB4F3009A6B9ED7119C8DF7913
>     6CEE157D8CA96A2AD8842B40F6D70428C98A32BF251C7B169CC26BCF763E7D59
>     701CF2450AB23D5238D5C018331EC2AADDAB43076744200F0F9B4E1DE60E4ED5
>     D87A5918DBC06333FD622C6A7977CDCF84CE5B12F734E1F59C26A78281F7630C
>     DC2719B83FC4C0FD3106EE4F66E0F135CB00D5FD0803F7A30CDC3F8D81FB5319
>     B81FB259BC1ADA3F8F81FB218FC490ED2AE14762E014560F8F9592964EE55AFC
>     6B58D7ECFC8FB88F32DF3902E658C4837CCBF5D40294FA43B1A645161B5540C7
>     AE6B005ADED9CBFAF063088A70E39565936AFF3305B8C44F8A6F5096D1C76429
>     82C9331E194AA7D562961C58EDC7143E831CBE093662AE36C8602AFF663A2527
>     1C26B26364313DFB5A71C7467BF6A4B62FB86D15371E10C8D3E7FA24FA88A8C3
>     C7254F72C88CC123EC3CA842031F192EFEA153B4FDD59C6A38EA1FBEC5CB5629
>     EB30BAAED9ADF6D9BB87BB4AF923B1FF50E8C7AB6F9AFCD1E7840DB7062C37AB
>     564483BFDDD6BBCE5E348D773FF364115A188DFCF262B44B52B3D95E31798EE4
>     567DA73391C1EF2FAB94D7537249652E0544C4E1D61ECA30E4CCBE636958EEF5
>     D83E343FAC4FB421CDBD90F75D0E639BEE8BDD1D3B009ABA03133FFDF8652307
>     EE21F1D7460EABA49F377CC9E34F7C9410BC68F6A9870331218203238CAEEEE4
>     1E251E46B7737249EACBB58037781032EA8CCFCE6FBCBB6F3977A6BE90E3311B
>     40AF3DC1C28B3F6927D83A5FEA2BDEE91C28028677F365F010C3A7748FE67C01
>     33E150796EC187C27D23DB2E6BF36D9BB5BA29FCEA41026D83DB4617652E963F
>     C2DB45EF9B7C2F38C7DF46DAE885DB4E831F7FFB685B941FC45A89BC83F4CB37
>     97F49FD8C2175C46FAC59B67F3D5F3B877701969F492F9016CCE40F20C31CE1F
>     8233A74FC902FD46AFED3E11BE73BBD9953A3857F47774418739DC0DDF9232A5
>     ED48AAAA79BEC79136A3B74FEA81284486226C96D388409FCF40CB9F1B1FF61C
>     E78D93E8D2A204AAA7EA3FE3702156A7438273F2BF8675E2DB9000CA0810EC47
>     00E1C4BAA9C6636E48D6359C811857733416861B945F549D0CB887FB117A926A
>     E2F7338BC8082DACF3D9AA8CF5F9B93969D53C84665B3528BF0FCAF32F732A9C
>     2D2FC4C13D46927292EFFC9C8FFA9B0C8408C9776E6E6611EF783C7729DA2214
>     77469AC58892A730EC0F76A03FD081FE651D0871466C0EE8E21CE3188CE5FB04
>     0B0C683456627FA8046E541B9D5A4899B45B4342B1A43D082C953681838FE2F3
>     1B073E630E25058B45EF4862E9686EB3A3DA378996DF40C30426DCDFCC7871B5
>     01D514C6E3AF515B77B87669F6BFBB9CFA6C906561B6975A5D42F7B611287FF3
>     DA68D7FD0168A2B4806D36AD3AE8E6B719863ADFD526CDDEECD298D3968ACF60
>     2C66DF444AD2719D9124DCEF47E56D16508DEB230B0A1C25B9311E5D3C559F04
>     5B6F6515D763DF0989520E7F58D1373FCDA8CF4DF21E7522D8240242456E35BD
>     496C048907728011DC4E0CC70AB61BEE4DE8CD4FA5FE2AB4ED3C7C2578F84862
>     8BC7C221552A60FC42FB3E6561CC521315B70B4AAEB81F7B3350DC01A00976C8
>     75C62431700DDB03037A2AA3423468A7BAA92E5F6D24C54594BF6F568E6BF902
>     01ABC358589D0E9B98EB056C576C89A9D4AD12DAFE20B4FD516847CDD0E4D821
>     E0D348ED8FDBA8C93E009600C11E961D1DFD729C8E6E178D54B861CACAAA7BAE
>     7819E0B3D01EC1F44AE00CD3525830DC05DC2638404C91B4DA34159330F23E80
>     013F8FC2E8837EF4613FFAD3FAD107FDE8C37EF4A7F563C13EB7A5943FBA02E1
>     F85FF161B13CBDB18DF389C6465CF93C188B7D357147DE48EAEABEF3268DD670
>     DA6A43CB816DD159D5837319FE7A4CEDCA06EFB8493EBB86D2EC518A6952E726
>     C3522B6D8A76E9FA82C0F0C150F7C3171B3502F08325B7762986861B521D6268
>     77AA836994D2E1FAF0D4BBE1F373F3D31C9E1C10D1EB55DE9FE874ABD9AE3868
>     C73C9EB214B94E792591EA96C093A301B6C166CA636B68612DB010E6392E2D0E
>     C66B0D0C42C5EF4F07EA162D0D648F17CB4C440BDA14CCDA591A02B411C661D8
>     8716C277D13022732B4DD6C9BFB0679471F7C2E248A7B8CA563F8A2AA303C212
>     B6A81CD0113FD63A8A0921314E5F4A7CACA3967204BCA395AAE9FD91945B5C8C
>     F5C59BCDE44B63D512EFF607DE1D74D10F7AE7CE26A4DFB18E4DB6385EAF3F50
>     4FE8DCC45B67F712EF9CD24DD5331A35F14A68943415ED3BB34CC00BD4B817D8
>     AE40DFE3325D53EDEE1F5CB414A3BE112CABFB12CD582D4BFBBE113EB644AD2C
>     340CACED78996E5BD11159EBAA2CAB478C4A17712EC4C8540A3F2045726A15D5
>     382D3AF3DB46D7B8726ED622298A0DD3245A46C7845017D17E125CAFBBCDE90F
>     1695A6195C93C2549F5D97EAB74D78C00A8508B13399281D0B9582061BB5C285
>     9EEF7EF58B7FFEB5A88FF47BE411EC3907A3B5012453DF152ED63649033A7C85
>     E5CFE137676C20D967B633572BAD6BB5C0442E5A04104B10C3ADC2D43C823D14
>     91743EA54D0A21A8302DEEBB265FF2711972D77A70759BEC3E1D4286693AEF3C
>     CCE15A28F78862B034DACFD41937CA87C8982624AA373B78BBD0AE69EECB84D2
>     EEA7678706C658E3B316A4DC48DEA0C074B409FEF91BCDCDC6F76AD7B8950D5E
>     D2A1B381D9D2D0B85EDCD630330786E0D3BBE8141919699E2A71DC8C88321F48
>     82960047CFBB247C3E51D039F62A64FAC901555F8699C7F106996A35D1EBB536
>     9C8BE7B934FCD62F34E3111833D30FE2761FAF0A3944B4B4ADD8A7A4B62C1BE2
>     204895B7F61E11780D92CEEDA3AA894F3AAAADB059199132E46F69B67B8367C1
>     319832662FCF2A5DBBE0BCABB99F893352A39A839111AA9271B00857E16BC9FB
>     6B73C1F5638E6A91051CD59D55E3D682E197AD51056223C55B65AA1871D9B562
>     29C3E4B1D1E125F38416F9FD365F94B4E3C574B5DA6C803AED59423190987698
>     6D06FA86D77E3959CB29775A8AA56944B34BABEBB7CE90D035DEC64E97F91E2C
>     09F2022EFDFA83A8702889BB2CDE9A84313E1F81A6CF3481C27B6B0A770C7678
>     57E6DA141CE8D5038B92A6BB350CA12F3679A7C1B75802A1CD693D0C6E509A77
>     11E1DD356002F0686122E0C30DB9D974DADC0207FAE3CB37E072F6183602C6D2
>     974A7D4FA90EB4903F046986B329567864508982FFA5ADDD151B9380E73732B9
>     D6DBA877787C0D6D69401A59D6A2815C26D0323C9676224FC1C4136D3335F912
>     D363CC7198546B3A1D6E050E6085E9A8F695BA1E9C52101F72E429E5D56BD514
>     F705A660583853E6838908B5C0AC907EC57D1AACAC26181E4895558B3FE2A1AE
>     B6CF8133313C9872D9E8BC33A7743247436DD46840DA479C2DBA84895850F163
>     2A2562FE64BB8577109530A8B8EEAFA357B8EB57EEDF090019959BCE8F22499E
>     4FD8B425926413D1624FA6275CFE66EF4A6774BFE252F40FE58A6CA0F5227337
>     A19F7C91903A93FE1752AED4401E0FCEBB41BC7D2771EBB9C853F15152791749
>     CEFBF4CF0CEDACE26981662B4DC93945B08D9042F789E27CE61F2DB1DECBF20D
>     EE3612A8C29F6DB49F911472C9474AE1A05B7FCAD26E410D8CE6B36C9B8C7B80
>     131DC21F4E20B69AF75702F3304E0D1C2E556C4075545D5E66D41F6FF4F0A561
>     454C0532954CDC14277DFC529E5E2D72666C57664EA5D0CFA4D7CC7899B37DCB
>     F49F7679F9CE55335872434B24DAC5A6F03B8228BC67322F6890B7389BA0156D
>     DAB515704EC8D2412FA91D8F2599A4811FB9A1CF9235EEA7AC2F7E247710C6DF
>     1C216703CFD4CC06860B61F6742366EAF40E43C71BE75C2C2864F92556F6B7C2
>     ADA2DD47A35992714374DCF189EDC803F2718FD36D0A2F82516781D204A2A083
>     92621BC3CC76BA17B2267EC2C93D63D2B06982FFACB08564BD32D09921E2E808
>     3D36B3B34499544AA968C90AC4A9DC7B881D044A462891BCB5E04AEA994C7D39
>     55EE92B1D89CC42AE339AD401303FF2281A6C3437180D3572944837ADE50AE4F
>     807EF006138C264CBA7DADDF193632A3C27B7A79E68FA9AD9BEA83D3E7617DAB
>     DCD9EDC3DDD9D2004E68A78971CAAC3D90783B70136724D3B113E74572AAB8ED
>     09E92CDBA9E921352BE5595AA18B31B32351463324DA654372452292CA467FD2
>     20F8DE7176BE8CB29A42054C703E45FC126E92F1195CF36C3ED55BEFD0BCBA7B
>     F55FAB2C8BF4F3A50000
>     }
>     view quick-plot [
>         400x400
>         line [1 2 4 8 16 32 64 128 256]
>     ]
>     
> 
> A **complete tutorial** about all of q-plot's features is available by downloading and running the "ez-plot" tutorial from rebol.org:
>     
>     
>     write %ez-plot.r read http://www.rebol.org/library/scripts/ez-plot.r
>     do %ez-plot.r
>     

### 7.3 Drawing Charts Using Raw GUI Code

> It should be noted that creating bar charts using native REBOL GUI elements is as simple as drawing box widgets, each sized to the numerical value of items in a list:
>     
>     
>     REBOL [title: "Simplest Bar Chart Maker"]
>     data: [12 3 9 38 1 23 18]
>     gui: copy [backdrop white]
>     foreach val data [append gui compose [box blue (as-pair (val * 10) 40)]]
>     view layout gui
>     
> 
> The code below adds a number of features such as text labels, randomly colored bars, and a 3D look using buttons instead of box widgets:
>     
>     
>     REBOL [title: "Simple Bar Chart Maker"]
>     data: [12 3 9 38 1 23 18]
>     labels: [Jan Feb Mar Apr May Jun Jul]
>     gui: copy [backdrop white across]
>     repeat i length? data [
>         append gui compose [
>             text bold 30 (form labels/:i)
>             button random white (as-pair (data/:i * 12) 40) (mold data/:i)
>             return
>         ]
>     ]
>     view layout gui
>     
> 
> This example adds variables for auto scaling and sizing, a gradient and colored grid background pattern, and vertical bar layout:
>     
>     
>     REBOL [title: "Simple Bar Chart Maker"]
>     
>     data: [12 3 9 38 1 23 18]
>     labels: ["Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul"]
>     height: 11
>     width: 50
>     
>     gui: copy [
>         backdrop effect [
>             gradient 1x1 180.255.255 255.255.100 grid 10x10 220.220.189
>         ]
>         across
>     ]
>     foreach val reverse data [
>         append gui compose [
>             button random white (as-pair width (val * height))
>         ]
>     ]
>     chart: to-image layout gui
>     gui2: [
>         backdrop white
>         style txt text bold (width)
>         tabs 20
>         across image (chart) effect [rotate 180] return tab
>     ] 
>     foreach label labels [append gui2 compose [txt (label)]] 
>     view center-face layout gui2
>     

### 7.4 Creating 3D Graphs With r3D

> A tutorial about the 3D library "r3D" by Andrew Hoadley is covered at http://re-bol.com/rebol.html#section-9.6. A nice business use example of r3D is available by running this code:
>     
>     
>     do http://www.rebol.net/demos/BF02D682713522AA/histogram.r
>     
> 
> The following example demonstrates how to edit code in histogram.r to create 3D graphs using a block of your own revelent data. This can provide a nice flourish for displaying data graphs in presentation settings. You can use the "asdfghqwerty" keys to adjust the camera position of the 3d view. Simply load your data into the "graph-data" block:
>     
>     
>     REBOL [title: "3D Graph"]
>     
>     ; Here is where you put your block of data to be graphed.
>     ; The first column contains labels for each value.
>     ; The second column contains the actual values to be graphed.
>     
>     graph-data: [
>         ["Jan"  11.0]
>         ["Feb"  22.0]
>         ["Mar"  25.0]
>         ["Apr"  55.0]
>         ["May"  35.0]
>         ["Jun"  75.0]
>         ["Jul"  20.0]
>         ["Aug"  33.0]
>         ["Sep"  21.0]
>         ["Oct"  55.0]
>         ["Nov"  65.0]
>         ["Dec"  45.0]
>     ]
>     
>     ; This compressed code is the r3D module.  You never need to touch it:
>     
>     do to-string decompress 64#{
>     eJzFWluP2zYWft5/weYl9gSOTUm2x0a2i23aAQq0m0VTZMcWhEAjcTJqdKskq2P/
>     +j28UxSVmXR3sQHGEs/147lQpJRffvju3U9h1PjpIktJ2WXdeY9C/HqFVtbfV9CY
>     uZo0bU2SLuvJHt2fyiRMw5QkWRHn30RR2JD0lJBne3LJLFHKvDF3XROXbR530tmt
>     dnbQt8cnINwOABwG7o6jaTLHbRLnX+/0djSjw4hydM2aO22qDqZ6O3YbhW1WUga9
>     wHSSSoz5DVC+EHghPFsw7du5pLOR5D4F6iBAHWxQBwHqICwdFKiDBCUYyukwAfJe
>     4DvMNeZx8CxUR4HqaKM6ClRHYemoUB2HqI7C7XEQFqX27N5goO7jhCzSrKH9UZUC
>     2/fvbsK7vEo+fxOdanm3hEuco8f4MWvRmf1e6G8UssseUXNl1cCUspYgsMFlbQYd
>     JU3VtnVTwaw6dKpRCsLnZwkrszImbLDEXB2uF3Gls+Q8T/A8wfMMni94vuD505Gq
>     Ibw0Rovq7jeIlggVH3yUTBksOf7YVR/zqvr8Me4mIwpTimjI+dzfn+5gBYGZOkwg
>     yxv6DyNPww7R/y9H3gIJlKk82JLeZFZsSd+doyJ4LAKRmQLLOKPCs0LekPaUd3QN
>     pFfaaPU5jO6rhsTJQxijO5SgFPRwGNc1KVOhIGc+i9EVGF3i+avZHb9dw23Cb3dw
>     mwoBfy5lPS270bJ4ZQgHStjXwltDGBvCayUcaOFrQ9gzhDdziA+fswhT78swqSj1
>     E0HqSFHDvYzSUzGTIRNqg5j1KmQ9C0jC7mC2oBllZb/4Yy/kZ/y5KozAHF2JUGwM
>     dpg6+qKY9zwxf0KMQmpId2pKZAdzETdNfBYh7UnTZQlpZTyLwBlZROXI40QVCi5S
>     xpyVqACgIpD2ojHGpCqgdchCN0fcNdkjNHo3kfSkCBY5gQcC/HzqHv6GtAbK7pFg
>     o7+iVSjdGTu3QZEYqpCogTIOh1hh7oybIU9JYRUf1eGozpLPJiKuIyc8mj7bklkB
>     eGJFEPEtAHGxXMPfDv4whBmKqFhu6GBFfwL4odQtHVBZTIUp9ZoOqDDe8MUJSgp2
>     ok9iQHWcNS3kk5YgbaCUAC5GNGHRkqe2uZcr6RlQjeiBQV8jrRuwaY3EfU02pQ2y
>     adCPFFIFbzZjcJdcky53fByw8VaN12x8PZ8vpIZnafiWxkZqDBXWSmBrKQiYpg9s
>     qVxbKjvbh+9U0CBFhEwfgROWoeLZTjaWxs6tsTWcrC0VMdcRsK0dLs+Kr2/FNxhF
>     y7Ny6Fs5DLQLUS5WtHxrYsEo6dgKlm/Py/ARODU8O1imE98Jy7NjZThZWxoCxkjF
>     N7xsLJ2dGxioRHZHc4DXbPW4EiuKZ9E2irZFUoO1riW3VjQtp2naytpsXvGA0QuP
>     s5txYJUCXlu1ALuNUW4Dq+IMpY1SsnR8K714VOkDT9jWura1diNP/oROYOd44CmY
>     wBfYaTZdbWyl3ZTSetTieNQLDoTr0bSwHWNdh8LVauzKqFUpY+Uba0c7t87Ojic2
>     /GxtcHJKNrqd9rO1ochY2evSziwIbMv4bnQrY/HCNrq1pSPRmqHbTcGzMwDwInic
>     72eiFWWrsRVDNKWieYzmD2g+owUDWjCnJuWLKNIh937yUas495KzR7AK6vPI2NCZ
>     OydzR5VWnTgXyj2vPm31T522hL8esyD0/BwFI4+PPD7y+cifR/ZR9E+7DA0vPqRP
>     e/HmxgBzFpaCxsDjLE8KOjabfMMsMT4LF2p/P8UNWTRV1c1mPXfGo8Jd8ZhwfOzh
>     QR39PU2Fl1h6ubPcZXCkmT7scjZWW/wYuc+7M7bdjpk4LWg6uuMjx/zlC4z/A7bF
>     U9h+hpuszs82tlK/jPvfobtCpQPS91kPp6avAoTSrLdBwbGKncZer8J/NlnZoRfc
>     MLo7owtpKhR39HjbkfSFPMPGEdiR60aJ/vy0KJzxxNSrpCdagZ0ydeOgHpGseyDN
>     TJwv53KmofHKJxq1Nu2aJUVOu0Xd+fzOdSauaZgch7EodLzTYMKKEPFhZNhR71P6
>     kR1Ecohqz22wgdL/BUJLGqH5R9XkqdRO4oI0qhxg4fuNv6HV/LKP2/fZhbCjoX2G
>     ZOs2fR/A7zzY1lUpyfkvcwSMLC4/5aS1S0kxJIFj+ZEfX3mu9FkWcS6SkwUuf1mH
>     +HyYR6b0jpHpgVqB2Gtx/jowqfKqMaV99DOVfsucmK8ABqC4yX+JecGEP8DUlbR8
>     PcOlJACJO07oTDnLY8Mfy/uKK7+N8+REv+XcAPkfrKBb7YDrygiP3ekk6PzJXbYK
>     MtPideClv0rqos2KOicqe9yTBId09lXQzLS1VdMtG8JDoz3JFEmKZoX3WZ5TMycI
>     vqTC1sf5zukl0GZaAZ5J+DXsfSK3MBVcAANpDUvypcIzpCsc3hTDn2IEjn535XLi
>     hR2LtvvlTErq7qGnZdBj2AKg3kd9V9SY/cIwqVEeN59IO3psKE17Y0a98QTDlmbP
>     321JRIy+pJ6cDOrfyRCoeE228pMCxSuQ2hyfMZN6P37xb83P/lBAp8zTsKzK/Kxe
>     bupI7NECr+AfLN3wmGL7rG8lL1QylE4fY3TL5eR7gu9P8IEuK0tnSSZDvi+1ssiX
>     8HH7vWftJ8qDNSFkqyDphy9VimzPyTUaevUt7dWwO4H10ZpNn8+yFXpeFhkAe0RV
>     k33KSiibU8kXnYtdXFxiPzMWhit4Tq7n94NiFwChoIxqpNSMUj3uAbYEyFGb9Jdn
>     XVScYVpAk0aFgM4CZwvrfPCKegELRw6AW4bMQoYZGb1Bq9AMiZyq8XlBRUt6Urh5
>     3KihsBdoHFkUYi6LYqMjIv8Kxe2C5pBuy9l2nCX7ApXN8wESq9fYZWkmkw4JYaJz
>     R7OYCoMvNT9Vcbp4d3Mjvzbe36dxF09/TmjFk6I8FR/YEG5uJOWHFFqBifG8Aonp
>     QFC6h6xlNNEvqIDjIjwwL3RNjcK/QFaEb5j/m2/RS8AkNjQvvqNgUAYuqg7FJQIW
>     XezJC74GwzZHotkrIx51Lh69kuZTGqEYNU0eOmXye25GLKBcnw/UOsA+iEMt5WrE
>     srxHa7BVk5gHSkUoNNPBQyhfyYFOVy3ERpzveQUubnJenJ+QoFU+Ly5PS0FBCZSS
>     wtY6yIJjpSseGe/s5J0Z7+LkXYTNNypAoY6UsurmSrtu7iUSsZWFxdcMWWE3VfMr
>     VBitRNGNwwAIZai1mcyLoQJN5s0HeeJFLg/1GMI1EftpHvh6lgRkxk4N1XDAjOwT
>     ie7HmWyrhYoemE1Od7CDZvvjMGT/D0b8V42IDRZqtHAMB6Liz9DDQz080GPfy8Ej
>     tMQGdNAGeVHowWVLL1uovdCHyzW9XKMgCgO4rOlljXAUXgNvQy8bSsTIowoY+SAZ
>     Rf8G28Udt8glAAA=
>     }
>     
>     ; This compressed code is some initial preparation to enable plotting.
>     ; You never need to touch it either:
>     
>     do decompress #{
>     789CED564B6F9B4010BEF7574C4F6912110763471187F6901E7388A2283D581C
>     D6B0B669318B96C5C1F9F59D7DC00EC458E9BDC896601EDFCC7C33B3000090B2
>     3D97EC45B2B26E6308A2DB9BDB2F30941F8DFC84E23D867039943F0AF187298D
>     343FA540A853620DD407C8F2BA2AD8F191AD791183920DA7E25756349C885351
>     8846F2CC98D7560146F3266491C568501D619518D196ABE0C138C4B069CA1456
>     D6D4E033C58283468755C6D37CCF8AAF49AF9D152265056468606409AC7A5DBE
>     A1CEDFE10E2B4164C955234B98234391FE4132E9B11C7A20154BFDFBB44768CC
>     6F90C3332E8BA18B0D323FEB120D5C969FF0980F3C4CDD37E1D94AC281073E8C
>     CA208AC80E88D53515C2F0AE8FB41FA73A6FAE5A31696673D10F9BB97899A174
>     242C9BBD491167AAE0E556ED7EC056B26A17E8ECBD599B36B216384F169C286A
>     C5AB18BE1974089C1E2E61064A046EC27C14EFB866B2C659E3DAD780C01556BF
>     44887B64EAD21B6E84E42CDD6100258F2439478537D497E73CB60EB3F947230C
>     1DEC45C60BC7A08CB260BF68F70B73A7F4CE17487A57B46E8AF96BADC9B94FDE
>     DF90665F414419EE228AF56F9E2A8CC6B326C5ED83B459739BC72823B2C01437
>     1962B2AA42CEED1478501F696CDFB7B02BEBDAF1EECD88873DB72C3795A87395
>     8BB203065283313394B5F4E1481FDEC7A94C5F236077CEBAA7C21EAE83A77FC0
>     5EF58D0CF19F90BA9FA4D0856189B14942D7CC655D69D9819BB38D34F41969E7
>     F245E6ACDC167A71A411B84ED8E408A4DEB836BA230079797820F4E22306C351
>     5838676F69E8A3035A79587473B108F2064AA1466F0B2CDCCD8A1C668E8A0B94
>     C3DB2EC7694F289393FB3EBD8DA32D2B74EC1DCFB73B455FB824D3874F66D9CF
>     844996EC46B7E0C9680610FB2779BBD233B3E395B7EA976ED7931B6DB29674EB
>     491127E6AC4E25E72542F41D3A44B665268099876E77269C51DDE2D702BE6DDA
>     F0FE165792D541C572E9D5B390DCCFE1038E23ED798A34B8D0B9D0708EB7104E
>     9434ECDADDB86B533CBFDA0F8AFF3C0F78C61760AD645E6EFDAB283943E7D401
>     7DF27CB64BA2BA3CC817C387E3A9FB40F80B7F5D1FA3080B0000
>     }
>     
>     ; The user definable GUI layout goes here.  If you want to use other
>     ; key controls, or widgets such as sliders to control the view angle
>     ; and size of the 3D view, put that code here.  The "cameraTrans_" and
>     ; "cameraLookat_" variables make all the adjustments: 
>     
>     out: layout [
>         origin 1x5
>         at 0x0 scrn: box 400x360 black effect [draw RenderTriangles]
>         across
>         text "" #"a" [cameraTransx: (cameraTransx + 10) update show scrn]
>         text "" #"s" [cameraTransx: (cameraTransx - 10) update show scrn]
>         text "" #"d" [cameraTransy: (cameraTransy + 10) update show scrn]
>         text "" #"f" [cameraTransy: (cameraTransy - 10) update show scrn]
>         text "" #"g" [cameraTransz: (cameraTransz + 10) update show scrn]
>         text "" #"h" [cameraTransz: (cameraTransz - 10) update show scrn]
>         text "" #"q" [cameraLookatx: (cameraLookatx + 10) update show scrn]
>         text "" #"w" [cameraLookatx: (cameraLookatx - 10) update show scrn]
>         text "" #"e" [cameraLookaty: (cameraLookaty + 10) update show scrn]
>         text "" #"r" [cameraLookaty: (cameraLookaty - 10) update show scrn]
>         text "" #"t" [cameraLookatz: (cameraLookatz + 10) update show scrn]
>         text "" #"y" [cameraLookatz: (cameraLookatz - 10) update show scrn]
>     ]
>     
>     ; Try changing the variables below to affect whether the lables and values
>     ; are shown at the bottom of each 3D bar in the graph, and whether or not
>     ; the data is shown in color or black and white:
>     
>     DisplayLabel: true
>     DisplayValue: true
>     ColouredLabels: false
>     
>     ; The following 2 lines update and show the display.  Don't change them:
>     
>     update 
>     view out
>     

### 7.5 Using the Google Chart API

> Google.com provides a powerful and nice looking chart generator which is freely accessible by anyone, at http://https://developers.google.com/chart/. The syntax for preparing chart data and displaying results is dramatically simplified using the REBOL script at http://reb4.me/r/google-charts.r/, by Chris Ross Gill. To use it, just include the line "do http://reb4.me/r/google-charts.r" in your script, or paste the following code:
>     
>     
>     REBOL[title: "Google Chart API"]
>     #{
>     789C8D56EB6FDB3610FF2CFD1517015BBAAEB6E2B4EB5A0D4390BED26ED99A65
>     6DF710848092684B0D256A2495D85DF7BFEFEE28594ED002FD6253C77BFCEECD
>     F3E74F5E9F421A066F6AA76402D189D62B25E169258C83E3B3575118BC93C6D6
>     BA4DE060BE982FC2E0B8779536C8FBB432B575BAABA481736DEDECA4560A055E
>     EA065555CE75491C1BBA58E1C5BCD04DDC89958CBD8D0BB6612F445B5E9C138C
>     3078261C0A3E9E1DF7ABD9E1C1C1A33078BEEE3432259016C49D85C18B9A707E
>     B5621D33A6DAB90983B3DE74DAE2D5BF27B29506355910F0F6FC149C065114D2
>     5A7095845D072D79F85F189CD6B91166935020825379255502FBB95CD52D6A42
>     D299126EA94D8354A11412DE6C3AB4942EFBB670181A6874D9A352A7B582B216
>     4A16043578A61B5163E0D281663928A0CA02AE654E1CA775215B42BD5F14B37C
>     33B3220CB2300B43762C81DE4A0265B476E0D0A8851FC04AE7EA7665C3A0111D
>     7158902D62D61D5E16DA481871210BC19ED9BAE9101E9F0BADB4F14785D99B4E
>     D61F4BE104EA21635049D561F2C36C80B04D2AA39B8BAEB6739F084E2E538FC2
>     3060A43E9AAA6E2544AA88804EF17A831FEB4D04B613E672B8B45833412E0C44
>     F9958D004F311658FD41B74E282456CCD0D5C8DBDD8F000FF11233825F44A720
>     442EA2B88501452361FF21ED8CC6D4A7B9D2C5E55E861665B1FD228F02664830
>     64AD936B07FC89642F2DCCCA8EECA0F3F7983E1443E686CA2CD6ADDAB0830131
>     26D0884B097758C5374024BA2A35E4755BC21DB2BD25671E2AE21E915A696ACC
>     622ADACD6C842B7C65316DCCE780DBB313F06E13975276E02978755D617B40DA
>     52B9885A1D0D372C36C955A2C536ECA8C507D38335FF152F60E171069514E556
>     3BA11E2A6D447E85096288947282276B47E360EBC911300BFE64A991655F48FF
>     9191B29DE21C4ADDE9D9C3053A560E98F984A3E6F8C9D367CF5F9CBC7CF5D3CF
>     A7BFFCFAFAECB7F3DFDFBC7DF7C79F7FFD2DF2A294CB5555BFBF544DABBB7F8C
>     75FDD5F57AF3E1607178FFC1770FBF7FF438425B01ABBE81BBED9B5C9A3D6875
>     2B87D006F5923F07D846BADEB4105D44148C006994E93534750B0B6639207A57
>     17971E3452BF05A37B4C3AFA7197583892DBB24A0BE18A2A036EB3A936252643
>     386CCC1BC124DD46BED7688DAA9C6512F6632AA3A9A947DF7C87A7AEC7B0A2EE
>     186D2050DD3B5688FFBE7220A2EE31B293D84AE48A92EDCA554730C8736D779D
>     44575006BB127DE41F2A2C1C75B34AAE3D6F9C8C6E62BFEB6B690A81B944A11D
>     8434614680ECF5279DA709B207D6199C6F43008C6CF495849D3078F16D1E7D98
>     F876D264AF6B0C3336C752F4CA8FCEA3F85A9BD2E795248252167523D41EA699
>     1216E3B0E08CCE179CECC00710A7FC3436C91CDF71C9403AF3AC1E4270CBE864
>     2918421AE5AB28031E93F851E019D7099E842F2FD4A0555D22C1E2D5CA88B296
>     2D712A12A3A8D0024869607AFE2C1D0165B70A8207FA186F9AAE5F1872DC2454
>     C7D36ADB23CD313A5681EDF3CFCA85C117248BCF9F4CD760D533EFDAB9E51675
>     C0E8D5CD0E9AAA9CE31EF344F76B221ED65FAC442E7DB9F4ADA2F7001AC142F5
>     4AA761EA155B7CC4C0A09D217BB67186D15736B636D7BB1FB1DE54CAFE453689
>     76F72B2B8EEE4590EC0C3E4E1FE34C27561FF05BFCBCAE239F7A766547827971
>     6E471FFD3DBB3FA0703750ECAAFE7853F5BD41D6F4F273603E29914DBB97A370
>     254DCE4FB1A550145F99F7AB64B761872531F0F1A6CE253797DF0D7E4CDD4DFC
>     88924DBD1D1DFBB843615826E368BA8B2DF17544DB15A21FBDAB30AA71FE594B
>     ED4A8BB3FE801FF70F0FD6870F68703B7EC6EDD333241C7337A00EC784A75938
>     F46FE2A71DB615471FFF8591C881EF153B9AF04B4B497CCC10B2013DB6BCA395
>     489B9EDE81C3538EDF580C974ED9C46C81904EDF250C111BCB6BDB0C636D7339
>     EE9039FF638D5279C63C6938BD141248475C0886089C7986E867D50D8FB391BB
>     D03B8FC4A115C6B727B34EC569B726D424E35B702BE219BD690CE55662B96385
>     2E9883C2BCE5C8AB1D16BA19EAD00F167E2E73D9414B81F0A9C077F5FFE11722
>     94EF0C0000
>     }
>     
> 
> That code enables a simple REBOL dialect to create and display charts:
>     
>     
>     REBOL [title: "Google Chart Introduction"]
>     do http://reb4.me/r/google-charts.r
>     probe chart [
>         title: "Chart Example"
>         type: 'line
>         size: 350x150
>         labels: ["Red" "Green" "Blue"]
>         data: [50 40 10]
>         colors: reduce [red green blue]
>         area: [color solid 244.244.240]
>     ]
>     halt
>     
> 
> The block of chart properties is easy to understand. Edit it to include your ownd data values, title, chart type, size, labels, colors, etc. To create the chart above using the native Google API, you'd need to learn how write the following code (paste this into any web browser, all as 1 line, and you'll see the chart appear):
>     
>     
>     http://chart.apis.google.com/chart?cht=p3&chs=350x150&
>     chd=t:50,40,10&chtt=Chart%20Example&chco=ff0000,00ff00,
>     0000ff&chl=Red|Green|Blue&chf=bg,s,f4f4f0
>     
> 
> You can view the results of the REBOL "chart" function using the "browse" function:
>     
>     
>     REBOL [title: "Google Chart Introduction"]
>     do http://reb4.me/r/google-charts.r
>     browse chart [
>         title: "Chart Example"
>         type: 'pie
>         size: 350x150
>         labels: ["Red" "Green" "Blue"]
>         data: [50 40 10]
>         colors: reduce [red green blue]
>         area: [color solid 244.244.240]
>     ]
>     
> 
> Or view it directly in a GUI by loading the results into an "image" widget:
>     
>     
>     REBOL [title: "Google Chart Introduction"]
>     do http://reb4.me/r/google-charts.r
>     my-chart: chart [
>         title: "Chart Example"
>         type: 'line
>         size: 350x150
>         labels: ["Red" "Green" "Blue"]
>         data: [50 40 10]
>         colors: reduce [red green blue]
>         area: [color solid 244.244.240]
>     ]
>     view layout [image load my-chart]
>     
> 
> Changing the properties is easy:
>     
>     
>     REBOL [title: "Another Google Chart"]
>     do http://reb4.me/r/google-charts.r
>     my-chart: chart [
>         title: "Chart 2"
>         type: 'pie
>         size: 500x400
>         labels: ["John" "Paul" "Sue"]
>         data: [35 55 10]
>         colors: reduce [orange purple pink]
>         area: [color solid 225.225.245]
>     ]
>     view layout [image load my-chart]
>     
> 
> You can include REBOL code directly in the chart block to perform calculations, format data, etc:
>     
>     
>     REBOL [title: "Example by Chris Ross Gill"]
>     do http://reb4.me/r/google-charts.r
>     clipdata: {Adsense Revenue^-300
>     Sponsors^-500
>     Gifts^-50
>     Others^-58}
>     
>     browse chart [
>         title: "Revenue"
>         size: 650x300
>         type: 'pie
>     
>         ; extract raw data
>         data: parse/all clipdata "^/^-"
>         labels: extract data 2
>         data: extract/index data 2 2
>     
>         ; format data and labels
>         sum: 0
>         forall data [sum: sum + data/1: to-integer data/1]
>         forall data [change data round 100 * data/1 / sum]
>         forall labels [
>             labels/1: rejoin [labels/1 " " data/(index? labels) "%"]
>         ]
>     ]
>     
> 
> More information about the REBOL Google Chart API is available at http://www.ross-gill.com/page/Google_Charts_and_REBOL.
> 
> #### 7.5.1 Working with Other Web Site APIs
> 
> Chris has created a number of other web APIs that make easy work of interacting with popular sites such as Twitter, Facebook, and Etsy. A tutorial about using REBOL with the Etsy API is available here. You can read more about using REBOL with the Twitter API, and simplifying the use of Rest, OAuth, and other protocols at http://www.ross-gill.com/page/REBOL

### 7.6 Using the "Nano-Sheets" Spreadsheet App

> In the introductory demos section of this text, you saw a small spreadsheet app titled "Rebocalc". This application idea was extended in an article by Steve Irvin and Steve Shireman at http://www.devx.com/opensource/Article/27454. The resulting "Nano-Sheets" app is actually useful in production situations and can be improved using simple REBOL code. Saving, loading, printing, and other features are already available in the Nano-Sheets app. You can create your own functions that use any of the features of the REBOL language to process cell data (math, graphics, parse, native dialogs and GUI interfaces, Internet connectivity, file and network protocols to connect with data sources, etc.). This program and the free REBOL interpreter are so small that they can both be sent easily, even by email, to others who may need to use it. No large or expensive office software installations are required to run spreadsheets created with this tool.
> 
> Here's a slightly modified version, with scroll bars, for grids of any size. Column sum and row sum functions are also added the included abilities:
>     
>     
>     REBOL [Title: "Nano-Sheets Spreadsheet"]
>     cell-size:  125x20
>     sheet-size: 10x50
>     window-size: 800x450
>     scalar-types: [
>         integer! | decimal! | money! | time! | date! | tuple! | pair!
>     ]
>     protect 'scalar-types
>     sheet: lay: current-file: sheet-code: none
>     cells: copy [] 
>     sheet-buttons: copy []
>     use [
>         buttons== cell== sheet-code==
>         id val text action face style
>     ] [
>         id: val: text: action: face: none
>         style: 'btn 
>         buttons==: [
>             'buttons into [
>                 any [
>                     set val word! (id: val) 2 [
>                         set val string! (text: val)
>                         | set val block! (action: val)
>                     ] (
>                         repend sheet-buttons [id text action]
>                         append lay/pane face: make-face/size/offset style
>                             cell-size
>                             cells/:id/offset
>                         if 'button = style [face/edge/size: 1x1]
>                         if not none? face [
>                             face/text: text
>                             face/action: action
>                             face/style: style
>                         ]
>                     )
>                 ]
>             ]
>         ]
>         cell==: [
>             set id word! into [
>                 opt 'formula set val [block! | path!](cells/:id/formula: :val)
>                 | opt 'value set val [string! | scalar-types] (
>                     set cells/:id/var cells/:id/text: val
>                 )
>             ]
>         ]
>         sheet-code==: ['do set sheet-code block! (do sheet-code)]
>         sheet==: [
>             (sheet-code: none  clear sheet-buttons)
>             opt sheet-code==
>             any [buttons== | cell==]
>         ]
>     ]
>     if link? [
>         hilight-all: func [face] [
>             either empty? face/text [unlight-text] [
>                 highlight-start: head face/text
>                 highlight-end: tail face/text
>             ]
>         ]
>     ]
>     clear-cell: func [cell] [set cell/var cell/text: cell/formula: none]
>     clear-sheet: does [
>         foreach [id cell] cells [clear-cell cell]
>         clear next find lay/pane last cells
>         show lay
>     ]
>     compute: does [
>         unfocus
>         foreach [id cell] cells [
>             if cell/formula [
>                 if error? try [cell/text: do cell/formula] [
>                     cell/text: "ERROR!"
>                 ]
>                 set cell/var cell/text
>                 show cell
>             ]
>         ]
>     ]
>     cur-cell: does [either in-cell? [system/view/focal-face] [none]]
>     empty-cell?: func [cell] [
>         all [
>             none? cell/formula
>             any [
>                 none? cell/text
>                 all [string? cell/text empty? cell/text]
>             ]
>         ]
>     ]
>     enter: func [face /local data] [
>         if empty? face/text [exit]
>         set face/var face/text
>         data: either #"=" = face/text/1 [next face/text][face/text]
>         if error? try [data: load data] [exit]
>         if scalar? :data [face/formula: none  set face/var data  exit]
>         face/formula: either formula? face/text [compose [(:data)]] [none]
>     ]
>     event-func: func [face event /local f] [
>         if all ['key = event/type in-cell?] [
>             switch event/key [
>                 F2    [if in-cell? [show-formula system/view/focal-face]]
>                 up    [move up]
>                 down  [move down]
>             ]
>         ]
>         event
>     ]
>     formula?: func [text] [#"=" = text/1]
>     in-cell?: has [f] [all [f: system/view/focal-face 'cell = f/style]]
>     load-sheet: func [file [file! url!]] [
>         clear-sheet
>         parse load/all file sheet==
>         current-file: file
>         show lay
>         compute
>     ]
>     move: func ['way /local pos] [
>         pos: find cells cur-cell
>         cell: pick switch way [
>             up    [enter cur-cell  skip pos negate sheet-size/x * 2]
>             down  [enter cur-cell  skip pos sheet-size/x * 2]
>         ] 1
>         if not object? cell [cell: none]  ; if 'A1 = cell [cell: cells/A1]
>         if cell [focus cell]
>     ]
>     new-sheet: does [
>         clear-sheet
>         current-file: none
>         show lay
>         focus second cells
>     ]
>     use [not-vals] [
>         not-vals: reduce [none ""]
>         no-val?: func [cell-val] [find not-vals cell-val]
>     ]
>     open-sheet: func [/with file [file! url!]] [
>         if not file [
>             if %none = file: to-file request-file [exit]
>         ]
>         load-sheet file
>         focus second cells
>     ]
>     save-sheet: func [/as /local file buffer] [
>         if any [not file: current-file  as] [
>             if %none = file: to-file request-file/save [exit]
>         ]
>         if all [file <> current-file  exists? file] [
>             if not confirm join file { already exists. 
>                 Do you want to write over it?} [exit]
>         ]
>         buffer: copy []
>         if sheet-code [repend buffer ['do sheet-code]]
>         if not empty? sheet-buttons [repend buffer ['buttons sheet-buttons]]
>         foreach [id cell] cells [
>             if not empty-cell? cell [
>                 repend buffer [
>                     cell/var reduce [any [cell/formula  get cell/var]]
>                 ]
>             ]
>         ]
>         save file buffer
>         current-file: file
>     ]
>     scalar?: func [val] [find scalar-types type?/word :val]
>     set-cell: func [id val /local cell] [
>         cell: select cells id
>         cell/text: form val  enter cell  show cell
>         compute
>     ]
>     show-formula: func [face] [
>         if face/formula [
>             face/text: join "=" mold/only face/formula
>             focus face
>         ]
>     ]
>     ctx-html-export: context [
>         out-buff: make string! 10'000
>     html-template: {
>     <html>
>     <!--Page generated by REBOCalc-->
>     <head>
>     <title>$title</title>
>     <style type="text/css">
>     html, body, p, td, li {font-family: arial, sans-serif, 
>         helvetica; font-size: 10pt;}
>     table, tr {border-collapse: collapse;}
>     th, td {font-size: 12px; border: 1px solid #C0C0C0; 
>         padding: 0.5em 0.5em 0;}
>     th {background: #8E806E; font-weight: bold; 
>         text-align: center; color: #404040;}
>     </style>
>     </head>
>     <body bgcolor="white">
>     $table
>     </body></html>
>     }
>         emit: func [data] [repend out-buff [reduce data newline]]
>         set 'emit-html func [/to file /local val] [
>             clear out-buff
>             emit <table>
>             repeat row 1 + sheet-size/y [
>                 emit [<tr><th> either 1 = row [""] [form row - 1]</th>]
>                 repeat col sheet-size/x [
>                     emit either 1 = row [[<th> col-lbl col </th>]] [
>                         [
>                             <td width="110"> any [
>                                 get/any mk-var col row - 1 ""
>                             ] 
>                             </td>
>                         ]
>                     ]
>                 ]
>                 emit </tr>
>              ]
>             emit </table>
>             out-buff: replace copy html-template "$table" out-buff
>             write %rebolcalc-out.html out-buff browse %rebolcalc-out.html
>         ]
>     ]
>     avg: average: func ["Arithmetitc mean" block [any-block!]] [
>         remove-each val block [no-val? val]
>         either empty? block [0] [divide  sum block  length? block]
>     ]
>     gcd: func ["Greatest common denominator" m [integer!] n [integer!]] [
>         either (m // n) = 0 [n] [gcd n (m // n)]  ; Euclid's algorithm
>     ]
>     geo-mean: func ["Geometric mean" block [any-block!]] [
>         either empty? block [0] [(product block) ** (1 / length? block)]
>     ]
>     median: func [
>         "Returns the number in the middle of a set of numbers sorted by value"
>         block [any-block!] /local len mid
>     ] [
>         block: sort copy block
>         len: length? block
>         mid: to integer! len / 2
>         either odd? len [
>             pick block add 1 mid
>         ][
>             (block/:mid) + (pick block add 1 mid) / 2
>         ]
>     ]
>     mode: func [
>         "Returns the most frequently occurring value in the block"
>         block [any-block!]
>         /local last-item result high-count count
>     ][
>         block: sort copy block
>         result: last-item: first block
>         count: high-count: 1
>         foreach item next block [
>             either item = last-item [count: count + 1] [
>                 if count > high-count [
>                     high-count: count
>                     result: last-item
>                 ]
>                 last-item: item
>                 count: 1
>             ]
>         ]
>         if count > high-count [result: last-item]
>         result
>     ]
>     product: func [
>         "Multiplies all the values in the block"
>         block [any-block!] /local result
>     ][
>         remove-each val block [no-val? val]
>         result: 1
>         foreach value block [result: result * value]
>         result
>     ]
>     sum: func [
>         "Adds all the values in the block"
>         block [any-block!] /local result
>     ][
>         remove-each val block [no-val? val]
>         result: 0
>         foreach value block [result: result + value]
>         result
>     ]
>     sum-rows: func [
>         "Adds a range of row values"
>         row start end
>     ][
>         total: 0
>         for i start end 1 [
>             do rejoin ["total: total + " row i]
>         ] 
>         total
>     ] 
>     ; =sum-rows "b" 1 4 
>     sum-cols: func [
>         "Adds a range of column values"
>         col start end
>     ][
>         total: 0
>         for i start end 1 [
>             do rejoin ["total: total + " i col]
>         ] 
>         total
>     ]
>     ; =sum-cols 2 #"b" #"e"
>     col-lbl: func [col] [form to char! 64 + col]
>     cell-name: func [col row] [join col-lbl col row]
>     mk-cell-size: func [col] [
>         either any [none? col-widths  col > length? col-widths] [cell-size] [
>             as-pair col-widths/:col cell-size/y
>         ]
>     ]
>     mk-var: func [col row] [to lit-word! cell-name col row]
>     sheet: [
>         origin 5x5 space 1x1 across
>         style cell field cell-size edge none with [formula: none] [
>             enter face  compute  face/para/scroll: 0x0
>         ]
>         style label text cell-size white rebolor bold center
>         style menu button 60x20 silver edge [size: 0x0] shadow off with [
>             font/colors: [0.0.0 0.0.128]
>         ]
>         menu "New"  #"^n" [new-sheet]  menu "Open" #"^o" [open-sheet]
>         menu "Save" #"^s" [save-sheet] menu "Save As" #"^a" [save-sheet/as]
>         menu "HTML" #"^t" [emit-html]
>         text 10 "" text "(Press [F2] to edit cell formulas)"
>         return
>     ]
>     repeat row 1 + sheet-size/y [   ; +1 accounts for header row
>         repend sheet ['label (as-pair 30 cell-size/y) either 1 = row [
>                 ""
>             ][
>                 form row - 1
>             ]
>         ]
>         repeat col sheet-size/x [
>             append sheet compose/deep either 1 = row [[label (col-lbl col)]] [
>                 [cell with [var: (mk-var col row - 1)]]
>             ]
>         ]
>         append sheet 'return
>     ]
>     lay: layout sheet
>     foreach face lay/pane [
>         if 'cell = face/style [
>             repend cells [face/var face]
>             set face/var none
>         ]
>     ]
>     focus second cells
>     insert-event-func :event-func
>     gui: [
>         across
>         g: box window-size with [pane: lay pane/offset: 0x0]
>         scroller as-pair 16 window-size/y [
>             g/pane/offset/y: g/size/y - g/pane/size/y * value show g
>         ]
>         return
>         scroller as-pair window-size/x 16 [
>             g/pane/offset/x: g/size/x - g/pane/size/x * value show g
>         ]
>     ]
>     view layout gui
>     
> 
> Try saving the text below to a text file, then load it as a spreadsheet in Nano-Sheets to see how some useful features are implemented. This is the "native" internal format that Nano-Sheets uses to save data. You can also use the modified version above to save and load flat and blocked tables of REBOL data, as well as standard CSV files that are compatible with traditional spreadsheet applications:
>     
>     
>     do [
>         right-now: does [now/time/precise] 
>         circle-area: func [diameter] [diameter / 2 ** 2 * pi]
>     ] 
>     buttons [
>         A10 "Random-test" [
>             set-cell 'a11 circle-area random 10 1E-2
>         ] 
>         C10 "test-2" [set-cell 'c11 right-now] 
>         A5 "Check" [print "check"] 
>         F16 "Done" [quit]
>     ] 
>     A1 ["test"] 
>     C1 [[now/date]] 
>     D1 [3] 
>     E1 [$200.00] 
>     F1 [1x2] 
>     E2 [[d1 * e1]] 
>     A11 [19.63] 
>     C11 [0:46:00.171]
>     C12 [[c11 + 1]]
>     
> 
> As you learn more about REBOL coding, you'll be able to easily modify and extend the capabilities of the Nano-Sheets program in ways that would be very difficult or impossible to accomplish using other spreadsheet applications.

## 8\. Using REBOL to Create Presentations

> ### 8.1 REBOL as Presentation Software

> REBOL GUI features enable simple methods for laying out images and text with a variety of fonts, styles, colors, gradients, and the ability to create animations, add sounds, and make use of other elements that are useful in creating captivating audio/visual presentations. REBOL's graphic capabilities provide advanced methods for _creating images from code_, which are difficult to design even with complex graphic manipulation software (a topic for much later in this text). In most simple cases, applications such as PowerPoint and Photoshop can be easily replaced by straightforward REBOL code.

### 8.2 Some Basic Layout Ideas and a Simple Code Framework for Presentations

> Slide show presentations are often shown in full screen mode. In REBOL, the size of the screen is stored in the value "system/view/screen-face/size", so the following code creates a full screen white box that closes the GUI when clicked:
>     
>     
>     REBOL [title: "Empty White Screen"]
>     view center-face layout [
>         at 0x0 box system/view/screen-face/size white [unview]
>     ]
>     
> 
> Here are a couple of GUI layouts that serve as examples of slides with text and images. Clicking anywhere on the screen advances from one slide to the next:
>     
>     
>     REBOL [title: "Slide 1"]
>     view center-face layout [
>         at 0x0 box system/view/screen-face/size white [unview]
>         at 20x20 h1 blue "Slide 1"
>         box black 2000x2
>         text "This slide takes up the full screen."
>         text "Adding images is easy:"
>         image logo.gif
>         image stop.gif
>         image info.gif
>         image exclamation.gif
>         text "Click anywhere on the screen to close..."
>         box black 2000x2
>     ]
>     
>     REBOL [title: "Slide 2"]
>     view center-face layout [
>         at 0x0 box system/view/screen-face/size effect [
>             gradient 1x1 tan brown
>         ] [unview]
>         at 20x20 h1 blue "Slide 2"
>         box black 2000x2
>         text "Gradients and color effects are easy in REBOL:"
>         box effect [gradient 123.23.56 254.0.12]
>         box effect [gradient blue gold/2]
>         text "Click anywhere on the screen to close..."
>         box black 2000x2
>     ]
>     
>     REBOL [title: "Slide 3"]
>     view/options center-face layout [
>         at 0x0 box 600x400 [unview]
>         at 20x20 
>         text "This slide is smaller, and as simple as can be"
>         text "Click anywhere on the screen to close..."
>     ] 'no-title
>     
> 
> This program uses q-plot to create graph images of monthly sales and expense numbers, and then displays them in a full screen presentation that can be shown to a group:
>     
>     
>     REBOL []
>     do %q-plot.r
>     save/png %sales.png to-image quick-plot [
>         600x400
>         bars [5 3 8 2 10 3 4 9 5 7]
>     ]
>     save/png %expenses.png to-image quick-plot [
>         600x400
>         line [9 2 4 1 7 3 8 14 10 5 6]
>     ]
>     view center-face layout [
>         at 0x0 box system/view/screen-face/size white [unview]
>         at 20x20 h1 blue "February Sales:"
>         image load %sales.png
>     ]
>     view center-face layout [
>         at 0x0 box system/view/screen-face/size white [unview]
>         at 20x20 h1 blue "February Expenses:"
>         image load %expenses.png
>     ]
>     
> 
> Making a slideshow framework to display consecutive layouts is as simple as creating a block of nested blocks containing the GUI code, and then using a foreach loop to display each layout:
>     
>     
>     REBOL [title: "Simple Presenter"]
>     slides: [
>         [
>             at 0x0 box system/view/screen-face/size white [unview]
>             at 20x20 h1 blue "Slide 1"
>             box black 2000x2
>             text "This slide takes up the full screen."
>             text "Adding images is easy:"
>             image logo.gif
>             image stop.gif
>             image info.gif
>             image exclamation.gif
>             text "Click anywhere on the screen for next slide..."
>             box black 2000x2
>         ]
>         [
>             at 0x0 box system/view/screen-face/size effect [
>                 gradient 1x1 tan brown
>             ] [unview]
>             at 20x20 h1 blue "Slide 2"
>             box black 2000x2
>             text "Gradients and color effects are easy in REBOL:"
>             box effect [gradient 123.23.56 254.0.12]
>             box effect [gradient blue gold/2]
>             text "Click anywhere on the screen to close..."
>             box black 2000x2
>         ]
>         [
>             at 0x0 box 600x400 [unview]
>             at 20x20 
>             text "This screen is smaller, and as simple as can be"
>             text "Click anywhere on the screen to close..."
>         ]
>     ]
>     foreach slide slides [
>         view/options center-face layout slide 'no-title
>     ]
>     
> 
> You can simplify coding tediously repetitive layout elements, by only putting unique GUI elements in each slide. Widgets and layout code to appear in _all_ slides can be inserted in a "forever" loop. This example separates out the title, the text background box color/effect, and layout code to appear in each unique slide, and adds forward and back controls, bar lines (black boxes), and colors to appear in every slide. In this example, the "compose" function is used to insert data contained within parentheses. To create your own slides, all you need to do is edit the unique code to appear in each individual slide layout (title string and unique GUI code for each slide):
>     
>     
>     REBOL [title: "Presenter"]
>     slides: [
>         "Slide 1 - A Few Basics"  
>         [
>             text "By default these slides are white and full screen."
>             text bold "Adding images is easy:"
>             image logo.gif
>             image stop.gif
>             image info.gif
>             image exclamation.gif
>             text {
>                 Press the space bar, right arrow key, or left click screen
>                 for the next slide.  Press the left arrow key, or right
>                 click screen to go back to previous slide.  Press the 'X'
>                 key to quit...
>             }
>         ]
>         "Slide 2 - Colors and Gradients" 
>         [
>             at 0x90 box as-pair system/view/screen-face/size/1 220 effect [
>                 gradient 1x1 tan brown
>             ]
>             at 20x70 text "Colors and gradient effects are easy in REBOL:"
>             box effect [gradient 123.23.56 254.0.12]
>             box effect [gradient blue gold/2]
>             text {
>                 Left arrow key or right click screen to go back, 'X' key to
>                 Quit...
>             }
>         ]
>         "Slide 3 - A Simple Window"
>         [
>             text "This slide is as simple as can be."
>         ]
>         "Slide 4 - Lots of Stylized Text"
>         [
>             across
>             text "Normal"
>             text "Bold" bold
>             text "Italic" italic
>             text "Underline" underline
>             text "Bold italic underline" bold italic underline
>             text "Serif style text" font-name font-serif
>             text "Spaced text" font [space: 5x0]
>             return
>             h1 "Heading 1"
>             h2 "Heading 2"
>             h3 "Heading 3"
>             h4 "Heading 4"
>             tt "Typewriter text"
>             code "Code text"
>             below
>             text "Big" font-size 32
>             title "Centered title" 200
>             across
>             vtext "Normal"
>             vtext "Bold" bold
>             vtext "Italic" italic
>             vtext "Underline" underline
>             vtext "Bold italic underline" bold italic underline
>             vtext "Serif style text" font-name font-serif
>             vtext "Spaced text" font [space: 5x0]
>             return
>             vh1 "Video Heading 1"
>             vh2 "Video Heading 2"
>             vh3 "Video Heading 3"
>             vh4 "Video Heading 3"
>             label "Label"
>             below
>             vtext "Big" font-size 32
>             banner "Banner" 200
>         ]
>         "Slide 5 - Live Code"
>         [
>             h3 "Remember, These Slides Are Live, Fully Functional GUIs!"
>             box red 500x2
>             bar: progress
>             slider 200x16 [bar/data: value show bar]
>             area "Type here"
>             drop-down 200 data reduce [now now - 5 now - 10]
>             across 
>             toggle "Click" "Here" [alert form value]
>             rotary "Click" "Again" "And Again" [alert form value]
>             choice "Choose" "Item 1" "Item 2" "Item 3" [alert form value]
>             radio radio radio
>             led
>             arrow
>             return
>         ]
>     ]
>     indx: 1
>     forever [
>         slide: compose [
>             size system/view/screen-face/size
>             backdrop white [
>                 if indx < ((length? slides) / 2) [indx: indx + 1 unview]
>             ] [
>                 if indx > 1 [indx: indx - 1 unview]
>             ]
>             at 20x20 h1 blue (pick slides (indx * 2 - 1))
>             box black as-pair (system/view/screen-face/size/1 - 40) 2
>             (pick slides (indx * 2))
>             box black as-pair (system/view/screen-face/size/1 - 40) 2
>             key #"x" [quit]
>             key #" " [
>                 if indx < ((length? slides) / 2) [indx: indx + 1 unview]
>             ]
>             key keycode [right] [
>                 if indx < ((length? slides) / 2) [indx: indx + 1 unview]
>             ]
>             key keycode [left] [
>                 if indx > 1 [indx: indx - 1 unview]
>             ]
>         ]
>         slide: layout slide
>         view/options center-face slide 'no-title
>     ]
>     
> 
> **It's important to realize that because these slides consist of live, running REBOL code, they can contain much more than just static text and images. Any sort of fully functional application of deep complexity can be included. You could, for example, include charts, tables, or even a working spreadsheet that performs live calculations on instantly updated data**. _Using the few simple tools you've seen so far, you can easily create presentations that are all but impossible using traditional presentation software_.

### 8.3 Using Tab Panels and Menus to Present Information

> Though not a traditional slide format, a simple and effective way to present multiple screen layouts is by using a tab panel widget. The following code contains a tab panel, and also a useful menu widget, created by Richard Smolak. The same 5 example slides shown in the previous section are demonstrated here. Menus can be used to pop up small text alerts, requestors, and choices that alter the state of screens in the presentation. Simply copy the compressed tab panel code (and menu code if needed), plus the "insert-event-func" code, then put your slide code inside the "tab-panel data" block. The syntax required to use optional menus should be intuitively understandable by examining the example code provided here. Beyond being a nice way to display pages of presentation data, these two GUI tools are useful for building all types of applications which require significant screen real estate:
>     
>     
>     REBOL [title: "Tab Panel and Menu Presentation"]
>     
>     ; Tab Panel Widget: 
>     
>     do load decompress #{
>     789CBD586973E2B816FDCEAF50577FE86428C7989824506F2695349DADB37496
>     4E4FA09C2A63CBE0C6D8C4368DC9BCF9EFEF5E495E65B2CCAB9AA4005BBAD2DD
>     8E8EAEF45714AF3CF799AA33338A6948868D47253647CADCF4A9D7238E6951B2
>     74E309EBE05D6648CD1E999953CABB79CFA312384E44E31E6925ED9668A2F698
>     0A517CCC441F1577666297179836890365E4FA66B82236B582D93CA4514476F4
>     8F7F35E8D973D8FF76F8DC69FEB8D56767E387ABBED63D39383B884FC79713EB
>     E4B8D38F2EEF9ED4A3969BCCFBBF76AE7E9E2E4757ABB079D3D28FADC99F8DDB
>     6F0FA77BB3FBF1D3D199F7703C0906B3BEDEBCE99EFE6A1F8EBFF6EFC70F27EE
>     FDF2E2707C39681F5EDF256A337A1ADCEB874FB7CF897DF2E5E2A9D171EFBA4D
>     4775FC78767D6D1E4D6EA6D6F5D765D4D793E3D9E0AC3B4816E777E7CFA74F17
>     9FA7AD9B2FC9F27C104C8F0E7FBA17DD4B6B7BFAE3B6D1FC71393BD8BB9AF447
>     30CF73D3695D7C3B595EDEDE3C58BB5F4EA3CF5DB77564FF79D78CC0BC643038
>     39F8BAFB5DBB3EBF98B9FDD1FDFC9BAD37BE3E07CBF3D3D5C21B3C75CD8BE6F7
>     B3B63538BE9C3E9CF8FABDF7BDD554E943AB75A21FDF6996EA6DDF5F7DFEDE3A
>     38D8D54E0F9AD303F8FBBDF17716F40812DD237AA293ACC90ABC20EC113FF0A9
>     6833C4AF4311003CCDF058C85DA3F4F3A884D40ECD258065E15B64E8109350A3
>     200E30000001B61C750ED8F1630561A38E82D0A6E17E4910B4AA0814953A0EB5
>     004B08872002E0D024A6BECD6CDF7054748428446B6D12E600BE6E94A767ED91
>     AA6D1A85F98D3A6525EF8B1110225553C6A169BBA00780AE9176A7BDC53F3A69
>     EBFA565BDFDE6A6FEFBDC72CA31478235D67754B8C27B0038ABB6996023F4E25
>     E1B1104D9159ADDDDA129F0A0E34AD92F1F5AB5546493A0998F266DC507FCC16
>     7D012744F502CBF448E43965C844403AD60444CA19B383A55F690259CFE955C0
>     55789685D594C55464B91E89A8071926A227620F4E602D229E06D7B769B24F1C
>     F84D65945190B0C1A016463B151DAE039E0D51D6B46237F071587956E335ABD4
>     BA900BD949B064B3A15CA9CFA805B1F1D2425D9300173B7F279F98AE72BCDF11
>     6D474DF78499EBE3982012DFCDCA0C76E0C495A12200E868BA684A1282544A61
>     0593DF902D09409C50D4558FB4DB521777013B5B521F2EB9D4D091675A531908
>     68433DD5F129EAE84EB5299D9321268B0CE7D4271BC5286C82739EA7D4B4839F
>     B820BB408C2DD88535A30AB35A3E0B8305C44AEBEC6D693B5DF874C876755CF9
>     DD581FBF8C97EAE227C7568A1F0063A71AE6F706B166C914FDAEF39720A7831D
>     8CD2351DD8927F8023E1977F5E89C98B4BAF48ED9C373323855B3D12870BDE52
>     A01EA4A31EB1CDD864CF0864781D99D31E31C33058463D22A257D9C83826C0D9
>     8F436C3320313B5B6D0DF6A64E879BB104BD28202C441D64E8D3A5CAB5396E18
>     C5C4876D17348DA3FC2975C90F84E97C54E686637A00AA5C927FBBBECB20375F
>     91D94ABCA5AA33C7E4FD2E2F2AF524470F9205EE3C850D2DA6F348CC3FCCC33F
>     33936C9BCA85EB2386FF7C3B28CF62E4560A0B916786D2BE6B14048B2572FA0A
>     254C757B2D0DC92320DE7213380ACA66C1A2F08398E4CC372CC0464BA5B84340
>     FB0B0C6A668AD050988BA79F238B29C2868A2E16373214E15B4EDC98A6120BE4
>     11C80AF9657A0B1223563C73455C3B210EB32E9ECD59260AD49136959323529B
>     271BE60087F28255184367F378B52FEC2EAC3DD854C016A9192012CCA8C41DA6
>     0F21057C71BBE1812D8B0F063E7237A23874FDF107D6802E0D47B05F4E3F90FF
>     9260F413F8049FC4986C32EEF2279610836C485C042EE0907D3E217CF5C8984F
>     2FF335C8328D4561F80A166BE4A151CD0F62552A65F3A1AF741FECE3B891444A
>     0C04E1AF1158F8E8279F41EAAE752255CA025DA733CB0278B05E234ABC4D2182
>     841D13EA94E5D8038AE0894B9B306A061AC10F194DA2ED25DBDB6FD109168680
>     1AD3F5186F67CB0E57417D6E11DAD80B4A5E9B2EAF61320E2A170B355E426F8F
>     540B2B116DDCAF7161B5B014635C8F4D0AC37C8187418F5AA0BAF41578888843
>     04AB343A6CB1F4C806FE6CCA9E3E2AC5FE9A6E991BDF1F711622B613088F7051
>     41DDE999515C0EE127B45D9A8E510F9258136F24E6A61B6629D4B228BD3C2791
>     AA844DE08768EACEDF502CA4A501E7119C2D63CD824CAA34DFDBCA19CE02C1FA
>     36D83CBF112D81A3729328DA0E948505695828305C4DC81F8443A202A4628899
>     9B69D9C139282DEEE0A83B86A8BC8848D30A8328AA348A81DB499B4473445C95
>     B1983EA2ED26DA2ED910956E7B937814F2149A31253B35D067DB51E54099FE3B
>     FC52EB8DA74511232493093581B2F30305475A9D0AAC364B5250DC626D5B697D
>     6524AF72CAEF2F42B36A9A844501323CD265B23522AF2FBDEAFB9A24416E27FF
>     284BFF384788D37D5EABBE3751B5E156FEFF704B50A8B3EEDF499451A60385E8
>     AD44694B65025FE26B2E205E3EDBD4DFFD08C190724EE2B70FC4618CD324A5D3
>     A438D463C8F7457FF5CA2E3D6AA64F901026A816CB06E9A28FAB6682EBC89785
>     5B722F33BE7A7512A45727B083BFE9EA846354A14F0BD34322C16A1B7FE45A75
>     E2DA9438B51E48875B474D2959EAB20332C26B104715672EDCB91CB0AC7A6355
>     719D252271E33581023FC4A583949BF42AA2974AD4F5BF78DFCA6A222CCA3476
>     67E4517F1C4F8AB42BEE71B212B5519C3FBB421348CB2F8AA1469124D3E9544D
>     45B4AAFC7EB2A24BED6185F6895D3C56EC6681E0D19722F1E2222A0808FD42AE
>     DCDCCE9B5352AD9F242DF8D39BF1F202AF8C29121C96803E1D2343D7788D3775
>     6AB266B86033AC6DD8D628F1617D8E44D4AA550C141EFF917995973065A7A088
>     D1BB50C4D45CE2554CABB36AED18F94E614D8C15A87813FC7A43452753A4D130
>     FEFE1F50628086731B0000
>     }
>     
>     
>     ; Menu Widget:
>     
>     do load decompress #{
>     789CB51B6B73DAB8F67B7E85BA3B770237430CE4D12EDD6EC6109A92266D499A
>     B629E3CE1810C6606C6A9BE074BBFFFD9E23C9B66CCB84A477C384C8B2747474
>     5E3A0FE5EF5118D516D45DB5C8C29C53E20D6774143E23839D6F357B615A3468
>     119F8E5723CABABED55EE260329C5B646D875342C71665FD8E678EC9F1E1EF7F
>     DB9FDAEFAFD6F5B76796A7C3CFBBEB9B69F7C68256BB87CFD71DFD161F3EFFF0
>     8EBE6047FB6CDCFE78D3D5F58BB3F7930FE1D5CE7C0DBD9DF6ECFAF5F93B787D
>     7CDED775AB77A9EB1F5C0D5EE8C7F07AFC11BEDE2F11ECB103E35F37F7BE7CFF
>     EADE20C09DE6DCE9F63F5D1DBA67172F34ED85A6FFB8D1FB7A27B27A33FFD38B
>     BDABAFE7DF17E1B43B5B4DA7B06AD7BABE3A773AEFDAD7FE7BC07074D5DDB1E7
>     776BC4D25B2EDB00BBFBEE1656F7ACC08AACAF67572BBDD9A6BDC6E7B6ADEB6F
>     BAD6FCC5E91B5B3F8F2EBFF6FBD142BFA6D6E71D58EDEAF8C7CDF2EB25ECA0D3
>     D1DFBEE95E754EEFDF74FA7AB7FBEEA67376DFD1BF9FDDF6FBFA69FBEEF6D68F
>     AE7A17BADEEB0DDB9DE69DFEFEEDCE17EB6BEFB6F7767D7EEE0125EF69AF1FE8
>     EDB61E5993FAE5349AF5828B4B86E17A31E97FBC9E863F7AFACDFBFACCBA38EF
>     996DA0FBCE6D70F5E58D7DE67EE94CFBFDD7A3D3C6C58B8B2BFDB2DB7D7D7C7A
>     AD03B5FBB7FAC5DC72BF1EDE6B07EDBECE5873F3E9FDD5DBA3CE6DAFF7EA1F89
>     D9A3291DCD413CFCF9969CD6D9578F73FAB47BFAFCF8E2DFE1F44D3DE6F4F97C
>     4FDFEBAE7AB0F41A609DBE99CED7FDB6A5B7EDFECAB4AE0F7B20017A74DBB7EC
>     B707CF3F009C7EFFEDF4F38ED75D74901A97D7AF7FD43B9FDAC8ACB3CBCE9ED5
>     EDB65FB70F6F75ABDFEF358EEE74EB3540EEEA7BF3E0CB878F079ED6EE3292ED
>     E46966C06F10DE3BF60FAA2DCC20A4BED01BAE6313131489290EEFFD561B798E
>     E7B788EBB954F44C3C3714DA88CD64643276E898A379D2E94D26018509F5A89E
>     F4055373ECAD33500DF117155640C7A6043D009C5BA41135F2EB359E37F71BC7
>     2FF61B4707DF6A39706BCF1F838948A18CCDD0240397AE356CC18E6D3F08894B
>     A39098BE15A42D2399623ACBA92981F856C3E9ACB7305F1A04066A42827BA0F1
>     421BAE6C678C2B52F22769366AE7A65B6BD6EB8719A839C8CDA323522324E9C9
>     8C34A4A70C62793C8C1C41BC498617410838B5083029E5376C8A711824A236C9
>     304960164F9E50EAC492004D69333EE5DC9AACDC11190019E069CF90374B41C8
>     40F896A6ED9F90898603C84034B4A895B4C81E9F0C2D79CFF1D078603C4C1E13
>     4CBD35991428912388EDDA612B2BC42D62BAF764C0C48B6D3F850A2C75BD90F0
>     57032180CD83E3FDE6C1C17EB3719C8E5C9A2E6037F2960029ED659445B5497B
>     3C9F9A2350389B0C0DC2C553DA84ED06D40F4968DA0E419082DCE688E6642704
>     D6B7889DE9E3CA243130A337857E3835F93BE9503DFC63BF513FDE6FFCF13C47
>     098EBB1B1666ACA73688393302C5D1B1B8A0DD301DDB725B64D7A193303B7269
>     FAA618894D80E99BCB13344F4E003E806F5B364C6C46F5EC342E1087D1214883
>     45C35AC84408D7B271C5CCD8D82C813E64FAB9551812FCC9625F2AEC02E01DF5
>     5381378967E44730E9311D986A82D4C2C628500F39A9312DCCF571F55300E1B6
>     5A0315A321CC4184156354C0346F19DA9E1B2858BF6152B85872ABA10629E858
>     59DBAE202AE873153850A9470DF25FA19F553065F5E870DB353927033AF2DC31
>     0940EE4FD4AB732563D695D9AB7887822E894CEE7285CDC2803EB28BD231D1D8
>     41B6CB0D7D7610EB33B6C55B9C29654CE1164931B130B6B8E244136ABBB4C1DB
>     9968A9B292E2527C47B91992B62AA6E4ACA51A0DEA5AA6456531A70A090DC083
>     008B661674842998B776952FF2241547139A5BC50B0500159756CB92B5401555
>     3AA81E0C16C99BE715945963DB1DD3088413FEAA5E8324536722AC066F0F5468
>     E2671BAD8E1905F82C574B0D740EC8A9996BF35E2956ADD2D342FE240AFECBBA
>     2C84447DEAC89FB2132823289B7549880C3B53F2C63D4356738426A1852702B0
>     2B4B27D079F6B67476A981798C7979BC71119C2E5A41C4A7743CC8346C50B89C
>     77365D935D90135CA9A63CB232847CE078933F78368E1C2FA0357A077B41FF9A
>     3D96EF84CF015FC61ED393C47C2003180483B75FF1270D1F1E82B5F4BD110D82
>     9AB70A1128C74405F90138F8B3721D00C59578B080839C84F68212148D3B5471
>     D198D37BC2AC5730F23DC7A93936F84302E5F07E097230454C986A3E843EFEB0
>     990F8C7B900CDEB236A6211D852DE0E153362F1C71C11B92CE7E5004721018F9
>     64B128210DF723C980A3B8C51AC6D698288542DAD2368BFD0243CADF95BD3118
>     D56ADC8E174EDFF8B336EDB0FCDC509E9ACC53564E508129F6E57BB2CFF293DC
>     16A74888274623AAC3895129F1C6C12456AB85D0EC5BEDE543364F0C38AED7A3
>     669A504093A5F1A093B0539687E5B17DE6FD6C621232C47F172B27B485E5636D
>     49DA26B643333665E8CC334A0516973957D04F1A393165ECE087184B49719460
>     A4927859B40C96AA81AF8470311AEC7510FAECAF961E7C136F38C3497C804FC3
>     95EFB22DB3C050E107A003844A9E49E70C672067312A22E152879F887D8B7E1E
>     69C638705459582D7248299ECC0B49CEEFF8EC640F041E44EF24CE56404BF42D
>     CD702A3A97A2C55D23DE74BC91E9B0E65D92E0F55760C4590BED329F0381E842
>     38D7E355DC0A5643DE630727AC319ACE79C35E58ECEFD0F44547B8607FC1F2B3
>     BF3402591CF377AE07E6920F172C8D43C9241309188340C95CC1E76C5200D8C0
>     3616B305741942DC847004B605C76BE0C1793440C0102F7B2EA960536BE0C304
>     1CB49F04BD4614C2219066FE8C543818EC010055783FB79706093D42DD315F98
>     E076EC30E16192DB40DA275282BB0CB2181B29E15BE4203A48C99BA65114C1F0
>     D843E72476C2B82E9818976C769D779937B28B001F31CBC41457925254052DBF
>     860E07F92884A84C3D2E982AF7BCE03C6F4CC0629E2A3172D4013700F52A753B
>     8DE4D478446E67DBAC4E2E7768A4CA9718F0ACDDFFEDF237C277AE2529B08CD0
>     81AEC7B2561766881D29A9962BD4834AF95DAE278951455A0C7641D1CDA14349
>     0535BE45427F45AB06A3D380E5F976E1B4421B205E8136EDD6E21E768E560D31
>     1CB50C8C0419B0D2D33318892704FE45FC9FC5C376C180900A5A91643536335C
>     A0D5B45DEB191FF73BEB46B75274C7F3C144910A33300900AEFB0916C21211BE
>     6134093F992D90314DED81412AD2A1C3625926B43CAB08946F908A8864719DAA
>     34384E59A1809C24CBB22E84CF90348C814853E26C8E471604235AE674147C67
>     843C89896A89A3125A598783BD0A3D5EF293B5466887E553EA92547738DC1683
>     4B2713748F4129C08B4A8A08E09B3051355E368E23396F9BF568004D9040ED1E
>     629383FC0EA4CC2CB7EC04F896D169F2127A588D0A9F732E15FAC580557C1CC9
>     9B15B86379536BBC64E2CEAB214390217349FE634D2216E2EF2F5D2B373BDEEE
>     C85B2CC117073F3B0AC1E813166B8283432A65468347A8CDA323A3CA13DCE835
>     958E96B2E3D5BCB7581EDE97E606D4E97289090119A439DB20DCCE218599A886
>     1B3807E4D7F27975C2EB8A63EAD80BB057BE9A710058BD6DA91EB5EDEE13574B
>     AA6E091396E6A9C18F06A7B774DF19F73B9F9FE1C6281F156448554A146EB213
>     B2E06306B6A047B19F5724C2450E4975E2DDF73CF42A73DA90398B44A089669C
>     0C061299659283319226955720BC7C098208F649B3B5E653EA12982B83238599
>     1730331008E51444442251B31819C11191A90E31A9111A1D47EA92C92C0820D3
>     796D4CE9920CC6BEB9164715BA4360E2175695D4F741C3F7EB464E81F2A0C462
>     780A2AC2EF0C6C0CF184B16A9680572C80BE65410FCAB51A04741C0903B14C82
>     03C1D6C79666088F20C88C848B25FE7AF815E0976D902C150B68C3A0B2F89A1F
>     6A35FA7D653A2719416AC822AACC673C2ABFFFA40C7F31CA57E6FCE532154FBE
>     A36A663CDB3809FA0A5E025BD4099AF2792D3EAD300742928A0A12F4CFD2AA73
>     EE4D5C3F75B96CB08045890FC12F803303ADCB5BD9FCCE2B0E78F8E1F484235A
>     257FBE2249975B65647193DD6FCCAC7307AE74048421C9415D0107074C638DF9
>     C2E2C89D79109E0C7621F0406292DD4CEE1A3D6003F1C97B5CD98F4F594ED30C
>     057166A52319756AA5D4512D414A324A55456745D127EC4CD6A1243CBC050AB3
>     9D95E4FF4AD3829BC98E32A3F1B43F999448221B97C4C9998D0D54BD6011D5DD
>     6A188AF594F42A2D5DA1D92AABA115B44E594C2D8CDA504A2D8C55153F846F28
>     46F3334B7889E8472A0AADEA19B19F5A26CF42602A251B65374614EF44910B5E
>     436CC7E3F624F89732B0E08F6385AB4AFE22F50D69676081642294B44410F994
>     60414C3DB55993463063A95C406B8AE23BDBF231D90CC756C249A8B261726C60
>     6D7ECBA9049B8D3B4DB8868800B2B68CB91DF3ED2FF2105F1E5824DE285BA526
>     AF524B567900403AA7C5FD8274261279E3EC8DE51625F03DEE76D41E02BCF12D
>     1792ADF6C7252E4563C3E027D432CAB7AF7205124A3C412CCB5040B5E47BE492
>     C4BF379A3C38DB376A7A2AFD4F117C99E319A1378781E7AC42CAE4E0D1A4FE05
>     8A72992B5FF297CE8F47B24B5C87C983528EDED2C9D85CB7FA3F5E6099C49536
>     F022CA2E9EB03B26E25E49DEE530480A41EDBCB15B1D83CDA3B62FD32519371E
>     3DE7E6C57724A452D79DE9AC681C28452C32F5E154264A874DE5A2257EADCAB3
>     D9E0EA32D7B6D4DB85D80FFDDDE28D8D2D02CE38B0F35CE75E89166C92DF81D6
>     3077A118C0D3CF6C448953C4CA354A09CEE5A6B39F48DC39DDDD63E96783D1BB
>     126189870B2344A31313738CD047067B301206D57082610CA04FE970E3E72789
>     5AB9B21082C0B250E90CAC16A9B550949054CAA85415520119C92F14D7DAD574
>     5CC48A9248E12F887D2E1988B9F6C7E602C14AF9E1681516135F49EA2BAE0FA6
>     9FF20CE813EFB666925752112549812B2EDC6E4838F2DC5C116F6EEB9B8AD414
>     922E5FBC493FE2F0B96FF174791EF55C82262DC6AA39086B15B0CE7172B3FD79
>     98ABA6EFC3E153CE52F67E6BA696D239CEDD0DF87AF5FDE7F00B1FE27BEC5CF8
>     A3C0E64285E25FA474194DE3320FC6DFAEA1222DB7A18CBE3CA9A04CCCB14A13
>     D697E25889D79AF68863825F961FAD28A8F0407412B00B0149448A28629A9B9D
>     1808B25E128C4A858A5D9E5E4DF5261B84A605906DEEB6F0DB9095B20CAEB44C
>     55B67D80774148784D32D7C9CA5DB93E5E8FCC750A4615FA45ED30D39B629231
>     F0F11E25C3CEBBC41D92F412C30EBBE4C13204995B1EE9058FF45E867C3323BD
>     1921DFCDE0D1C84E725067FE312577BBE0A1A23262A03552BB943AED99FFA7B0
>     852B5B6902F7D81278B735E3D8DAB21F2B7BEF7238920BA3EEF3C3EFE597B082
>     ACA8316A33B194FC0F4EDCEB9C891B73123B8BC7D62C1358A4898F38807E8040
>     79F1CE5F8A5253AAD26477BA18373653EE49BB44B5891369E93EE37F084A7659
>     93B0D222BC8C7CA8DC1378B5CCE66E41B81A99A54D01B8042696F69F80E28B52
>     24C4202067732BD6487628BE646727D7B20587528E714B85025B2DAAB6505CE9
>     F69674D5077ACCF13873A72BBDFD1697FB714A72A52D003F4943CBA2C141A2A1
>     B30D5E5D6C99F9D04301C9244363202209FC77431B040804940CD96F930C307B
>     8BB782C12732E21B663C8F5D82914872B36B38325AB011E325D6BFBD0989FF97
>     78E79FFF0120649CE6573C0000
>     }
>     
>     insert-event-func [ 
>         either event/type = 'resize [
>             mn/size/1: system/view/screen-face/pane/1/size/1 
>             my-tabs/size: system/view/screen-face/pane/1/size - 15x30
>             show [mn my-tabs]  none
>         ] [event]
>     ]
>     
>     view/options center-face layout  [
>         across space 0x0 origin 0x0
>         mn: menu with [ 
>             size: 470x20 
>             data: compose/deep [
>                 " File " [
>                     "Open" # "Ctrl+O" [request-file]
>                     "Save" # "Ctrl+S" [request-file/save]
>                     bar
>                     "Exit" [quit]
>                 ]
>                 " Options " [
>                     "Preferences" sub [
>                         "Colors" [alert form request-color]
>                         "Settings" [request-text/title "Enter new setting:"]
>                     ]
>                     "About" [alert "Menu Widget by Cyphre"]
>                 ]
>             ]
>         ]
>         below
>         at 10x25 my-tabs: tab-panel data [
>             "1" [
>                 h1 "Slide 1 - A Few Basics"
>                 text "By default these slides are white and full screen."
>                 text bold "Adding images is easy:"
>                 image logo.gif
>                 image stop.gif
>                 image info.gif
>                 image exclamation.gif
>                 text {
>                     Press the space bar, right arrow key, or left click screen
>                     for the next slide.  Press the left arrow key, or right
>                     click screen to go back to previous slide.  Press the 'X'
>                     key to quit...
>                 }
>              ]
>             "2" [
>                 h1 "Slide 2 - Colors and Gradients" 
>                 at 0x90 box as-pair system/view/screen-face/size/1 220 effect[
>                     gradient 1x1 tan brown
>                 ]
>                 at 20x70 text "Colors and gradient effects are easy in REBOL:"
>                 box effect [gradient 123.23.56 254.0.12]
>                 box effect [gradient blue gold/2]
>                 text {
>                     Left arrow key or right click screen to go back, 'X' key
>                     to quit...
>                 }
>             ]
>             "3" [
>                 h1 "Slide 3 - A Simple Window"
>                 text "This slide is smaller, and as simple as can be."
>             ]
>             "4" [
>                 h1 "Slide 4 - Lots of Stylized Text"
>                 across
>                 text "Normal"
>                 text "Bold" bold
>                 text "Italic" italic
>                 text "Underline" underline
>                 text "Bold italic underline" bold italic underline
>                 text "Serif style text" font-name font-serif
>                 text "Spaced text" font [space: 5x0]
>                 return
>                 h1 "Heading 1"
>                 h2 "Heading 2"
>                 h3 "Heading 3"
>                 h4 "Heading 4"
>                 tt "Typewriter text"
>                 code "Code text"
>                 below
>                 text "Big" font-size 32
>                 title "Centered title" 200
>                 across
>                 vtext "Normal"
>                 vtext "Bold" bold
>                 vtext "Italic" italic
>                 vtext "Underline" underline
>                 vtext "Bold italic underline" bold italic underline
>                 vtext "Serif style text" font-name font-serif
>                 vtext "Spaced text" font [space: 5x0]
>                 return
>                 vh1 "Video Heading 1"
>                 vh2 "Video Heading 2"
>                 vh3 "Video Heading 3"
>                 vh4 "Video Heading 3"
>                 label "Label"
>                 below
>                 vtext "Big" font-size 32
>                 banner "Banner" 200
>             ]
>             "5" [
>                 h1 "Slide 5 - Live Code"
>                 h3 "Remember, These Slides Are Live, Fully Functional GUIs!"
>                 box red 500x2
>                 bar: progress
>                 slider 200x16 [bar/data: value show bar]
>                 area "Type here"
>                 drop-down 200 data reduce [now now - 5 now - 10]
>                 across 
>                 toggle "Click" "Here" [alert form value]
>                 rotary "Click" "Again" "And Again" [alert form value]
>                 choice "Choose" "Item 1" "Item 2" "Item 3" [alert form value]
>                 radio radio radio
>                 led
>                 arrow
>                 return
>             ]
>         ]
>     ] [resize]
>     

### 8.4 Show.r - A Useful Line-By-Line Presentation System

> Carl Sassenrath (the creator of REBOL) released a simple and productive presentation tool at http://www.rebol.com/notes/devcon07-carl.zip. Here's the code (you only need to edit the title and background image - copy and paste the rest):
>     
>     
>     REBOL [
>         Title: "Slideshow Presenter"
>         Author: "Carl Sassenrath"
>         Version: 3.0.3
>     ]
>     
>     file:       system/script/args
>     if not file? file [file: request-file/only]
>     title-line: "Presentation Title"                               ; EDIT THIS
>     diags:      %diags.r
>     save/png %logo.png svv/image-stock/2   ; demo image
>     back-image: %logo.png                                      ; AND EDIT THIS
>     author-mode: off
>     time-need:  1:00
>     
>     ;-- Configuration --------------------------------------------------------
>     
>     page-size: system/view/screen-face/size
>     ;page-size: 800x600
>     ;page-size: 1024x800
>     ;page-size: 740x480
>     big-size:  page-size/x > 1000
>     sect-size: page-size/x / 4 - 40
>     text-size: (round/to page-size/y / 32 4) - 1 ;pick [28 20] big-size
>     margin: round page-size/x / 10
>     h2-size: as-pair page-size/x - margin - 30 text-size * 2
>     h3-size: h2-size - (text-size / 2)
>     origin: page-size / 11
>     def-in: round page-size/x / 7
>     spacing: page-size / 100x200
>     
>     ;-- Styles ---------------------------------------------------------------
>     
>     back-image: load back-image
>     
>     stylize/master [
>     
>         vh2: vh2 h2-size left top font [
>             size: text-size + 6
>             name: "arial black"
>             style: [underline]
>             color: 240.220.60
>             shadow: 3x3
>         ]
>     
>         vh3: vh2 h3-size left middle font [
>             color: white
>             style: [bold] ; underline]
>             size: text-size
>             name: "arial"
>         ]
>         para [origin: 10x2]
>         effect [merge gradmul 96.96.96 128.128.128]
>     
>         txt: vtext page-size/x - margin - 50 font [
>             style: 'bold
>             size: text-size
>             shadow: 2x2
>         ]
>     
>         txtb: txt page-size/x - margin - 50 font [
>             color: sky + 30
>         ]
>     
>         txti: txt italic white effect [merge colorize red]
>     
>         code: tt page-size/x - (margin * 2) - 50
>             black snow edge [size: 2x2 color: gold]
>             ;snow coal edge [size: 2x2 color: gray]
>             font [
>             size: round (text-size * .8)
>             style: 'bold
>             colors: [0.0.0 0.0.80]
>         ] as-is para [origin: margin: 12x8]
>     ]
>     
>     bullet: to-image make face [
>         size: text-size / 2 - 1 * 1x1
>         color: 160.0.0
>         edge: make edge [color: black size: 0x0]
>         effect: [oval gradmul 1x1 255.255.255 0.0.0 oval]
>     ]
>     shift-bullet: text-size - bullet/size/y * 0x1
>     
>     ;bold: make face/font [name: "Arial Black" size: 480]
>     ;scale: page-size/x / 800 / 17
>     
>     backdrop: layout [
>         size page-size
>         across
>         at 0x15 box as-pair page-size/x text-size * 2
>             edge [size: 0x2 color: gold] 
>             effect [merge grid navy gradmul 200.120.100 128.128.128]
>         origin 10x20
>         banner font-size text-size + 4 italic title-line white 
>         ;font-color silver
>         return
>     ]
>     
>     backdrop/image: back-image
>     backdrop/effect: [gradmul 1x-1 50.50.90 100.120.140 fit]
>     backdrop: to-image backdrop
>     
>     end-mark: make face [
>         offset: page-size * 0x1 + 40x-20 size: 140x3 ; -140x80
>         effect: [gradient maroon green]
>     ]
>     
>     pan-mark: make face [
>         offset: page-size * 0x1 + 40x-20 size: 140x3
>         effect: [gradient maroon purple]
>     ]
>     
>     ;-- Scanner --------------------------------------------------------------
>     
>     
>     *scanner*: context [
>     
>     ;-- Variables:
>     text: none
>     part: none
>     code: none
>     title: none
>     out: [] ; holds output block
>     
>     ;-- Emitters:
>     emit: func ['word data] [
>         if block? word [word: do word]
>         if string? data [trim/tail data]
>         repend out [word data]
>     ]
>     
>     emit-section: func [num] [
>         emit [to-word join "sect" num] text
>         title: true
>     ]
>     
>     ;--- Text Format Language:
>     rules: [
>         [to "^/=start" skip to newline (author-mode: true) | none]
>         some parts
>     ]
>     parts: [
>         ;here: (print here)
>         newline |
>     
>         spaces
>     
>         ;--Document sections:
>         "===" text-line (emit-section 1) |
>         "---" text-line (emit-section 2) |
>         "###" to end (emit end none) |
>     
>         ;--Special common notations:
>         "***" para opt newline (emit bullet3 part) |
>         "**" para opt newline (emit bullet2 part) |
>         "*" para opt newline (emit bullet1 part) |
>         ":" define opt newline (emit define reduce [text part]) |
>         "#" para opt newline (emit enum part) |
>         "!" para (emit txti part)|
>         "[" example (emit code detab code) | ; trim/auto
>         ";" thru newline |  ; comment
>         ";===" to "===" |
>     
>         "==" output (emit output head insert code "  ") |
>         "=image" file (emit image text) |
>         "=all" (emit all true) |
>         "=intro" (emit intro true) |
>         "=diagram" some-chars (emit diagram text) |
>         "=pad" num (emit pad num-n) |
>         "=skip" num (clear back back tail out) num-n [to "===" thru newline] |
>         "=" some-chars | ; ignore unknown options
>     
>     
>         ;--Defaults:
>         para (emit para part) |
>         skip
>     ]
>     
>     space: charset " ^-"
>     nochar: charset " ^-^/"
>     chars: complement nochar
>     spaces: [any space]
>     some-chars: [some space copy text some chars]
>     text-line: [copy text thru newline]
>     ;par:       [copy part some chars newline]
>     para: [copy part some [chars thru newline]]
>     ;example:   [copy code some indented] ; | some newline indented]]
>     example:   [thru newline copy code to "^/]" skip thru newline]
>     indented:  [some space chars thru newline]
>     output:    [
>         copy code indented any [
>             "==" copy text indented (append code head insert text "  ")
>         ]
>     ] ; compensate for ==
>     define:    [
>         copy text to " -" 2 skip any space para
>     ]
>     file:      [
>         spaces copy text some chars thru newline (text: to-file trim text)
>     ]
>     num:       [
>         spaces copy text any chars (num-n: either text [to-integer text][1])
>     ]
>     num-n: 0
>     
>     ;-- Export function to scan doc. Returns format block.
>     set 'scan-doc func [str] [
>         clear out
>         parse/all detab str rules
>         copy out
>     ]
>     ]
>     
>     ;-- Load it up -----------------------------------------------------------
>     
>     doc-text: read file
>     if find doc-text "=author" [author-mode: on]
>     doc: scan-doc doc-text
>     ;?? doc halt
>     ;do diags ;;; NASTY!
>     
>     ;-- Globals --------------------------------------------------------------
>     
>     this-page: doc ; points to current page position
>     title:   select doc 'title
>     options: select doc 'options
>     time-left: 1.0
>     time-start: now/time
>     back-flag: false
>     
>     ;-- Helpers -------------------------------------------------------------
>     
>     title-of: :second
>     next-page: does [this-page: any [find next this-page 'sect1 this-page]]
>     back-page: does [
>         this-page: any [find/reverse back this-page 'sect1 this-page]
>     ]
>     limg: :load-image
>     load-image: func [file][
>         either exists? file [
>             limg file
>         ][
>             make image! reduce [page-size / 3 200.0.0]
>         ]
>     ]
>     
>     ;-- Page Builder ---------------------------------------------------------
>     
>     build-page: has [page out emit bull count] [
>     
>         at-once: author-mode
>         intro: false
>         in-sect: false
>         count: 0
>     
>         ; Slide title line and indentation:
>         out: compose [
>             across space spacing
>             at (origin)
>     ;        vh2 (title-of this-page) return
>     ;        indent margin guide
>         ]
>         emit: func [blk] [append out compose blk]
>         bull: func [depth] [
>             emit [pad (20x0 * 2 * depth + shift-bullet)]
>             emit [image bullet effect [key 0.0.0]]
>             emit [pad (-8x0 - shift-bullet)]
>         ]
>     
>         foreach [type data] this-page [
>             switch type [
>                 sect1 [
>                     if in-sect [break]
>                     in-sect: true
>                     emit [
>                         vh2 (data) return
>                         indent (margin) guide
>                     ]
>                 ]
>                 sect2 [emit [pad 0x4 * spacing vh3 (data) return]]
>                 para [emit [txt (data) return]]
>                 code [
>                     emit [
>                         pad to-integer margin / 3 code (trim/auto data) return
>                     ]
>                 ]
>                 bullet1 [bull 1 emit [txtb (data) return]]
>                 bullet2 [bull 2 emit [txtb (data) return]]
>                 enum [
>                     emit [
>                         txtb (join count: count + 1 [". " data]) return
>                     ]
>                 ]
>                 pad [emit [pad (data * text-size * 0x1)]]
>                 txti [emit [txti (data) return]]
>                 define [
>                     emit [
>                         pad 30 txt def-in no-wrap (data/1) txtb (data/2) 
>                         return
>                     ]
>                 ]
>                 diagram [
>                     type: layout/tight blk: get to-word data
>                     emit [
>                         pad (as-pair margin 30)
>                         ;panel (type/size) [(blk)]
>                         return
>                     ]
>                 ]
>                 image [
>                     data: load-image data
>                     emit [
>                         pad (
>                             as-pair 
>                             page-size/x - data/size/x / 2 - margin
>                             text-size
>                         )
>                         image (data)
>                         return
>                     ]
>                 ]
>                 intro [
>                     intro: true
>                     at-once: true
>                 ]
>                 all [at-once: true]
>             ]
>         ]
>         out: layout/tight out
>         offs: 100x100
>         if intro [
>             foreach face out/pane [
>                 if face/style = 'txt [offs: 110x120]
>                 face/offset: face/offset + offs
>             ]
>         ]
>         out/pane
>     ]
>     
>     ;-- Show page:
>     show-page: func [out] [
>         ; Do we step through items one at a time?
>         either any [at-once back-flag] [
>             items: []
>         ][
>             items: copy next out
>             clear next out
>         ]
>         screen/pane: out
>         if at-once [show-end-mark]
>         show screen
>         back-flag: false
>     ]
>     
>     pan: []
>     
>     show-end-mark: does [
>         time-used: now/time - time-start
>         either time-need - time-used <= 0:00 [
>             end-mark/effect/3: red
>             end-mark/size/x: 140
>         ][
>             end-mark/size/x: (
>                 to-decimal (time-need - time-used) / to-integer (time-need)
>             ) * 140
>         ]
>         append screen/pane end-mark
>     ]
>     
>     ;-- Traverse pages:
>     next-item: does [
>     
>         if not empty? pan [
>             append panel pan/1
>             remove pan
>             if empty? pan [
>                 append screen/pane pan-mark
>             ]
>             show screen
>             exit
>         ]
>     
>         either not empty? items [
>             if items/1/style = 'panel [
>                 panel: items/1/pane
>                 pan: copy panel
>                 clear panel
>                 append screen/pane items/1
>                 remove items
>                 next-item
>                 exit
>             ]
>             if items/1/style = 'image [
>                 append screen/pane items/1
>                 remove items
>             ]
>             append screen/pane items/1
>             remove items
>             if empty? items [show-end-mark]
>             show screen
>         ][
>             next-page
>             show-page build-page
>         ]
>     ]
>     
>     back-item: does [
>         pan: []
>         back-page
>         back-flag: true
>         show-page build-page
>     ]
>     
>     ;-- Handle Keystrokes:
>     do-key: func [key] [
>         if key = escape [quit]
>         switch key [
>             #" " [next-item]
>             #"^(back)" [back-item]
>             down [next-item]
>             up [back-item]
>             page-down [next-page show-page build-page]
>             page-up [back-item]
>         ]
>     ]
>     
>     count-slides: has [n d] [
>         n: 0
>         d: doc-text
>         while [d: find/tail d "^/==="] [n: n + 1]
>         n
>     ]
>     
>     this-page: doc ;next-page halt
>     
>     ;-- Build screen and event handler:
>     screen: [
>         size page-size
>         across
>     ]
>     
>     if not author-mode [
>         append screen [
>             at (as-pair page-size/x - 150 20) t1: txt form now/time
>             at (origin) guide
>             v1: vh2 "Show07.r Information and Setup" return
>             vh3 200 "Version:" 
>             vh3 gold form system/script/header/version return
>             pad 0x30
>             vh3 200 "File: " vh3 gold form file return
>             vh3 200 "File size:" vh3 gold reform [
>                 round (511 + size? system/options/script) / 1024 "K"
>             ] return
>             vh3 200 "Slides: " vh3 gold form count-slides return
>             pad 0x30
>             vh3 200 "Page size: " vh3 gold form page-size return
>             vh3 200 "Font size: " vh3 gold form text-size return
>             vh3 200 "Head font: " vh3 gold form v1/font/name return
>             vh3 200 "Body font: " vh3 gold form t1/font/name return
>             vh3 200 "Origin: "   vh3 gold form (origin) return
>             vh3 200 "Margin: "   vh3 gold form margin return
>             vh3 200 "Spacing: "   vh3 gold form spacing return
>         ]
>     ]
>     
>     screen: layout/tight screen
>     
>     screen/image: backdrop
>     screen/color: navy
>     view/new screen
>     
>     insert-event-func func [face event][
>         switch event/type [
>             key [do-key event/key]
>             down [next-item]
>             alt-down [back-item]
>             close [quit]
>         ]
>         event
>     ]
>     
>     items: []
>     if author-mode [show-page build-page]
>     
>     do-events
>     
> 
> Using the program above is easy. Save it as %show.r. Edit the "title-line" and "back-image" variables. Upon running the program, a file is requested. Save the following text file as show-example.txt, and load it into show.r when requested (you can also examine the text files included in the download at http://www.rebol.com/notes/devcon07-carl.zip - it contains three actual presentations created by Carl). The space bar, mouse, and cursor keys control progress of the slide contents:
>     
>     
>     ===Presentation Title
>     
>     =intro
>     
>         ---Nick Antonaccio
>     
>         Operating Manager
>         Merchants' Village, LLC
>         Pittston, PA  2013
>     
>     ===A Main Slide Header
>     
>         ---A Sub Header
>         (Some sub text)
>     
>     =pad
>         #Numbered item 1
>         #Numbered item 2
>         #Numbered item 3
>         #Numbered item 4
>     
>     ===Another Main Slide
>     
>         ---Another Sub Header
>     
>         *Bullet Item 1:
>             **Sub Bullet Item 1a
>             **Sub Bullet Item 1b
>             **Sub Bullet Item 1c
>         *Bullet Item 2:
>             **Sub Bullet Item 2a
>             **Sub Bullet Item 2b
>             **Sub Bullet Item 2c
>         *Bullet Item 3
>         *Bullet Item 4
>     
>     ===A Third Main Slide
>     
>         ---Subheader:
>     
>     =image rebol.gif
>     
>     =pad
>     
>     =image info.gif
>     
>     ===Slide 4
>     
>         ---Subheader 4:
>         Topic 1 - idea 1
>         Topic 2 - idea 2
>         Topic 3 - idea 3
>         Topic 4 - idea 4
>     
>     [
>         A preformatted text block:
>     
>             Idea 1:  some thoughts
>             Idea 2:  some thoughts
>             Idea 3:  some thoughts
>             Idea 4:  some thoughts
>     ]
>     
>     ===Slide 5
>     
>         Some Text
>     
>         ---Definitions:
>     
>         :Idea 1 - definition of Idea 1
>         :Idea 2 - definition of Idea 2
>         :Idea 3 - definition of Idea 3
>         :Idea 4 - definition of Idea 4
>     
>     =all
>     
>     ---Last Idea 1
>     ---Last Idea 2
>     ---Last Idea 3
>     
>     ###
>     
>     Notes: nothing below the 3 pound characters appears in the presentation.
>     
> 
> Because this program is entirely REBOL code, you can make changes and add functionality to it as needed. And just as with all other REBOL software tools, you can transfer, install, and quickly send by email the entire program, _together with the REBOL interpreter_, even to users with low powered computers and slow bandwidth Internet connections. The program will run on any operating system supported by REBOL, and the entire setup is free for anyone to copy, use, alter, etc.

### 8.5 Creating "Screen Shot" Images of GUIs

> When building presentations, it can be helpful to have screen shots of programs and/or to build graphic layouts using the REBOL graphic dialect. You can use the "to-image" function to create images from GUI layouts, and the "save/png" function to save image data to a .png file:
>     
>     
>     REBOL [title: "Create Images From GUI Code"]
>     save/png %image1.png to-image layout [
>         size 600x400
>         backdrop white
>         h1 blue "Slide 1"
>         text "Here's a red box:"
>         box red "I'm red!"
>     ]
>     browse %image1.png
>     
> 
> Here's an advanced graphic example by John Niclasen (the "draw" dialect used here will be covered in more depth later in this tutorial):
>     
>     
>     REBOL [title: "Shiny Black Button"]
>     sz: 200x400
>     img: make image! sz
>     img/alpha: 255
>     draw img compose [
>         pen none
>         fill-pen linear (as-pair 0 sz/y / 2) -50.5 70.5 90.0 1.0 1.0
>                 45.45.47 9.9.11 108.113.117
>         circle (as-pair sz/x - 115 sz/y / 2) 70.5
>         fill-pen 1.0.5
>         circle (as-pair sz/x - 115 sz/y / 2) 68.5
>         reset-matrix
>         fill-pen linear (as-pair sz/x - 115 sz/y / 2) -60.5 30.5 45.0 1.0 1.0
>                 161.164.169 161.164.169 89.94.100
>         box 
>             (as-pair sz/x - 115 - 26 sz/y / 2 - 26) 
>             (as-pair sz/x - 115 + 26 sz/y / 2 + 26) 10.0
>         fill-pen 1.0.5
>         box 
>             (as-pair sz/x - 115 - 22 sz/y / 2 - 22) 
>             (as-pair sz/x - 115 + 22 sz/y / 2 + 22) 6.0
>         reset-matrix
>         fill-pen linear (as-pair 0 sz/y / 2 - 26) -50.5 100.5 90.0 1.0 1.0
>                 1.0.5.255 200.214.226.224 200.214.226.128
>         shape [
>             move 154x200
>             arc 16x200 68.0 68.0
>             arc 154x200 -149.0 68.0
>         ]
>     ]
>     save/png %black-btn.png to-image layout [
>         backdrop 1.0.5
>         image img
>     ]
>     browse %black-btn.png
>     

### 8.6 Embedding Binary Resources (images, sounds, files etc.) in Code

> The following program can be used to encode external files (images, sounds, DLLs, .exe files, etc.) so that they can be included within the _text_ of your program code:
>     
>     
>     REBOL [Title: "Simple Binary Embedder"]
>     
>     system/options/binary-base: 64
>     file: to-file request-file/only
>     data: read/binary file
>     editor data
>     
> 
> Use "load (data)" to make use of any text data created by the above program. This example uses a text representation of the image at http://musiclessonz.com/test.png, _encoded with the program above_:
>     
>     
>     picture: load 64#{
>     iVBORw0KGgoAAAANSUhEUgAAAFUAAABkCAIAAAB4sesFAAAAE3RFWHRTb2Z0d2Fy
>     ZQBSRUJPTC9WaWV3j9kWeAAAAU1JREFUeJztlzEOgzAQBHkaT7s2ryZUUZoYRz4t
>     e9xsSzTjEXIktqP3trsPcPPo7z36e4/+3qO/9y76t/qjn3766V/oj4jBb86nUyZP
>     lM7kidKZPFE6kydq/Pjxq/nSElGv3qv50vj/o59++hNQM6Z93+P3zqefAw12Fyqh
>     v/ToX+4Pt0ubiNKZPFE6Ux5q/O/436lkh6affvrpp38ZRT/99Ov6+f4tPPqX+8Ps
>     /meidCZPlM7kidKZPFE6kydKZ/JE6UyeKJ3JE6UzeaJ0Jk+UzuSJ0pk8UTMmvn8L
>     j/7l/nC7tIkonekLdXm9dafSmeinn376D/rpp5/+vv1GqBkT37+FR/9yf7hd2kSU
>     zuSJ0pk8UTqTJ0pn8kTpTJ4onckTpTN5onQmT5TO5InSmTxROpMnasbE92/h0b/Q
>     //jR33v09x79vUd/73XvfwNmVzlr+eOLmgAAAABJRU5ErkJggg==
>     }
>     view layout [image picture]
>     
> 
> The program below allows you to _compress_ and embed files in your code. **This compressing BINARY RESOURCE EMBEDDER program will be referred to many times throughout the tutorial**. Save it to a .r file so that it can be run later:
>     
>     
>     REBOL [Title: "Binary Resource Embedder *** SAVE THIS PROGRAM ***"]
>     system/options/binary-base: 64
>     editor picture: compress to-string read/binary to-file request-file/only
>     
> 
> To use the compressed version of data created by the program above, use the following code:
>     
>     
>     to-binary decompress {compressed data}
>     
> 
> For example:
>     
>     
>     REBOL []
>     image-compressed: load to-binary decompress 64#{
>     eJzrDPBz5+WS4mJgYOD19HAJAtL/GRgYdTiYgKzm7Z9WACnhEteIkuD8tJLyxKJU
>     hiBXJ38f/bDM1PL+m2IVDAzsFz1dHEMq5ry9u3GijKcAy0Fh3kVzn/0XmRW5WXGV
>     sUF25EOmKwrSjrrF9v89o//u+cs/IS75763Tv7ZO/5qt//p63LX1e9fEV0fu/7ap
>     7m0qZRIJf+2DmGZoVER5MQiz+ntzJix6kKnJ6CNio6va0Nm0fCmLQeCHLVMY1Ljm
>     TRM64HLwMpGK/334Hf4n+vkn+1pr9md7jAVsYv+X8Z3Z+M/yscIX/j32H7sl/0j3
>     KK+of/CX8/X63sV1w51WqNj1763MjOS/xcccX8hzzFtXDwyXL9f/P19/f0vxz4f2
>     OucaHfmZDwID+P7Hso/5snw8m+qevH1030pG4kr8fhNC4f/34Z89ov+vHe4vAeut
>     SsdqX8T/OYUCv9iblr++f67R8pp9ukzLv8YHL39tL07o+3pekn1h/dDVBgzLU/d3
>     9te/Lki4cNgBmA6/lO+J/RPdzty8Rr5y94/tfOxsX6/r8xJK0/UW9vlH93/9oAzR
>     e09yKIUBVbT9/br/U/m7x6CU98VAAJS2ZPPF/197eEDhtfs9vX9rDzc6/v3qzUyo
>     nJA/dz76Y77tHw+w3gXlbEMpDKihza/+7/o/c3+DU54tDwsobR2/fXR/qYXBiV8T
>     t3eDEmpA/d9LDASK0y/tnz+H/Ynmt78E1vti7lAKA6pouxz/X7v+uR045ZFdRE6x
>     1q21pG7NiSzx1f5R40pvvdNn+oB1P4Onq5/LOqeEJgCemFy1KQgAAA==
>     }
>     view layout [image image-compressed]
>     
> 
> You will use the binary resource embedder regularly. It's a good idea to save it now to your desktop or some location on your hard drive that's easily accesible.

### 8.7 Playing Sounds

> Playing .wav sound files is easy in REBOL:
>     
>     
>     insert s: open sound:// load %/c/windows/media/tada.wav wait s close s
>     
> 
> Just as with images, you can use the "Binary Resource Embedder" program to save sound files as code in your programs. This example loads and plays an embedded sound:
>     
>     
>     REBOL []
>     my-sound: load to-binary decompress 64#{
>         eJxtlHtMU1ccx6vGR3kWLMWpm5pskc2pi3MkqFNYJsh0oigV5KEULK2lpdDb9vbe
>         9r56W1pogSKltBQqSGGAlYeimAlDkU1H1KgssrhBmFNhjAECHcZl2bVo1LjfyTm/
>         nO/vdf45n9joyMjphTTaoQj2Tq4QWB1Io9HmUSt8Fc2z59GWUEp6KpB6k8pC3zJs
>         7nzTvXbB/sdhmMdjcx5744q9SkHf1l4f/LLhq+K33jZnOI6/3gZBVAjq8Qj6Mkzl
>         ek5KwBEpL11saGyrANhx4kKHzUBgmFKhUKKIAgBAlNRqNaSayiO1pEqeLeTzxZjJ
>         nA+KAK2ByBaidle1XoGVnrLjx3kSlULEOSaBIBmkMZkL9Lo8owYUZYqyRLwMMVJo
>         NqgkoL7MQoqOiXUVzpPl1a7OiyXS6K2RBxJiE1KgitrTteYyq0ktStgbE3MwTUha
>         7BXFmDxHjpGITE5Unu++dLaupc2UFTLfd5PEZi8xObp7W/Ts8N3Jx3npXMjqarQA
>         8XFHpJBUeAwscNRZ8wwF1a7auvIzVWRCwCL/XY6B4c5CWGYol+8LWfk52X63t1Ka
>         mnw0Izk+XkCcbDpVKueKUdvpRofVfulms3TlIh8mODQ7fjpx2359ERTFZB3u+Gt2
>         MH+zr8+mgwJMZ2/vajYeDt2aYr72U7eNUDf+es+yYQFzQcQvs+MTmQH0zaTTsued
>         j/HHT2b6vloc6L0+71Z/hw2RykVHvt6bVtTZd+ecraCq3sT28fNnFD4bdQ/sWhwQ
>         xHG14HH7iHtPpi6ELgn0CnFNTQybdwSviYLs39TYyqwN565cq+evoQctDvv+6cjT
>         ns/ogQGH6r4tVwh0PWMjzq1egb5rqqfHJhq3+Pt9kOW61l2jh3TOG0Pt/BV01sL9
>         A+7H/5xi+TGWpl/pq0cScxruP2qI8g70W2Zxj7ovb/cJYCS0D49dMXC5up4H13OC
>         vFkLEodnhv8t8WUE+AsHn9w27totPj94XbXCZ6l31uj45MOkJUz65tbJiZGahJ1p
>         rv6fcZYXa/7eodlHtLplXqyFkXenJ7qSwz4VNlxuTlrK8NvYNDPqrl9LDcq4Pzk5
>         aIyNFpdftITSmfQP256NuH9jL2L6MhVDk2Mdiojt8WBZniB8bWha7f2JOyf2BLO2
>         4b1jk301pAxAeFtWegfvbJgan36ofc/Hj7G/cuCPvlaYx04SZPCT4lKExvqLbRXg
>         wS+jBZbv+vuuNhWDieuCAoN3EP0zU5PnOcu9vEO41Tdu9zp1AOc4N4PDPpSYlV/T
>         dtaBcWJi+YbWH+/e7HAoD6zyZyyP0t9z//1nq2Cjj/8nKaXtP1ytOyHn8TkZ3DRu
>         ugjWWU9WFqMivhCznunq6W42Z4Yt8wrYwGt++NR9x5K0/t33I0TFrZ1tTj3ATU7l
>         iUFQli2SwFrTiaJ8jdZgrmpou+CqkOz+yD94XZK568Hvt5rwo3u+iEmR6IttZUYS
>         yBRkyhFCDcnEmdkArMkvsTlqapx1VeWGnCNRYWHhidKi+pbW+tJ8pVwuQ3G1BoVz
>         eOkcbg6caywoyMWVIKTEqf9ozNPrcrUYLMuRABBO6nUkppACAIzpqLQ8LYmpIBAE
>         FRAEwbASwQmCwFSwgpIgJarW6inTUfUakiTVOAJTMkJoNCSuAmVSQCqHUdwTec4X
>         tRrHVEpYqaKMIg9OqNVqAvcgh9RoczUkgSKeGMUlRKWkBqpQah6Gzkko/oJjOE7g
>         L2FFAc2DM8zTjHoZDKsw4vlEDwyRF5xUKZVUj7lagsCxOfYR/wHwfuhW/AUAAA==
>     }
>     
>     insert port: open sound:// my-sound wait port close port
>     

### 8.8 Launching Code in Separate Processes

> For background sounds and other elements of a presentation, it can be helpful to run code sections as separate programs which don't block or interfere with the operation of your main program. You can accomplish this easily by writing the separate code to a text file, and then using the "launch" function to run it. The "launch" function opens a new instance of the REBOL interpreter, to run the loaded file. The launched code executes as a totally separate and independent program. Be sure to include a REBOL header in the saved program:
>     
>     
>     REBOL []
>     
>     write %playsound.r {
>     REBOL []
>     insert s: open sound:// load %/c/windows/media/tada.wav wait s close s
>     }
>     
>     launch %playsound.r
>     

### 8.9 Running Command Line Applications

> The "call" function executes commands in your computer's operating system (i.e., DOS and Unix commands). This can be really useful when creating presentations of all kinds. The example below opens Windows' Notepad to edit the "C:\YOURNAME.txt" text file created earlier (leaving out the /show option runs the program in a hidden window):
>     
>     
>     call/show "notepad.exe c:\YOURNAME.txt"
>     
> 
> This next example opens Windows' Paint program to edit an image we downloaded earlier in the tutorial:
>     
>     
>     call/show "mspaint.exe c:\bay.jpg"
>     
> 
> Here's an example that embeds an executable program into the code, decompresses, and writes the program to the hard drive, and then runs it with the call function:
>     
>     
>     program: load to-binary decompress 64#{
>     eJztF11sU2X03K4VqJsrkZJp6OzchhFJsx8qDB9od1fHdIO6ds7AgJX2jttyey/p
>     vWUjJuNnmNhMibzwaCSLi+EBE1ziGIkBGh0BSYTwwAMme9Dk4kgkgSiKcj3nu7es
>     QrKFhMUQOcn5+c7fd875+vXe27FJAg4AbIiGAQwWIwZMEbqTcmODN5xRdmRi6aoy
>     Z83YogngLlaNtV+s6kV7q9KelHeu9LYqQTXt7e/v97UqLcLuqKJIvriShnAIoJ0r
>     gXvPn+StlDAF5dyzHLwAdlw4TZ1Mm7oQvWDu7jKLslsxBc4KQ30bb9bMHF3F/D5j
>     MFAHEIbHD+cwb88s9riSEIjvK7EKogZs//bxAvQmYlqM5JsOUwHPWFgEAYDTvqTp
>     eYdy1Fn5Sh/O96h9nLrrDcD4IpQm7UOkWL/nt6MlqMvxrkl+GVWS7xqWalzDzqGz
>     9rbyD5ehpmnl+ezt3M/RSPe7Q9/ajeh5+9Ztm3vKh9xoM7SaimLUR18C2JKf+Kg2
>     APoJwzDOuiAF+hHU/pHXryObdLyP+y2kEhx7UaLfo0gq/RJa60/n88Ndrpz7FmqG
>     u5bk3L8zwdWXc0+jdOYXkn4lnYfW++/qOPLyDz7BfH3jTXVnplx949inhPvnSgw/
>     8RSIHM7P8PdSUYtxlxSkONE+o/u7EkNElMbpcuRKUhTjmLH/iHbDQQ7DHqL77zbh
>     oQxeRa9duBQHkRj+HnIdr7y/e178AvmmnHt5VQAmaNo59/EZ8QSJAY7EURJvMu2x
>     KipYj2CaEToYve2eYYiwl4rWY6jN8RWF5XtsuWSyhO7aJG8XXQFkNdWYIqIHK8nH
>     8FOSFJMoteEfZfQEo1SNCPCW2/BTjWK1uXkp9dDDegjrDqpkAUtiJhNp4ma3qUrx
>     MG6dqkyFMQ2ExQmaxgU2c/07D2ZJsCz3Q68Xh76Cvac2pZwi8jCO8rIZd4jielmc
>     uHxmsEMe1vMBZJf0YY8Pda95yH5p+tWrI86XMZbTE5a1gVlXFKyryeowp0Cy4Wf+
>     hdSrWGp26N008hW4XnS6/OBS7MnUVHoK0osoTV+22qF56c95qKdtZBzB66J/imSc
>     /Rmsg/KDdHFbA9O3RrZWByD/qPf1KTCwze3y2KCbn9vnP4ExoItiwr11zvncqq6+
>     oXGV//XVa5qCzXxL6M3ZfBfMZyFPBvywgD3FGDjLnGVl83o4T+HJAZ/PFxWTqrcj
>     GxerHljRqyL9sWXxqU2/nkHki1H4HDkvJeM7vZooeLdnNU2R10K34G1XdgveTmE7
>     vmv7fNDcFY1u3ABpNa5J6rZd9MouqGpjw6z1GLXn6vDxV/s9o1cYvcroNUanGP2J
>     UZ3RG4zeZPQ2o3cY/YtRqCdqZ3Qho6WMuhitYHQZ0pr6mRr21Zvv03VFuuMoX0Gd
>     VqT7BlupKFoXw8eo/8yynUR+HvEa4g3EPxEXYuwSxOWIaxADiGHEBKKGeADxCOIx
>     a1wXkE81zH/ut0OdG0LtjQ2+hCSBzLUKWoeSyErC+pickIQgfAmhgaSG319xPEvo
>     ioQ6Ld9D0CL04ddZQuknaxA4W1hRtXeySa0DXWM7BHjDFhHkhLUKYs2cJTcrA0H4
>     mmtXYgk+m1GVTBBOsVVbXJGDsNTWKexIqpqQ4aWYqgbps4LPCDFNMPcLYXQpldrC
>     g0bcVHcKcQ220DqyB4PTHYKWScZVgCGsw/LBEgHWsjYLZR2zRTMxWZUwfaFwOAot
>     SXVXTIuLM9V/ZeuSMw/UxW/s4KOF6W2GNjmp8Uo6rci8ImsZRVLxG+1hZWhgrlv6
>     /4F/ABcSIgQAEAAA
>     }
>     write/binary %program.exe program
>     call/show %program.exe
>     
> 
> The "call" function has many options that allow you to monitor, control, and make use of output from external command line applications. Type "help call" into the REBOL interpreter for an introduction. For more information, see http://rebol.com/docs/shell.html.

### 8.10 Creating Simple Animations

> You can place your widgets at specified coordinate positions (XxY coordinates indicate X pixels over and Y pixels down):
>     
>     
>     REBOL []
>     view layout [
>         size 600x400
>         at 200x250 btn "button 1"
>         at 300x350 btn "button 2"
>     ]
>     
> 
> Change a labeled widget's position using the "/offset" refinement, followed by a colon:
>     
>     
>     REBOL []
>     view layout [
>         size 600x400
>         at 20x20 btn1: btn "button 1" 
>         at 100x20 btn "change button 1's position" [
>             btn1/offset: 300x250
>             show btn1
>         ]
>     ]
>     
> 
> You can create a coordinate position from two separate numbers, using the "as-pair" function (paste/F5):
>     
>     
>     REBOL []
>     x-size: 600
>     y-size: 400
>     x-position: 20
>     y-position: 20
>     view layout [
>         size (as-pair x-size y-size)
>         at (as-pair x-position y-position) button1: btn "button 1"
>     ]
>     
> 
> To create a repeating loop, just copy the line below that starts with the word "box", and the closing 3 square brackets, into your GUI code. Anything inside those brackets will be repeated continuously. This is a simple way to create continuous motion:
>     
>     
>     REBOL []
>     view layout [
>         size 600x440
>         btn1: btn red
>         box 0x0 rate 0 feel [engage: func [f a e] [if a = 'time [
>             btn1/offset: btn1/offset + 2x2
>             show btn1
>         ]]]
>     ]
>     
> 
> To control movement using keyboard controls, you need to check for user keystrokes:
>     
>     
>     REBOL []
>     view center-face layout [
>         size 600x440 
>         text "Press an arrow key"
>         key keycode [left]  [alert "You pressed the LEFT arrow key"]
>         key keycode [right] [alert "You pressed the RIGHT arrow key"]
>     ]
>     
> 
> Put the motions to be performed inside square brackets following an if test:
>     
>     
>     REBOL []
>     direction: "down"
>     view layout [
>         size 600x440
>         btn1: btn red
>         box 0x0 rate 0 feel [engage: func [f a e] [if a = 'time [
>             if btn1/offset/2 > 420  [direction: "up"]
>             if btn1/offset/2 < 1    [direction: "down"]
>             if direction = "down"   [btn1/offset: btn1/offset + 0x5]
>             if direction = "up"     [btn1/offset: btn1/offset - 0x5]
>             show btn1
>         ]]]
>     ]
>     
> 
> Use REBOL's "within?" function to test for graphic collisions (i.e., when graphics touch, or share coordinate locations):
>     
>     
>     REBOL []
>     direction: "down"
>     view layout [
>         size 600x440
>         btn1: btn red
>         at 20x350 btn2: btn green
>         box 0x0 rate 0 feel [engage: func [f a e] [if a = 'time [
>             if btn1/offset/2 > 420  [direction: "up"]
>             if btn1/offset/2 < 1    [direction: "down"]
>             if direction = "down"   [btn1/offset: btn1/offset + 0x5]
>             if direction = "up"     [btn1/offset: btn1/offset - 0x5]
>             show btn1
>             if (within? btn1/offset btn2/offset 1x1) [alert "Collision!"]
>         ]]]
>     ]
>     
> 
> This simple program demonstrates the some of most important animation techniques discussed here. Catch the falling pieces:
>     
>     
>     REBOL [title: "Catch"]    
>     alert "Arrow keys move left/right, up goes faster, down goes slower"
>     random/seed now/time   
>     speed: 11   score: 0
>     view center-face layout [
>         size 600x440   backdrop white   across
>         at 270x0 text "Score:"  t: text bold 100 (form score)
>         at 280x20  y: btn 50x20 orange
>         at 280x420 z: btn 50x20 blue
>         key keycode [left]   [z/offset: z/offset - 10x0  show z]
>         key keycode [right]  [z/offset: z/offset + 10x0  show z]
>         key keycode [up]     [speed: speed + 1]
>         key keycode [down]   [if speed > 1 [speed: speed - 1]]
>         box 0x0 rate 0 feel [engage: func [f a e] [if a = 'time [
>             y/offset: y/offset + (as-pair 0 speed)  show y
>             if y/offset/2 > 440 [
>                 y/offset: as-pair (random 550) 20   show y
>                 score: score - 1
>             ]
>             if within? z/offset (y/offset - 50x0) 100x20 [
>                 y/offset: as-pair (random 550) 20   show y
>                 score: score + 1
>             ]
>             t/text: (form score)  show t
>         ]]]
>     ]
>     
> 
> Your ability to create interesting animations is limited only by creative application of movement.

### 8.11 A Simple Animation Framework for Presentations

> A simple animation framework, specifically designed to make easy work of moving and resizing GUI elements in presentations, created by Jeff Kreis, is available at http://www.cs.unm.edu/~whip/presentation.r (be sure to download the demo file at http://www.cs.unm.edu/~whip/test-prez.r). A short discussion of this tool is available on the REBOL mailing list at http://www.rebol.org/ml-display-thread.r?m=rmlBYZS

### 8.12 Using Animated GIF Images

> Another easy way to work with animations in REBOL is with the "anim" style in GUIs. Anim takes a series of still image frames, and plays them in order as an animation with a given rate. The basic format is:
>     
>     
>     view layout [
>         speed: 10
>         anim rate (speed) [%image1.gif %image2.gif etc...]
>     ]
>     
> 
> The following script will convert an animated .gif into a folder filled with individual frame images:
>     
>     
>     REBOL []
>     
>     gif-anim: load to-file request-file
>     make-dir %./frames/
>     count: 1
>     
>     for count 1 length? gif-anim 1 [
>         save/png rejoin [
>             %./frames/ "your_file_name-" count ".png"
>         ] pick gif-anim count
>     ]
>     
> 
> This next script will convert a directory of images (such as above, or any other series of images) into an embeddable block of REBOL code. It looks for all the images named [%your_file_name-1.* your_file_name-2.* etc...]:
>     
>     
>     REBOL []
>     
>     system/options/binary-base: 64    
>     file-list: read  %./frames/
>     anim-frames-block: copy []
>     foreach file file-list [
>     
>         ; Unique portion of file names for your image frames go here.
>         ; Leave out this check if you instead want to convert all
>         ; files in the directory:
>     
>         if find to-string file "your_file_name-" [ 
>             print file
>             uncompressed: read/binary file
>             compressed: compress to-string uncompressed
>             append anim-frames-block compressed
>         ]
>     ]
>     
>     editor anim-frames-block
>     
> 
> Here's some sample output:
>     
>     
>     anim-frames-block: [64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zCHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4686JjYuP9ys4
>     d8l4blpycrJG8KqYk5uWnp5ukHxqjufmZWdnWxS/OsPJcODoPLtKprUcW9TPLXJT
>     V7LdFZIZuMx/Ll/rrJCkC3NZ1ztd6SpVCG+L363EsXpCTvhmtovzVCWurr7R6jG7
>     rzZarKFpd8XTS77Z1/Xu7Qn+vunr6+/v725rqv6nm/Oj4Or2Ll7jvDUOa8+e6FX3
>     3uYjbPz0fN/RKjbeWcU+Z5do2qfN2lWaelnXfbveKwkz7ytLqu0qBK6Xed1cyfhG
>     TC58xeujhyuF422FXxQeOPybbR1nzbbP18+khtXvu/H95Ns7Gzdv5ZtfaVX64fjZ
>     crf/d6xPvV7XmJ7PZ1/x/ueXm/nXrOfVZKyZ+DL8nt85zhWzqu8LPosvPyYZEdW8
>     QrJjvjdj3TOFJuXQFVEVEl0iC9L49pVJJvZcnR7XLn/w+ux64XUpizrvbF0R1PFx
>     4QvB3s29OxLylB9tW9Cj9+vEol5NLk+5ia7vLB74GvxbETxZRklSqI+HyWNpR7ri
>     VbkJtreOp05nF1O/EeGW9C01/RqjmVrF3l7PZxnfPStv12qxsjBYAwBolvDW2AQA
>     AA==
>     } 64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zMHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4686JjYuP9ys4
>     d8l4blpycrJG8KqYk5uWnp5ukHxqjufmZWdnW6hqBUwQfnxuvkPltxaJLSsuLOTt
>     ZWPdIPzSaal3vZUth6nWhZUsq7NsrUqzQ9f47K17qyWmdW1T2txFsreLdW/Pydu6
>     rXe2mHrsYuf3j86uLn95Z1/Qf6ZnWeUGD2e38V/3WVOh9viYkfzh3Fvmb1Iap+oq
>     P7OUKH64ocH2tsisGfkvTy7nXi6nG/n11dGZzLv3RQt8On3c19zY7e8stbyDCxtf
>     h0rLZBZuKjyYFrv6jsLdZ8xr99lGi3wueRLuGN6+zqSq7MW1700y/hHle4o/PhP8
>     5Xt+397f3z88Pj3ff/++v79/vGdnYbAGAJfEqNM/BAAA
>     } 64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zMHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4686JjYuP9ys4
>     d8l4blri2cIVNC+GU2Hp6elcEX0tnsbLfPpNs++9mTE57fRcyepfJZxfFgUsdNWU
>     s51l8ihoma+8XatU6cOQVaHCca6zQh+GrYvlrWOVnvbgxrzUo/POzrz2JmpuLuu+
>     VuntT+9ML316T3VWuf79HXX/t/GuKTJIPBj5UW7bzB0fko75frwVGzP1ffIRa934
>     tpiQp88O9Zq3q84pL3qwq593uZ621dus61NCJ097K/714b7l3tf1bAv03jfNmv/v
>     264t3wu2Hn0r9973y6uiy2aql235hJeef35hovexONmK8jc3rzapXLeL03r+6cXl
>     1fHn9+39/f3D49Pz/ffv+/v7x+fX98/v3////1NWFgZrALxatNdHBAAA
>     } 64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zMHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4686JjYuP9ys4
>     d8l4blpycrJG8KqYk5uWnp5ukHxKZMWCZWdnSuW+urOSId11nkP+rx6JLS8C2l0n
>     y6XO2PLyUovvXDtTCdNXV5pCl8YtnRn68tq6qOVNX6tKdW4uT+ud5sv9RTt6Xt79
>     Vz3a4Stu7Cq7+OitZ/i7i3tza5n4tCo+3JzWdniTz5oI1cfHNOVXt2pWqp87VaPv
>     LZf1413C3s7pdmKys0rSL88PZGbbe+vzva1rY3+/PV32+sCubRtnnd0rkJdwj/0h
>     0wyemh2p644UC7fl7H778NGh3vO6fKbGX1/f2Jx9/9ze3d/fPzjczSvvv2/Pz88v
>     Lq+Oj7dTYLAGANdbpyswBAAA
>     } 64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zMHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4686JjYuP9ys4
>     d8l4blpycrJG8KqYk5uWnp5ukHxqjufmZWdnWxS/unNy8/Lz8x2auWR/BTVeXOwi
>     Khe7y2Sl47KAiVamXApZV5b4rnWSXbVVO3RB3OF/PN7X1G9usjnfdXdl2dpz2/IK
>     D339VZZ3fVfZ2kdnd5uqx++t+/9tqvaMlWfXh3IrT7sZ/jHxaHim0zWtSqOnM6a9
>     FDtbU26cfkDPvrlNc1dm6kVTb22Lv5alaYfm5C+qu3OrNPfa+tzj13Ijv+XemZzI
>     zv9n+oq7Kye6f9+js2Fz5IFZx4PK+MR+JSy/sTn7/rm9u7+/f3C4m/m7pACDNQAX
>     yZ/iJgQAAA==
>     } 64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zMHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4686JjYuP9ys4
>     d8l4blpycrJG8KqYk5uWendyiezhkdy8zHemsfm9O5LG6m7zHGqjWKRCMo7MY+h4
>     Z/IrYGXwMp65dq2rAl6FrGJbG3fUKuB12DrPvVqs2gFvwlelHZ/ku3qadvSilMP7
>     9kqW653fWvay6ezq67rxS6r/P1qjPWPDg4Nu/N+/rvyh9/iYt7zzNs0So6enpi2M
>     cuuRNLp3qJH/d6hNlEnY+eXS09l6w0qzLq+PPP7s98yy3N2Fp5+dvTtVN78lqf77
>     u5XTi3wfHpYVj5lTnX3xfsHkeDe98qrS11catc/PK7D+/u74fnNpHv19e35+fnF5
>     dfz5fXt/f//w+PR8//37/v5mYGJisAYARqapGj4EAAA=
>     } 64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zMHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4686JjYuP9ys4
>     d8loBjYyMaj5ToqJNHjqOV0zsq/l56RnnjPlcq9t6Zy8+Nx8w+okFq8vywK6XDvl
>     ZGdNeR7Uyb9oUY7X55dH2INX7trCZbr62oIYSa+vv65mRDRHs05rrRR7GLU09+K+
>     v5LmD++sKuW/d3R2+YO4fbUn//G+MV+bsKpF9JzvnSKDx/vbhJ3DTkbo3j5coB2v
>     F72z4MzWubrBbLJWL25fWuZv7/d6y4q0bdMNj6udub7mzYnGuVV+v6qK8k/sl/We
>     l7Nb/+Ojyv5ytX0yFq/2LnRdfW3P79ef515b73/9nFRGSVPJ00c2fXwSf9685y1d
>     7B9ft/fu53ei/f3/5xnVtie8f33//P79wEKATeNBA4tYxoNGDrUVD5p4zF48aBZw
>     00h0ZGRksAYAd264o18EAAA=
>     } 64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zMHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4686JjYuP9ys4
>     d8l4blpycrJG8KqYk5tUvVi5Yia1eG5edqbPtPjSnpWBy/0YDCvDvvwsXh7Q6TL5
>     kI1UYGbQMv65Wq2nAl6FrApd++vIrA8HmRc4smbxni59cH294d46Vu2tOQc3OzDO
>     cc2+ujZiZ9zjc6mvr+hFNGV+/rT31bUX9xuTTybFWllsTFzXI5uv6xO2yXe3m669
>     nrfIxrAzDaLqx9bc2Jx8aVZ90bWcWYZXr6xj39+W++NT4K1VuZ9LeqPfpM2cWHj8
>     ytmQHx/u79b9zSf3e9un5iOth/QkYnd9fHVy/fSydbWl5e8PBbYHLreJ+1Oyv1d1
>     cX5tVe2Li+94t/X7y9b9Wf5y4mx3u5919d/Orr1+s8jyovr9ZFYpjol1XGYvHjQL
>     uGk8bBEJy3jYKpG24mGbTNmLh+0KbRqPOoTYWBisAbfrxM90BAAA
>     } 64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zMHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4686JjYuP9ys4
>     d8l4blpycrJG8KqYk5uWnp5ukHxqjufmZWdnWxRHhRwIfu46z6Hx1xSJLSsuLOTt
>     1XLdFfDy0mIfTqu5t4xfOayKWMt04NRVretrAvc3yWqVrTm/LnqlUuusba9Ct6aL
>     ctQ4mL+9syt3+jHWgO+Nd/fVPXxm88p8Q8y+Gl7/q5Il667sZjp7S0drqm7UHP/T
>     UrJ7LNc/2zFFOXudlNWyG9uzvs6yO1NgEj29V3RXH2/1tzfTthVv9lt52+zdvcXZ
>     zPZ/rb99OKfvLF+vu+d50Xaju3b3bSutnj+fsTx4/sra6pK3N9fed2Op/2uR/OZ5
>     +/pQf7GKiJ37tlb905I3LVw7s//St1W7NgW8f/l1+41qZr6O+MxvjuH3m3jMXjxo
>     FnDTeNgiEpbxsFUibUViGyMjgzUAhlm/D2kEAAA=
>     } 64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zMHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4686JjYuP9ys4
>     d8l4blpycrJGcFnIAgdVr2kGybtEJDernZmpnfsqp9P48bn5tvr/ZKSuPApY4Koo
>     Fzvry8OgZb6Sdq1Sog9DZjJlh/l6mLz2ZeDfU3c3SuClwzQm+RWsC6bqOC7JOrwo
>     Vnv72uht1gfbeK0n6MWtKW/8pbrj2/uI7QU/F9Vmf14XMbfnolxpjWlR3GGbyXZb
>     a3ZufLY619b5H8+vnNRL8z7K6ciWbnG80B7Y3SZrrZF7bVN+ee6q6uKr9/ZFM8/X
>     qfnx7s6xYPGrs+7oPXrWzex83qes6svaa+v/n9OrtUp9fX9ve7j/ux8fP3x61rjY
>     vLZ6b+iNdzsPre/9l5a86itjv21cXGXk5p+Wx+fVM3K9CK15v7MtwZlL74RCAp+b
>     xsMWkbCMh60SaSsetsmUvXjYrtCm8ahDZVrGo06NPFEBBmsAOJHArHoEAAA=
>     } 64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zMHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4a8uKBYvd+6Wd
>     i/54bFp8YjKf9yqTzk2ph6ZqxZ4S4dj87Mw00+J7IjM3Pz/Xa1v674jElecXJrom
>     yq3NKFbwWC4/PSiE68FB5llMay/1aJkuClobLhqyV2pa9vUp8SeZBLjL1t7czDM7
>     S9ViukrMlpCNYj2V5YlB03x/7/uzu3RpQqsjL5tdjYFhyIF8yfehWT82Rmz3VxXf
>     9rvi0+VJs8zdv8lsLYo/NK2b699pqS93r20wLu/lrTbNvbYt3/rcWmv9x5f2prb7
>     1VZbvHxwrPO1n94u8+IzB/XV+/VsTEpfXl5pn+9Xbf3l6b2J1cHP+6psKhc/43zk
>     d99Cs/qrXW17eW3Nl7Jfp1aff17zb2/Rjz8/v8uWMf1aGt/IobbiQROP2YsHzQJu
>     Gg9bRMIyHrZKpK142CZT9uJhu0KbxqMOlWk7Eh0YrAGyBMCKdgQAAA==
>     } 64#{
>     eJxz93SzsEwMZwhn+M4AAg1g3ACmGsCsBjDnPxj/B1P/waz/YM4oGAXDBij+ZAHT
>     OiAClCfYOf4zMHLIeGxYcLCZQ1gr5sSGhYfbBZS95nhsXHS0W8I4686JjYuP9ys4
>     d8l4blpycrJG8KqYk5uWnp5ukHxqjufmZb79XEWvrlROfnRuvn21F4tXSOOFNptu
>     JttVBisuzfURtJsrdfXBleWhnHFLZ5VqX18V18lnImW6JmwT/yamD1ofHG9tZbi0
>     TLV6ytrbOwqeHkrNCtePaiypntX7u+z9rTml7OIxWiZrbhy2kbbm45IsTDrevTDu
>     GM/PgptrkzWj360qefhi9nLH+b09VUa3Z62zPN+zNkLt7fVt+eK21tHf8w40Jv7S
>     Oxv148Pxg73y1898t4h4Pnvh9rh5c9S+XjZbH/5+757K7y/22bc716+Lzn168ln4
>     db/1917kfwvbOH+6/zzLD8ez7p/X9/u1/d+fiEq2+Joe3owHjRxqKx408Zi9eNAs
>     4KbxsEUkLONhq0SaqACDNQAYMLy/ZgQAAA==
>     }]
>     
> 
> And here's an example of how to write the files in that block back to the hard drive and display them in a GUI:
>     
>     
>     ; Write files:
>     
>     count: 1
>     make-dir %./frames/
>     for count 1 length? anim-frames-block 1 [
>         write/binary rejoin [
>             %./frames/ "frame-" count ".gif"
>         ] to-binary decompress pick anim-frames-block count
>     ]
>     
>     ; Create file list, with frames in numerical order:
>     
>     file-list: read %./frames/
>     animation-frames: copy []
>     for count 1 length? file-list 1 [
>         append animation-frames rejoin [
>             %./frames/ "frame-" count ".gif"
>         ]
>     ]
>     
>     ; Display that file list as an animation:
>     
>     view layout [
>         anim: anim rate 10 frames animation-frames
>     ]
>     
> 
> Here's an example that combines the above animated GIF files with normal GUI animation (/offset values adjusted using "for" loops):
>     
>     
>     view center-face layout [
>         size 625x415
>         backcolor black
>         anim: anim rate 10 frames load animation-frames
>         btn "Run Animation" [
>             for counter 0 31 1 [
>                 anim/offset: anim/offset + (as-pair counter 0)
>                 show anim wait .05
>             ]
>             for counter 0 24 1 [
>                 anim/offset: anim/offset + (as-pair 0 counter) 
>                 show anim wait .05
>             ]
>             for counter 0 31 1 [
>                 anim/offset: anim/offset + (as-pair (negate counter) 0)
>                 show anim wait .05
>             ]
>             for counter 0 24 1 [
>                 anim/offset: anim/offset + (as-pair 0 (negate counter))
>                 show anim wait .05
>             ]
>         ]
>     ]
>     

### 8.13 And That's Just the Beginning

> As you learn more about general REBOL coding throughout this text and beyond, you'll improve your ability to design GUI screens that exactly match your creative vision. If you want to create more complex visual layouts, GUI and graphic programming should be the focus of your study. For now, understanding the basic framework and concept of switching between slides, adding graphics, text, animation, sound, etc., along with specific pre-made tools like Carl's show.r script, are more than enough to put together effective presentations.
> 
> Other tools such as the REBOL Flash .swf creator, covered later in this tutorial, provide additional powerful capability for building and distributing presentations.

## 9\. Makedoc And Other Useful REBOL Productivity Tools

> ### 9.1 Makedoc.r - HTML Document Builder

> The show.r presentation script demonstrated earlier is really just a variation of another useful REBOL script called "Makedoc". Makedoc is used to create HTML (web) pages quickly and easily using a simple text markup format. Using minimal character patterns, Makedoc allows users to layout headers, subheaders, numbered lists, images, and other common page elements. Makedoc also automatically generates a hyperlinked table of contents for all topics and subtopics. Here's a short sample of the syntax:
>     
>     
>     
>     Page Title
>     
>         By:  Author Name
>         Some descriptive info about the page.
>     
>     ===Main Section Header
>     
>     Main section text.
>     
>     
>     ---Sub Header
>     
>     Sub section text.
>     
>     # Automatically numbered item 1
>     
>     # Automatically numbered item 2
>     
>     # Automatically numbered item 3
>     
>     Here's how to include an image:
>     
>     =image %image.png
>     
> 
> Save the text above as a file named example.txt, then download and run the makedoc.r script from http://www.rebol.org/library/scripts/makedoc2.r. When prompted, select the example.txt file, and Makedoc will convert it into a nicely formatted HTML page.
> 
> This entire tutorial is actually written in Makedoc format. The source text is available at http://www.re-bol.com/business_programming.txt.
> 
> More information and instructions about how to use Makedoc are available at http://www.rebol.net/docs/makedoc.html.
> 
> Makedoc has been integrated into the Sitebuilder CGI script, so you can create and edit pages on a web site using only a browser, with simple Makedoc syntax. Much more about creating and using web site CGI programs will be covered in depth in later sections of this tutorial.

### 9.2 An Improved Text Editor

> The text "editor" function built into REBOL is very simple. It doesn't even enable undo/redo for when typing mistakes occur. The following version allows for several such useful features. After running the code below, just use the "editor" function is the normal way, and the new features will be added. Notice that the download procedure is wrapped in a block executed by the "attempt" function, just in case an Internet connection is not available:
>     
>     
>     if not exists? %e [
>         attempt [
>             write %e read http://re-bol.com/e
>             do e%
>         ]
>     ]
>     
>     ; editor none
>     
> 
> Here's the program in compressed format, for use in situations where an Internet connection is not available. This script uses Romano Paolo Tenca's undo/redo code to add [ctrl]-z and [ctrl]-y features:
>     
>     
>     REBOL [Title: "Advanced Editor"]
>     do undo: decompress #{
>     789CAD58DD6EA33A10BEA64F61F55C546A85C856DA1BBAE7F441908FE4829358
>     4B2002A709FBF4677E6C6C2034ED9E8DD406EC99F137BF9E49D936565FAC7833
>     4DC5FF8ABBE4D4546D7A50975C7CDB6C3642BC88A66DB4F85B9C9ADA1C8CD595
>     7044AAAA72B13D35A528B6AAD412B913B315AAAE45611A818BE20149418415DB
>     5AED525C7BE59DBDA9B44496C434BDEEAC286BAD3ADACB8849C1527B1C788580
>     02447D7915A5EAB425467798C72CC6871FA2D6CDCEEE5FC55EAB2A0805909D3E
>     B4EF7ABE8EE2C6B75C5865EAB00B9B40209DDE3B6D977A8F2073964C1881CC74
>     BD9D08A2E7DA343AAD4D0F14685D5876A8169495E9ECF00A80BA932608CE5804
>     F0A71E0EEA48E7FF75FFEFAF7BE138E165B8179DF62F27DE49C15824E365DB76
>     42F7E55DD26B2B1EF6A636BBBDC56DA7973B5D646D530FC0422BDAD8BD06BEC3
>     1110455E293032901FDFD8A37B78E7B5DEAACEDB64649992E8A68A0DEE086414
>     4C183E88448C5105E025593F83A77C1627E4ABBB040DEA1DA5DF7503E164BB5A
>     1C6B659AA946B899F57BB3056554338862865F2CF421F74A39551D243AB74F04
>     9790665D5B47A7B36A93631D07F143B2CD01CC6C3C339E4313D44E87384245A5
>     6BAB4456B7A502046D2FECE1887FCFE42D78C845BBDD422CA4B64D1942C4F784
>     2CEE10246052A6F0A988C25648602B981AE9B241FCF80765C243010BB260FC0C
>     9F22525786559DC523BB5195D6B46844A711A481C08C1A447F5647E6F31A8AA3
>     DAE9F474E4EFAA3D7304A5BDF9A57D608F0B39C7103E8AD43B91A3ACDA69513C
>     8BC7F04A64B2D8A0DB0141EEFC098FECDE6BF52E00CCE964B67D48A5A88A70F6
>     2BB0FFF8943B5BCEA3ACEBDAEE152AC48065375448594C934A16CAAE1453E912
>     0E374CB36D193155297ADDC01E59380F8BA47FE6942DF70A20A023482D6F3ABC
>     5360B1C79870856BA4192F113A8C56982445618C808D99C8820CDCEB5A97D657
>     3DF892A14E9CDBAE8A0038AF8395391D58DCE868F02E078CFF7E149B4BFA4D8E
>     AC18283799918979E0B672E058B55A634E5345E7902DDE54F9334590DE37B810
>     12173E1DE6F394A901774C987061C204811D73F8609F009F68C86C94070BC6B0
>     BA64F59C93133CCE70E3490F21A25E1CC67119D3230973ECDB835E155EBCE91D
>     D49614614DCCA0B1775939A180CDAB4CE4128A3576DA95804CE836E0C704AAA1
>     B61002E4685DA5FE2643D48031EA4B92D9D5E26F002F89D33E2677F77F76C462
>     EFD23B848C2B668E56FA1626A20B699C704A2457FB87711374F943AAA3A53FA3
>     FA4241B188EE58ADCFAB02A7E8518F2B7517849DBA6654E5666576747CC984D4
>     A70ABC2EC3AAB737688D8B6D5B9E7A566D6B74CD0695DE321763277A5D31FBA2
>     0636FA8CA11B690C3D115F7245D4B951AB169D862D91A30A8F2470DEB300EDC9
>     DDB6EBD1403226FE8F36D7C3E323C71D550F4C37CEBD217AD948AF1EEA6F4D3F
>     6D500C76545C6A737C6B5557E55916E1A37924A54AB28E6F19D68B7273DB1210
>     3C936CFC20BEA63936F6C39DE6C01B2B0C1DE757A34E73AC2151297A9E35ACAE
>     25A5FA130571B112D59F4EA90F732A61A808C763FC3F5903F68A0CFC024934F6
>     1C91955746552EE761381C6B0787CE5746D464325652A98E67BC519D9D8E134A
>     46D8718CBB0D99CBF0127274F8EFA1BF81CECF95AB08613E5B4407C5D008319A
>     FBA360F9EA0F09B35F0F6410D3DBCE343B671C8453C496087D37CE945FBC24FE
>     D44540FFA56B775D478BF43006E08443F2D9C26BC8D898EF469F1FB3C5B43A5F
>     A6A171AC976C8DAC82AE2E32228D1EF78FF7E30F29530761C71B1B03400BF709
>     CDCDCAB418113EBB4107EAA7CAFA123A853AECFB1000BA0C7FD2D9F0F8488F92
>     47DB9831BBE49E2015C423AFCB1A82AC614DD6907B02963544B2B88CE5938980
>     DAB3F830A221ACDF3F84FA144853F15D5E138220B913FF08E7532077030A4555
>     BF6FCF3E7769C49602AF8D7E80CBF79061648807B85DB7B858DA0BDFC7B4F21F
>     C9601ECC1F140000
>     }
>     base-color: 230.230.255  base-effect: []
>     ctx-edit: mold :ctx-edit
>     changes: [
>         {style tx vtext bold 40x22 font [colors: [0.0.0 200.200.200]]} 
>         {style tx text 40x22 font [colors: [0.0.0 170.170.170]]}
>         {vtext} {text}
>         {btn-enter} {btn} {btn-cancel} {btn} {btn green} {btn} {btn red + 50}
>         {btn}
>         {[tabs: 28 origin: 4x4]}
>         {[tabs: 28 origin: 4x4] with [
>                 undo: []
>                 colors: [254.254.254 255.255.255]
>             ]}
>         {Ctrl-V - paste text}
>         {Ctrl-V - paste text^/^-^-Ctrl-Z - undo^/^-^-Ctrl-Y - redo}
>     ]
>     foreach [original changed] changes [replace/all ctx-edit original changed]
>     ctx-edit: do ctx-edit
>     
> 
> Writing/editing code is _the_ core activity engaged in by programmers, so being able to edit directly with the REBOL interpreter is an essentially useful capability. One benefit of using the simple built in editor is that it operates on any platform supported by REBOL. It works the same way on Windows, Mac, Unix, or other operating systems which may be unfamiliar. The ability to edit scripts provides an instant environment for developing portable software on any OS. The tiny REBOL interpreter is all you need. Metapad (http://liquidninja.com/metapad/download.html) is a great third party editor that can be used for REBOL coding on Windows. Click Options -> Settings -> Primary External Viewer, and set your REBOL path (usually C:\Program Files\rebol\view\rebol.exe).

### 9.3 GUI Builders and Learning Tools

> A primary difference between REBOL and other programming tools is that REBOL tends to require fewer lines of code to accomplish equivalent goals. The GUI dialect is particularly concise compared to other solutions. Typing "view layout [button]" does what requires a page or more of code in other environments. REBOL also has built-in help available for all language constructs. You can search for forgotten functions, look up the syntax of any function or list the content of any object using the "help" function, list all available words using the "what" function, quickly test short bits of code in the console and the text editor, and use the console's auto-complete feature to remember spellings and speed typing. Much more about these and other work enhancing features will be covered later in this tutorial.
> 
> As a result of the inherently simple workflow, most REBOL developers tend to write code using a plain text editor, instead of a bloated integrated development environment ("IDE"). It's generally faster and more effective to keep a copy of the REBOL interpreter open, and simply write REBOL code, than it is to use heavy third party GUI builders to layout interfaces, or to rely on complex IDE features to help remember and manage large APIs. One of the pleasant advantages of REBOL is that it's tiny and instantly installed on any computer. No other tools are required to develop or to distribute REBOL software.
> 
> Nevertheless, it can be helpful to have a few extraneous tools to help learn and explore the language, and to create simple visual layouts without writing code. The following examples are not industry strength applications, but may be useful for quick design and instruction, to speed presentation layout, etc.:
> 
> http://www.rebol.org/view-script.r?script=vid-build.r
> 
> http://www.rebol.org/library/scripts/layout-1.8.r
> 
> http://www.rebol.org/view-script.r?script=rebolide.r

## 10\. Real World Concerns and Examples: Why "Programming" > Office Software

> The programs in this section demonstrate practical, real world examples of how critical company specific features were added to different types of simple applications for managing inventory, payroll, and rent collections.
> 
> You've already seen that by creating GUIs, you can make input forms which enable easy input, create custom output displays, and more. Adding extended functionality such as emailing data files to others and sending data to a web server, for example, require simple one-line scripts in REBOL code. You can also create web and network applications that allow users to access data from any location, and from virtually any web connected device. A programmer's potential ability to simply save data to a web server, for example, alone adds a truly dynamic scope of power and usability beyond what's possible with office apps. With REBOL, web and mobile programming requires very little additional learning overhead and provides a wide range of capabilities that aren't so easily acquired using other tools.
> 
> But that's just the beginning. Another of the great benefits of custom built applications over spreadsheets, for example, is that they allow _perfect control_ over data entry and display. It's easy to check data for errors using simple form validation code, before incorrect data is permanently saved, and only essential categories of values need to be displayed. You can also easily make automated backups of data, so that information is never accidently overwritten or permanently erased. You can ensure that protected fields of data are never touched during data entry, but only viewable and editable when needed. You can choose that user interfaces are cleanly laid out and labeled exactly as you see fit, and insist upon the workflow order in which data is entered. Collections of small data entry routines, reports and other elements of daily work can be collected and run from a core GUI app, data can be saved, read, and shared between each component, and other features automated behind the scenes so that users see and interact with data _exactly_ as needed. Your ability to use code to speed use, reduce error, and perform calculations and manipulations to data are limited entirely to your own interests, abilities, and priorities. Your palette of fine data management controls and powerful tools will continue to grow as you learn more, and the potential features you can enable are limited only by your own experience, insight, and creative effort.

### 10.1 An Expanded Inventory Program

> You've already witnessed how simple it is to create the example inventory program earlier in this tutorial:
>     
>     
>     REBOL [title: "Inventory"]
>     view layout [
>         text "SKU:"
>         f1: field
>         text "Cost:"
>         f2: field "1.00"
>         text "Quantity:"
>         f3: field
>         across
>         btn "Save" [
>             write/append %inventory.txt rejoin [
>                 mold f1/text " " mold f2/text " " mold f3/text newline
>             ]
>             alert "Saved"
>         ]
>         btn "View Data" [editor %inventory.txt]
>     ]
>     
> 
> That application creates a data file which can be easily opened as a spreadsheet in Excel, viewed as text in Word, imported into an Access database, etc. In fact, that program and others so far in this text allow users to accomplish many of the same goals as typical office software. You can get columns of data entered by users, display tables in a visual grid, sort and perform calculations on columns/rows, create charts from the values, (and you can engineer other complex functions as needed), etc. Developing even the simplest custom GUI apps, however, enables greatly increased control over data management.
> 
> Below is an enhanced inventory program which implements a variety of specifically useful features for the environment in which it was used, as well as additional general security features, control over data entry, etc. Read the comments to see all the specialized features that were added:
>     
>     
>     REBOL [title: "Real World Inventory"]
>     
>     ; The script allows for manual editing of data using the "editor"
>     ; function.  The improved editor, from the previous section of this
>     ; tutorial, is added here to enable undo/redo for when typing mistakes
>     ; occur:
>     
>     if not exists? %e [
>         attempt [
>             write %e read http://re-bol.com/e
>             do e%
>         ]
>     ]
>     
>     ; This is stock code that removes the word "REBOL" from the GUI header
>     ; bar in Windows.  This makes the program look more professional.  You
>     ; can copy and use these five lines in any program:
>     
>     tt: "Real World Inventory"
>     user32.dll: load/library %user32.dll
>     gf: make routine![return:[int]]user32.dll"GetFocus"
>     sc: make routine![hw[int]a[string!]return:[int]]user32.dll"SetWindowTextA"
>     so: :show show: func[face][so[face]hw: gf sc hw tt]
>     
>     ; We can choose to automatically create and save to any desired file name
>     ; in any location:
>     
>     make-dir %/c/merchants-inventory/
>     datafile: %/c/merchants-inventory/merchants_mv_inventory.csv
>     write/append datafile ""
>     prcnt: 1.0
>     scanmode: false
>     roundmode: false
>     
>     ; This backup routine is used to automatically save incremental versions
>     ; of the inventory file, so that no changes are ever lost:
>     
>     backup-data3: func [msg] [
>         write (
>             to-file bak-file: replace form datafile "_mv_inventory" rejoin [
>                 "_mv_inventory-backup--"
>                 now/date "_"
>                 replace/all form now/time ":" "-"
>             ]
>         ) read datafile
>         if msg = "msg" [alert (join "Data has been backed up to " bak-file)]
>     ]
>     
>     ; These routines check that appropriate values are entered into the cost
>     ; and quantity fields:
>     
>     check-errors-f2: does [
>         if (
>             (f2/text = "0.0") or (f2/text = "") or
>             (error? try [to-decimal f2/text])
>         ) [
>             alert {
>                 *** ERROR: Enter a decimal in cost field 
>                 (set mode to 'key' if using keyboard).
>             }
>             focus f2 show f2
>             return 0
>         ]
>         return 1
>     ]
>     check-errors-f3: does [
>         if ((f3/text = "") or (error? try [to-integer f3/text])) [
>             alert "*** ERROR: Enter an integer in quantity field." 
>             focus f3 show f3
>             return 0
>         ]
>         return 1
>     ]
>     
>     ; This routine saves the data, and automatically performs a backup.
>     ; Along the way, a common default value is reset in the cost field,
>     ; and the user is notified that the process was successful:
>     
>     enter-item: does [
>         if check-errors-f2 = 0 [return]
>         if check-errors-f3 = 0 [return]
>         backup-data3 ""
>         write/append datafile rejoin [
>             mold f1/text " | "  mold f2/text " | "  
>             mold f3/text " | "  mold f4/text " | " 
>             mold {} " | " mold {} " | " mold {} newline
>         ]
>         request/timeout/ok "Done" 00:00:01
>         set-face f1 ""
>         set-face f2 ".99"
>         set-face f3 ""
>         set-face f4 ""    
>         focus f1
>     ]
>     
>     ; This routine allows the user to manually edit the data file, if desired.
>     ; A backup is made first, just to be safe. Along the way a total inventory
>     ; sum is calculated and displayed, and the data file is checked for
>     ; integrity:
>     
>     view-data: does [
>         backup-data3 ""
>         total: 0
>         inv: read/lines datafile
>         if error? try [
>             foreach line inv [
>                 ln: parse line "|"
>                 line-total: (to-decimal ln/3) * (to-decimal ln/2)
>                 total: total + line-total
>             ]
>             alert join "Total Inventory: $" total 
>         ][
>             alert {
>                 *** ERROR: Improperly formed data in database.  
>                 Check each line.
>             }
>         ]
>         editor datafile
>     ]
>     
>     ; The program provides an option to automatically compute a standard
>     ; margin markup, to figure the wholesale cost of any entered item, based
>     ; upon the scanned retail cost.  These functions enable those
>     ; computations, with appropriate data validation error checks along the
>     ; way:
>     
>     calc-percent: does [
>         if error? try [
>             if scanmode [f2/text: calculate-barcode-price f2/text show f2]
>             f2/text: form (prcnt * (to-decimal f2/text))
>             if roundmode [f2/text: form (round/to (to-decimal f2/text) .01)]
>             show f2
>         ] [alert "*** ERROR: Enter a decimal in cost field."]
>     ]
>     set-percent: does [
>         if error? try [
>             prcnt: to-decimal request-text/title/default
>                 "Default Percent:" form prcnt
>         ] [alert "*** ERROR: Enter a decimal."]
>     ]
>     
>     ; The program allows for prices to either be entered by hand, or to be
>     ; extracted from a specialized bar code format that can be entered by a
>     ; USB scanner.  This allows the user to switch entry modes:
>     
>     scan-mode: does [
>         scanmode: not scanmode
>         either scanmode [
>             b2/text: "Mode: Scan"
>         ] [
>             b2/text: "Mode: Key"
>         ]
>         show b2
>     ]
>     
>     ; This routine allows the user to switch between automatically rounding
>     ; computed wholesale values above, or using exact fractional values:
>     
>     round-mode: does [
>         roundmode: not roundmode
>         either roundmode [
>             b1/text: "Round: On"
>         ] [
>             b1/text: "Round: Off"
>         ]
>         show b1
>     ]
>     
>     ; This routine parses values from the specially encoded barcode price
>     ; data entered with a scanner.  This bar code format is unique to the
>     ; business is which this particular inventory is found (i.e., it could
>     ; not simply be entered into or used directly by a spreadsheet - the
>     ; price data needs to be extracted using a parse computation):
>     
>     calculate-barcode-price: does [
>         scanned-price: to-integer (trim/all copy (at copy f2/text 8))
>         final-price: rejoin [
>             to-string to-integer (
>                  (scanned-price - (scanned-price // 100)) / 100
>             )
>             "."
>             either (scanned-price // 100) < 10 [
>                 rejoin ["0" scanned-price // 100]
>             ] [
>                 scanned-price // 100
>             ]
>         ]
>         final-price
>     ]
>     
>     ; Here's the program's GUI window:
>     
>     view/options center-face layout [
>         size 240x400
>     
>         ; Users can select from specialized item categories found in this
>         ; business, using a quick list choise:
>     
>         text "Item:" [
>             picked-item: request-list "Items" [
>                 "1 - Food" "2 - CVS" "3 - Bread" "4 - Electronics" "5 - Coke"
>                 "6 - Drinks" "7 - " "8 - " "9 - " "10 - "
>             ]
>             f1/text: copy at picked-item (
>                 (index? find/only picked-item " - ") + 3
>             )
>             show f1
>         ]
>     
>         ; All the special routines created earlier are executed by entering
>         ; data into fields, clicking buttons, and otherwise interacting with
>         ; simple widgets:
>     
>         f1: field "Food"
>         text "Cost"
>         f2: field ".99" [calc-percent check-errors-f2]
>         across 
>         btn "%" #"^x" [set-percent]
>         b1: btn "Round: Off" [round-mode]
>         b2: btn "Mode: Key" [scan-mode]  
>         below
>         text "Quantity:"
>         f3: field [check-errors-f3]
>         text "Description:"
>         f4: field
>         text 100 ""
>         across
>         btn 95 "Enter [CTRL+Z]" #"^Z" [enter-item]
>         btn 95 "View Data" [view-data]
>         do [focus f1] 
>     ] [resize]
>     
> 
> This program enables a specialized work flow which is as fast, efficient, and error proof as possible, and it satisfies the _exact_ specifications required to enter data in the unique environment for which it was created. The special modifications are simply additions to the generic inventory program presented at the beginning of the tutorial.

### 10.2 Receipt Printer

> In one of this author's businesses, receipts for rent payments were initially provided using a traditional paper receipt book. This was an error prone process, paper receipts could be damaged and lost, and seaching for information on receipts later was too time consuming. A very quick solution was initially devised by copying all the fields on the paper receipts to a GUI form (similar to the "Generic Text Field Saver" example). That simple program evolved into the following script, which validates correct data entry, requests confirmation before saving, automatically saves audit trail backups, provides simple entry using GUI features such as drop-down selection lists and automatic date/time entry, and displays a nicely formatted text receipt for printing:
>     
>     
>     REBOL [title: "Cash Receipt"]
>     make-dir %/M/merchant/documents/
>     make-dir %/M/merchant/documents/cash_receipts/
>     make-dir %/M/merchant/documents/cash_receipts/history/
>     write/append %/M/merchant/documents/cash_receipts/cash_receipts.txt ""
>     write/append %/M/merchant/documents/cash_receipts.txt ""
>     view center-face layout [
>         across
>         style field field 400
>         text 50 right "Name: "  name: field return
>         text 50 right "Booth: "  booth: field return
>         text 50 right "Amount: "  amount: field "$" return
>         text 50 right "" paytype: drop-down "Cash" "Check" "Credit" "Other"
>             text right 15 "#:" num: field 270 return
>         text 50 right "Signed: "  signed: field return
>         text 50 right "Date"  date: field 400 (form now) return
>         text 50 right "Note: "  note: area "Rent for ..." return
>         indent 405 btn 50 "SAVE" [
>             if error? try [
>                 to-integer booth/text to-money amount/text to-date date/text
>             ][
>                 alert {
>                     ERROR: booth must be a number, amount must be valid money
>                     amount, date must be a date/time in the default format
>                     (1-jan-2011/12:00:00-4:00).  Make sure there are no
>                     additional spaces in the data.  ENTER ANY OTHER
>                     INFORMATION IN THE "NOTE" FIELD.
>                 }
>                 return
>             ]
>             unless true = request "Confirm Save" [return]
>             backup-receipt: rejoin [
>                 %/M/merchant/documents/cash_receipts/history/  
>                 now/date "_" 
>                 replace/all copy form now/time ":" "-"
>                 ".txt"
>             ]
>             write 
>                 backup-receipt 
>                 read %/M/merchant/documents/cash_receipts/cash_receipts.txt
>             write/append 
>                     %/M/merchant/documents/cash_receipts/cash_receipts.txt 
>                     receipt-data: reduce [
>                 newline mold name/text "  "
>                 mold booth/text "  "
>                 mold amount/text "  "
>                 mold paytype/text "  "
>                 mold num/text "  "
>                 mold signed/text "  "
>                 mold date/text "  "
>                 mold note/text "  "
>             ]
>             write/append %/M/merchant/documents/cash_receipts.txt receipt-data
>             cur-receipt: rejoin [
>                 %/M/merchant/documents/cash_receipts/
>                 name/text "_"
>                 now/date "_" 
>                 replace/all copy form now/time ":" "-"
>                 ".txt"
>             ]
>             write/append cur-receipt reduce [
>                 newline newline newline
>                 "             M E R C H A N T S '    R E C E I P T" 
>                 newline
>                 "             ____________________________________"
>                 newline newline newline newline
>                 "      Name:  " name/text "  " newline newline
>                 "     Booth:  " booth/text "  " newline newline
>                 "    Amount:  " amount/text "  " newline newline
>                 "  Pay Type:  " paytype/text "  " newline newline
>                 "    Number:  " num/text "  " newline newline
>                 " Signed by:  " signed/text "  " newline newline
>                 "      Date:  " date/text "  " newline newline
>                 "      Note:  " note/text newline newline newline newline
>                 newline newline newline newline
>                 "             X _____________________________________________"
>                 newline newline newline newline
>                 "             X _____________________________________________"
>             ]
>             alert "This receipt is not valid until signed by both parties!"
>             call/show rejoin ["notepad " to-local-file cur-receipt]
>         ]
>     ]
>     
> 
> Using the data saved by the program above, the script below can be used to produce a report calculating total rent collected between selected dates:
>     
>     
>     REBOL [title: "Total "] 
>     start-date: request-date
>     end-date: request-date
>     receipts: load %/m/merchant/documents/cash_receipts/cash_receipts.txt
>     total: $0
>     foreach [name booth amount type number signed date notes] receipts [
>         date: to-date first parse date "/"
>         if ((date >= start-date) and (date <= end-date)) [
>             ; print name print date
>             total: total + to-money amount
>         ]
>     ]
>     alert form total
>     
> 
> Here is a program that displays the entire rent history for every client, prominently noting those who currently owe rent:
>     
>     
>     REBOL [title: "Rent History and Currently Due Report"]
>     due-dates: copy ""
>     total-money: 0
>     grand-total-monthly: 0
>     booths: load %booths.txt
>     foreach [a b c d e f g] booths [if error? try [
>         append due-dates rejoin ["Booth " a ", " b newline]
>         due-date: copy ""
>         parse g [
>             thru "[" copy due-date to "]"
>         ]
>         due-date: parse due-date " "
>         if not empty? due-date [
>             if error? try [
>                 either now/date >= (current-date: to-date first due-date) [
>                     append due-dates rejoin ["    DUE:  " (form current-date)]
>                     money-is-due: true
>                 ] [
>                     append due-dates rejoin ["    " (form current-date)]
>                     money-is-due: false
>                 ]
>             ] [
>                 append due-dates "    (Invalid Date)"
>             ]
>             if error? try [
>                 current-money: to-money second due-date
>                 grand-total-monthly: grand-total-monthly + current-money
>                 if money-is-due = true [
>                     total-money: total-money + current-money
>                 ]
>                 append due-dates rejoin [
>                     newline "    " (form current-money) newline
>                 ]
>             ] [
>                 append due-dates rejoin [
>                     newline "    (Invalid amount)" newline
>                 ]
>             ]
>         ]
>         append due-dates "-------------------------------------------------^/"
>     ] [alert rejoin ["ERROR: booth " a " " b " " c " " d " " e " " f " " g]] ]
>     append due-dates rejoin [
>         newline newline "Total Due: " total-money
>         newline newline "Total Monthly Rent: " grand-total-monthly
>     ]
>     make-dir %./rent_reports/
>     change-dir %./rent_reports/
>     write report-filename: to-file rejoin [
>         "rent_" now/date "_" (replace/all to-string now/time ":" "-") ".txt"
>     ] due-dates
>     call/show rejoin ["notepad " to-local-file what-dir "\" report-filename]
>     
> 
> Again, what started with a tiny GUI form for saving a few text fields, evolved into a full featured application set. Only a basic understanding of saving files, concatenating and splitting text, using foreach loops, testing for errors, etc., is required to create all of the code above. The report scripts can be integrated back into the main program's GUI window with code this simple (inside the view layout block):
>     
>     
>     btn "Rent Due Report" [launch %rentdue.r]
>     btn "Total Rent Report" [launch %rentcollected.r]
>     

### 10.3 Advanced Time Clock and Automated Payroll Reports

> In the same business as above, a specialized time clock machine with fingerprint validation was initially employed to manage employee payroll and work reports. The software that came with the fingerprint machine was very difficult for managers to use, and the reports it generated were awkward and inadequate for the needs of the business. In order to solve the problem, the following program was created. It simply adds features to the simple "Time Clock" app demonstrated earlier in the tutorial. This version uses an NIST clock script to set the computer's internal clock to the exact correct time (Internet connection is required). To ensure that employees never sign in for others, the program takes a photo of the person performing each signin (the code routine to capture photos is covered later in this text). To enhance security further, a full audit history of every single entry made to the signins, is saved to the hard drive, _and_ each file is _uploaded to the company's web server_. This simple added feature ensures that signin times cannot be tampered with by anyone who doesn't have approved access:
>     
>     
>     REBOL [title: "Time Clock"]
>     insert-event-func [
>         either event/type = 'close [
>             really: request {
>                 To restart this program you must also 
>                 restart the computer.  Really close?
>             }
>             if really = true [quit]
>         ] [event]
>     ]
>     
>     ; Ladislav Mecir's nistclock.r, to ensure the computer's clock
>     ; is set correctly:
>     
>     do decompress #{
>     789C6D544B6FDB300CBEFB57B005861D0ADB49BA6081D7B5971D765977688162
>     087C506D3AD1224B811E09BC61FF7D941C278A13388E2592FAF8FA44CB5B4C0D
>     EA1D6A53C032819A759664459EFB4FCA32C98DCD566A77A17ABFAAF2B2692ABB
>     CC199270B9CA945E5D18644C8974C732D3B52D5ACD2BD566F42665D2C7924A55
>     C024F1B66938078D93958FEFEF33921E9C41B06B6E82DC7225A1551A41351625
>     299804252B042EA1514E83C14AC9DADCFC4B2017AA62028ED0D0FEAE61DD9AA4
>     F4F04E5A2EFC02A2408E4BB88329A97813891E41A05CD9F513D8A896B08CCE4F
>     4B3A249505D45A6932D41D2CA3DC34B21AB6BCDA9C431C11E838FDB64C1BCC99
>     88635F9A0DDF42A5B65D48630E613FA30A6807B7F4041565078BA02298C8EFF4
>     73FEAC76F974315F50665651B92CAE50DF78B0C832EFCDC9C02F6E42B54E5A6A
>     5AA5B4C6D086D443E81D13D4BE62514C62558F22D51E52B872A2EFF649E111E8
>     3913637D4687432F351A276CE85FBFECBDDCC10831F19DBBE2191EBE42CD9B06
>     357AD2F418308A3C906280BFCCEA580D187B2DAE605378A1A7FD36D0DEA6A633
>     16DB8092EEB98C384F5AE8B5A1039ED66F5CD66A6FBE1084755AC2AB76415E31
>     E3AF01185755680C117E59315BAD4B7F072D1EF93F7238B05FD019A092387C82
>     8F1BD412C5FD0C96C3AA00A1589D0BFEAE1991F8C320CF6A21C8C308B480966D
>     2867E52C97C49B70AD82FA405EAB5D65495E96A1B63E111A42D416CF7838BABF
>     7D41FB12CEBDD2B9DB3E9322FC1395FC27FFA32426A765E04E021378781C07D5
>     C774744D8EF7BF90698A66ADB4770CFB1F4ADA752CF8C6BA9FCD1BE266248CB7
>     DFFD9C8941B8741663C94B1842E73642F0C36C3AC94B2A45EDAA9E7121A58E02
>     1CD6AD0F6ED8EC29261AADC3365A867BBBA698CE046D088A44F1653FA9FB5048
>     3DF1ECBC60254DC23D272E1D9A98FB29E5472FA3AC26997F66F3B97F7DE4BDE0
>     3E9BC2B2B8C2EE72B0F894CDAE58086F4183C5D12D9236BE64E7936064D128DD
>     422C0A792561609FB3E00AD661268F2650F91F6BB4707323070000
>     } 
>     make-dir img-dir: %./clock_photos/
>     unless exists? %employees [
>         write %employees {"Nick Antonaccio" "(Add New...)"}
>     ]
>     cur-employee: copy ""
>     avicap32.dll: load/library %avicap32.dll
>     user32.dll: load/library %user32.dll
>     find-window-by-class: make routine! [
>         ClassName [string!] WindowName [integer!] return: [integer!]
>     ] user32.dll "FindWindowA"
>     sendmessage: make routine! [
>         hWnd [integer!] val1 [integer!] val2 [integer!] val3 [integer!]
>         return: [integer!]
>     ] user32.dll "SendMessageA"
>     sendmessage-file: make routine! [
>         hWnd [integer!] val1 [integer!] val2 [integer!] val3 [string!]
>         return: [integer!]
>     ] user32.dll  "SendMessageA"
>     cap: make routine! [
>         cap [string!] child-val1 [integer!] val2 [integer!] 
>         val3 [integer!] width [integer!] height [integer!]
>         handle [integer!] val4 [integer!] return: [integer!]
>     ] avicap32.dll "capCreateCaptureWindowA"
>     log-it: func [inout] [
>         if ((cur-employee = "") or (cur-employee = "(Add New...)")) [
>             alert "You must select your name." return
>         ]
>         if set-system-time nist-corrected-time [nist-correction: 0:0]
>         cur-time: now
>         record: rejoin [
>             newline {[} mold cur-employee 
>             { "} mold cur-time {" "} inout { "]}
>         ]
>         either true = request/confirm rejoin [
>             record " -- IS YOUR NAME AND THE TIME CORRECT?"
>         ] [
>             make-dir %./edit_history/
>             write/append %time_sheet.txt ""
>             write rejoin [
>                 %./edit_history/time_sheet--
>                  "_" now/date "_"
>                  replace/all form now/time ":" "-"
>             ] read %time_sheet.txt
>             write/append %time_sheet.txt record
>             if error? try [
>                 write ftp://user:pass@site.com/public_html/time_sheet.txt
>                     read %time_sheet.txt
>             ] [alert "Error uploading to web site (saved locally)."]
>             alert rejoin [
>                 uppercase copy cur-employee ", YOU ARE " inout "."
>             ]
>         ] [
>             alert "CANCELED"
>             return
>         ]
>         time-filename: copy replace/all copy to-string cur-time "/" "_"
>         time-filename: copy replace/all copy time-filename ":" "+"
>         img-file: rejoin [
>             img-dir 
>             (replace/all copy cur-employee " " "_")
>             "_"
>             time-filename "_" 
>             next find inout " "
>             ".bmp"
>         ]
>         sendmessage cap-result 1085 0 0
>         sendmessage-file cap-result 1049 0 img-file
>         ; call to-rebol-file img-file
>     ]
>     timeclock-report: does [
>         timeclock-start-date: request-date
>         timeclock-end-date: request-date
>         totals: copy ""
>         names: load %employees
>         log: load %time_sheet.txt
>         foreach name names [
>             if name <> "(Add New...)" [
>                 times: copy reduce [name]
>                 foreach record log [
>                     if name = log-name: record/1 [
>                         flag: none
>                         date-time: parse record/2 "/"
>                         log-date: to-date date-time/1
>                         log-time: to-time first parse date-time/2 "-"
>                         if (
>                             (log-date >= timeclock-start-date) and 
>                             (log-date <= timeclock-end-date)
>                         ) [
>                             previous-flag: flag
>                             either record/3 = "CLOCKED IN " [
>                                 flag: true
>                             ] [
>                                 flag: false
>                             ]
>                             either flag <> previous-flag [
>                                 append times log-date
>                                 append times log-time
>                             ] [
>                                 alert rejoin [
>                                     "Duplicate successive IN/OUT entry: "
>                                     name ", " record/2
>                                 ] 
>                             ]
>                         ]
>                     ]
>                 ]
>                 append totals rejoin [name ":" newline]
>                 total-hours: 0
>                 foreach [in-date in-time out-date out-time] (at times 2) [
>                     append totals rejoin [
>                         newline 
>                         "    in: " in-date ", " in-time 
>                         "  out: " out-date ", " out-time "    "
>                     ]
>                     if error? try [
>                         total-hours: total-hours + (out-time - in-time)
>                     ] [
>                         alert rejoin [
>                             "Missing login or Missing logout: " name
>                         ]
>                     ]
>                 ]
>                 append totals rejoin [
>                     newline newline
>                     "    TOTAL HOURS: " total-hours
>                     newline newline newline
>                 ]
>             ]
>         ]
>         write filename: copy rejoin [
>             %timeclock_report-- timeclock-start-date 
>             "_to_" timeclock-end-date ".txt"
>         ] totals
>         call/show rejoin ["notepad " to-local-file filename]
>     ]
>     view/new center-face layout/tight [
>         image 320x240
>         tl1: text-list 320x200 data sort load %employees [
>             cur-employee: value
>             if cur-employee = "(Add New...)" [
>                 write/append %employees mold trim request-text/title "Name:"
>                 tl1/data: sort load %employees show tl1
>             ]
>         ]
>         key #"^~" [
>             del-emp: copy to-string tl1/picked
>             temp-emp: sort load %employees
>             if true = request/confirm rejoin ["REMOVE " del-emp "?"] [
>                 new-list: head remove/part find temp-emp del-emp 1
>                 save %employees new-list
>                 tl1/data: sort load %employees show tl1
>                 alert rejoin [del-emp " removed."]
>             ]
>         ]
>         across
>         btn "Clock IN" [log-it "CLOCKED IN"]
>         btn "Clock OUT" [log-it "CLOCKED OUT"]
>         btn "Report" [timeclock-report]
>         btn "EXIT" [
>             sendmessage cap-result 1205 0 0
>             sendmessage cap-result 1035 0 0
>             free user32.dll   quit
>         ]
>     ]
>     hwnd: find-window-by-class "REBOLWind" 0
>     cap-result: cap "cap" 1342177280 0 0 320 240 hwnd 0
>     sendmessage cap-result 1034 0 0
>     sendmessage cap-result 1077 1 0
>     sendmessage cap-result 1075 1 0
>     sendmessage cap-result 1074 1 0
>     sendmessage cap-result 1076 1 0
>     do-events
>     
> 
> The reports printed by the program above are produced in an easily readable, consistent format. Paychex.com is used to process payroll for the business that uses the script above. Even though the report format is clean, entering payroll figures into the Paychex.com web interface required quite a bit of time each week. In order to speed that process, the following additional script was created. This program enables extremely fast copying and pasting directly into Paychex's custom web interface. The text reports created by the script above can be emailed, copied to the clipboard of any remote machine where the payroll manager is working, and the processed output can be entered instantly into Paychex's web site. Inputting payroll for 30+ employees takes less than a minute, using this script:
>     
>     
>     REBOL [title: "Enter Time Clock Report into Paychex"]
>     dec-time: func [tm] [
>         qq: (to-decimal second q: parse form round/to tm 00:00:60 ":") / 60 
>         write clipboard:// form round/to ((to-decimal q/1) + qq) .01
>     ]
>     data1: copy read clipboard://
>     data2: copy parse/all data1 "^/"
>     foreach line data2 [
>          if line = (trim copy line) [print line]
>          if find line "TOTAL HOURS:" [
>              hours: to-time (last parse line " ")
>              if hours <> none [
>                  dec-time hours
>                  ask "Paste Into Paychex, Then Press [ENTER]..."
>              ]
>          ]
>     ]
>     halt
>     
> 
> The script above is very simple, but such a time saving and error reducing routine would have been impossible to create without custom software coding.
> 
> Here's another little custom report script that can be used to check the entire audit history of all log-ins for any given employee, starting on any given date, to ensure that no entries have been manually changed (this can be used to compare files on the local server, or on the backup web server):
>     
>     
>     REBOL [title: "Payroll Audit History Report"]
>     start: ["John Smith" "18-Mar-2012/8:30:53-4:00" "CLOCKED IN "]
>     current: find/only (load %./time_sheet.txt) start
>     erased: copy []
>     collected: copy []
>     foreach file read %./edit_history/ [
>         if error? try [
>             current-period: find/only (load join %./edit_history/ file) start
>             if current-period <> none [
>                probe length? current-period
>                difs: difference current current-period
>                append collected difs
>             ]
>         ] [print file]
>     ]
>     probe length? current
>     probe length? final: unique collected
>     ask "Done..."
>     editor difference current final
>     halt
>     
> 
> Hopefully, the examples in this section have shed a bit more light on simple ways in which real world custom apps can help maintain data integrity, security, and critically functional customised workflow preferences that are just not possible with generic "office applications" or 1-size-fits-all third party software solutions.

## 11\. More REBOL Language Fundamentals

> This section covers a variety of topics that form a more complete understanding of the basic REBOL language.

### 11.1 Comments

> You've already seen that text after a semicolon and before a new line is treated as a comment (ignored entirely by the interpreter). Multi-line comments can be created by enclosing text in square or curly brackets and simply not assigning a label or function to process it. Since this entire program is just a header and comments, it does nothing:
>     
>     
>     REBOL []
>     ; this is a comment
>     {
>         This is a multi line comment.
>         Comments don't do anything in a program.
>         They just remind the programmer what's happening in the code.
>     }
>     [[
>         This is also a multi line comment.
>         alert "See...  Nothing."
>     ]] 
>     comment [
>         The "comment" function can be used to clarify that the following
>         block does nothing, but it's not necessary.
>     ]
>     

### 11.2 Function Refinements

> Many functions have "refinements" (options separated by "/"):
>     
>     
>     request-text/default "Text"
>     request-text/title  "The /title refinement sets this header text"
>     request-text/title/default  "Name:"  "John Smith"     ; 2 options together
>     request-text/title/offset "/offset repositions the requester" 10x100
>     request-pass/offset/title 10x100 "title" alert "Processing"  ; 2 functions
>     request-file/file %temp.txt          ; default file name
>     request-file/filter ["*.txt" "*.r"]  ; only show .txt and .r files
>     request-file/only  ; limit selection to a single file
>     request-file/save  ; save dialog (instead of open dialog)
>     request-file/save/file/filter %temp.txt ["*.txt" "*.r"]
>     
> 
> Typing "help (function)" in the REBOL interpreter console displays all available refinements for any function.

### 11.3 White Space and Indentation

> Unlike other languages, REBOL does _not_ require any line terminators between expressions (functions, parameters, etc.), and you can insert empty white space (tabs, spaces, newlines, etc.) as desired into code. Notice the use of indentation and comments in the code below. Notice also that the contents of the brackets are spread across multiple lines:
>     
>     
>     alert rejoin [
>         "You chose: "               ; 1st piece of joined data
>         (request "Choose one:")     ; 2nd piece of joined data
>     ]
>     
> 
> The code above works exactly the same as:
>     
>     
>     alert rejoin ["You chose: " request "Choose one:"]
>     
> 
> ONE CAVEAT: parameters for most functions should begin on the same line as the function word. The following example will _not_ work properly because the rejoin arguments' opening brackets need to be on the same line as the rejoin function:
>     
>     
>     alert rejoin                    ; This does NOT work. 
>     [                               ; Put this bracket on the line above.
>         "You chose: "
>         (request "Choose one:")
>     ]
>     
> 
> Blocks often contain other blocks. Such compound blocks are typically indented with consecutive tab stops. _Starting and ending brackets are normally placed at the same indentation level_. This is conventional in most programming languages, because it makes complex code easier to read, by grouping things visually. For example, the compound block below:
>     
>     
>     big-block: [[may june july] [[1 2 3] [[yes no] [monday tuesday friday]]]]
>     
> 
> can be written as follows to show the beginnings and endings of blocks more clearly:
>     
>     
>     big-block: [
>         [may june july] 
>         [ 
>             [1 2 3] 
>             [
>                 [yes no]
>                 [monday tuesday friday]
>             ]
>         ]
>     ]
>     
>     probe first big-block
>     probe second big-block
>     probe first second big-block
>     probe second second big-block
>     probe first second second big-block
>     probe second second second big-block
>     
> 
> Indentation is not required, but it's really helpful.

### 11.4 Multi Line Strings, Quotes, and Concatenation

> Strings of text can be enclosed in quotes or curly brackets:
>     
>     
>     print "This is a string of text."
>     print {
>         Curly braces are used for
>         multi line text strings
>         (instead of quotes).
>     }
>     
>     alert {To use "quotes" in a text string, put them inside curly braces.}
>     alert "You can use {curly braces} inside quotes."
>     alert "'Single quotes' can go inside double quotes..."
>     alert {'...or inside curly braces'}
>     alert {"ANY quote symbol" {can actually be used within} 'curly braces'}
>     alert "In many cases"  alert {curly braces and quotes are interchangable.}
>     
> 
> You can print a carriage return using the word "newline" or the characters ^/
>     
>     
>     print rejoin ["This text if followed by a carriage return." newline]
>     print "This text if followed by a carriage return.^/"
>     
> 
> Clear the console screen using "newpage":
>     
>     
>     prin newpage
>     
> 
> The "rejoin" function CONCATENATES (joins together) values:
>     
>     
>     rejoin ["Hello " "World"]
>     rejoin [{Concatenate } {as } {many items } {as } {you } {want.}]
>     rejoin [request-date {  } request-color {  } now/time {  } $29.99]
>     alert rejoin ["You chose: " request "Choose one:"] ; CASCADE return values
>     join {"Join" only concatenates TWO items } {("rejoin" is more powerful).}
>     print rejoin ["This text is followed by a carriage return." newline]
>     print "This text is also followed by a carriage return.^/"
>     prin {'Prin' } prin {doesn't } prin {print } print {a carriage return.}
>     

### 11.5 More About Variables

> The COLON symbol assigns a value to a word label (a "variable")
>     
>     
>     x: 10
>     print x
>     x: x + 1    ; increment variable by 1 (add 1 to the current value of x)
>     print x
>     y: "hello"  z: " world"
>     
> 
> You can use the "PROBE" function to show RAW DATA assigned to a variable (PRINT formats nice output). Probe is useful for debugging problem code:
>     
>     
>     y: "hello"  z: " world"
>     print rejoin [y z]
>     probe rejoin [y z]   
>     print join y z
>     
> 
> The "prin" function prints values next to each other (without a newline):
>     
>     
>     y: "hello"  z: " world"
>     prin y 
>     prin z
>     
> 
> Variables (word labels) ARE ** NOT ** CASE SENSITIVE:
>     
>     
>     person: "john"
>     print person   print PERSON   print PeRsOn
>     
> 
> You can cascade variable value assignments. Here, all 3 variables are set to "yes ":
>     
>     
>     value1: value2: value3: "yes "
>     print rejoin [value1 value2 value3]
>     
> 
> The "ask" function gets text input from the user. You can assign that input (the return value of the ask function) directly to a variable label:
>     
>     
>     name: ask "Enter your name:  "  
>     print rejoin ["Hello " name]
>     
> 
> You can do the same with values returned from requestor functions:
>     
>     
>     filename: request-file/only
>     alert rejoin ["You chose " filename]
>     osfile: to-local-file filename   ; REBOL uses its own multiplatform syntax
>     to-rebol-file osfile  ; Convert from native OS file notation back to REBOL
>     the-url: http://website.com/subfolder
>     split-path the-url   ; "split-path" breaks any file or URL into 2 parts
>     

### 11.6 Data Types

> REBOL automatically knows how to perform appropriate computations on times, dates, IP addresses, coordinate values, and other common types of data:
>     
>     
>     print 3:30am + 00:07:19                   ; increment time values properly
>     print now                                 ; print current date and time
>     print now + 0:0:30                        ; print 30 seconds from now
>     print now - 10                            ; print 10 days ago
>     $29.99 * 5                                ; perform math on money values
>     $29.99 / 7                                ; try this with a decimal value
>     29.99 / 7
>     print 23x54 + 19x31                       ; easily add coordinate pairs
>     22x66 * 2                                 ;  and perform other coordiante
>     22x66 * 2x3                               ;  math
>     print 192.168.1.1 + 000.000.000.37        ; easily increment ip addresses
>     11.22.33.44 * 9        ; note that each IP segment value is limited to 255
>     0.250.0 / 2       ; colors are represented as tuple values with 3 segments
>     red / 2                    ; so this is an easy way to adjust color values
>     view layout [image picture effect [flip]] ; apply effects to image types
>     x: 12  y: 33  q: 18  p: 7
>     (as-pair x y) + (as-pair q p)  ; very common in graphics apps using coords
>     remove form to-money 1 / 233
>     remove/part form to-time (1 / 233) 6
>     
> 
> REBOL also natively understands how to use URLs, email addresses, files/directories, money values, tuples, hash tables, sounds, and other common values in expected ways, _simply by the way the data is formatted_. You don't need to declare, define, or otherwise prepare such types of data as in other languages - just use them.
>     
>     
>     To determine the type of any value, use the "type?" function:
>     
>     some-text:  "This is a string of text"    ; strings of text go between
>     type? some-text                           ; "quotes" or {curly braces}
>     
>     some-text:  {
>         This is a multi line string of text.
>         Strings are a native data type, delineated by
>         quotes or curly braces, which enclose text.
>         REBOL has MANY other built in data types, all
>         delineated by various characters and text formats.
>         The "type" function returns a value's data type.
>         Below are just a few more native data types:
>     }                                          
>     type? some-text
>     
>     an-integer: 3874904                       ; integer values are just pos-
>     type? an-integer                          ; itive/negative whole numbers
>     
>     a-decimal: 7348.39                        ; decimal numbers are recognized
>     type? a-decimal                           ; by the decimal point
>     
>     web-site: http://musiclessonz.com         ; URLs are recognized by the
>     type? web-site                            ; http://, ftp://, etc.
>     
>     email-address: user@website.com           ; email values are in the
>     type? email-address                       ; format user@somewebsite.domain
>     
>     the-file: %/c/myfile.txt                  ; files are preceded by the %
>     type? the-file                            ; character
>     
>     bill-amount: $343.56                      ; money is preceded by the $
>     type? bill-amount                         ; symbol
>     
>     html-tag: <br>                            ; tags are places between <>
>     type? html-tag                            ; characters
>     
>     binary-info:  #{ddeedd}                   ; binary data is put between
>     type? binary-info                         ; curly braces and preceded by
>                                               ; the pound symbol
>     
>     image: load http://rebol.com/view/bay.jpg ; REBOL can even automatically
>     type? image                               ; recognize the data type of
>                                               ; most common image formats.
>     
>     a-sound: load %/c/windows/media/tada.wav  ; And sounds too!
>     a-sound/type
>     
>     color: red
>     type? color
>     
>     color-tuple: 123.54.212                    
>     type? color-tuple
>     
>     a-character: #"z"                          
>     type? a-character
>     
>     a-word: 'asdf                              
>     type? a-word
>     
> 
> Data types can be specifically "cast" (created, or assigned to different types) using "to-(type)" functions:
>     
>     
>     numbr: 4729                ; The label 'numbr now represents the integer
>                                ;   4729.
>     strng: to-string numbr     ; The label 'strng now represents a piece of
>                                ;   quoted text made up of the characters
>                                ;   "4729".  Try adding strng + numbr, and
>                                ;   you'll get an error.
>     
>     ; This example creates and adds two coordinate pairs.  The pairs are
>     ; created from individual integer values, using the "to-pair" function:
>     
>     x: 12  y: 33  q: 18  p: 7
>     pair1: to-pair rejoin [x "x" y]        ; 12x33
>     pair2: to-pair rejoin [q "x" p]        ; 18x7
>     print pair1 + pair2                    ; 12x33 + 18x7 = 30x40
>     
>     ; This example builds and manipulates a time value using the "to-time"
>     ; function:
>     
>     hour: 3
>     minute: 45
>     second: 00
>     the-time: to-time rejoin [hour ":" minute ":" second]    ; 3:45am
>     later-time: the-time + 3:00:15
>     print rejoin ["3 hours and 15 seconds after 3:45 is " later-time]
>     
>     ; This converts REBOL color values (tuples) to HTML colors and visa versa:
>     
>     to-binary request-color
>     to-tuple #{00CD00}
>     
> 
> Try this list of data type conversion examples:
>     
>     
>     to-decimal 3874904        ; Now the number contains a decimal point
>     to-string http://go.com   ; now the web site URL is surrounded by quotes
>     form web-site             ; "form" also converts various values to string
>     form $29.99
>     alert form $29.99         ; the alert function REQUIRES a string parameter
>     alert $29.99              ; (this throws an error)
>     5 + 6                     ; you can perform math operations with integers
>     "5" + "6"                 ; (error) you can't perform math with strings
>     (to-integer "5") + (to-integer "6")    ; this eliminates the math problem
>     to-pair [12 43]           ; creates a coordinate pair
>     as-pair 12 43             ; a better way to create a coordinate pair
>     to-binary 123.54.212      ; convert a REBOL color value to hex color value
>     to-binary request-color   ; convert the color chosen by the user, to hex
>     to-tuple #{00CD00}        ; convert a hex color value to REBOL color value
>     form to-tuple #{00CD00}   ; covert the hex color value to a string
>     write/binary %floorplan8.pdf debase read clipboard://  ; email attachment
>     
> 
> REBOL has many built-in helper functions for dealing with common data types. Another way to create pair values is with the "as-pair" function. You'll see this sort of pair creation commonly to plot graphics at coordinate points on the screen:
>     
>     
>     x: 12  y: 33  q: 18  p: 7
>     print (as-pair x y) + (as-pair q p)    ; much simpler!
>     
> 
> Built-in network protocols, native data types, and consistent language syntax for reading, writing, and manipulating data allow you to perform common coding chores easily and intuitively in REBOL. Remember to type or paste every example into the REBOL interpreter to see how each function and language construct operates.

### 11.7 Random Values

> You can create random values of any type:
>     
>     
>     random/seed now/time   ; always use this line to get real random values
>     random 50              ; a random number between 0 and 50
>     random 50x100          ; left side is limited to 50, right limited to 100
>     random 222.222.222     ; each segment is limited to #s between 0 and 222
>     random $500
>     random "asdfqwerty"    ; a random mix of the given characters
>     

### 11.8 More About Reading, Writing, Loading, and Saving to and from Varied Sources

> Thoughout this tutorial, you'll see examples of functions that read and write data to "local files", web sites, the system "clipboard", emails, and other data sources. If you're totally new to programming, a quick explanation of that topic and related terms is helpful here.
> 
> It may be familiar that in MS Windows, when you click the "My Computer" (or "Computer") icon on the desktop, you see a list of hard drives, USB flash drives, mapped network drives, and other storage devices attached to the computer:
> 
> Data on your computer's permanent hard drive is organized into a tree of folders (or "directories"), each containing individual files and additional branches of nested folders. In Windows, the root directory of your main hard drive is typically called "C:\". C is the letter name given to the disk, and "\" ("backslash") represents the root folder of the directory tree. The REBOL interpreter is installed, by default, in the folder C:\Program Files\rebol\view\
> 
> When you perform any sort of read, write, save, load, editor or other function that reads and writes data "on your computer", you are working with files on one of the "local" storage devices attached to the computer (as opposed to a folder on web server, email account, etc.). When using read and write functions, the _default_ location for those files, in a default installation of REBOL, is "C:\Program Files\rebol\view\". The following image of a Windows file selector shows the list of files currently contained in that folder on the author's computer:
> 
> In REBOL, the percent character ("%") is used to represent local files. Because REBOL can be used on many operating systems, and because those operating systems all use different syntax to refer to drives, paths, etc., REBOL uses the universal format: %/drive/path/path/.../file.ext . For example, "C:\Program Files\rebol\view\" in Windows is referred to as "%/C/Program%20Files/rebol/view/" in REBOL code. Note that Windows uses backslashes (\\), and REBOL uses forward slashes (/) to refer to folders. REBOL converts the "%" syntax to the appropriate operating system format, so that your code can be written once and used on every operating system, without alteration.
> 
> The list of files in the image above would be written in REBOL as below. Notice the forward slashes at the end of folder names:
>     
>     
>     %data/
>     %desktop/ 
>     %local/ 
>     %public/ 
>     %temp-examples/ 
>     %console_email.r
>     %e 
>     %edit-prefs.r 
>     %r 
>     %read-email-header.r 
>     %rebol.exe 
>     %temp.txt 
>     %user.r 
>     %word-cats.r 
>     %word-defs.r 
>     %wordbrowser.r
>     
> 
> The following 2 functions convert REBOL file format to your operating system's format, and visa versa. This is particularly useful when dealing with files that contain spaces or other characters:
>     
>     
>     print to-local-file %/C/Program%20Files/rebol/view/rebol.exe 
>     print to-rebol-file {C:\Program Files\rebol\view\rebol.exe}
>     
> 
> You can use the "change-dir" (or "cd") function to change folders:
>     
>     
>     change-dir %/c/                     ; changes to the C:\ folder in Windows
>     cd %/c/                             ; "cd" is a shortcut for "change-dir"
>     
> 
> To move "up" a folder from the current directory, use "%../". For example, the following code moves from the default C:\Program Files\rebol\view\ folder, up to C:\Program Files\rebol\, and then to C:\Program Files\:
>     
>     
>     cd %../
>     cd %../
>     
> 
> Refer to the current folder with "%./". You can read a listing of the files in the current folder, like this:
>     
>     
>     read %./
>     probe read %./
>     editor %./
>     
> 
> You can make a new folder within the current folder, using the "make-dir" function. Here are some additional folder functions:
>     
>     
>     make-dir %./newfolder/
>     what-dir 
>     list-dir
>     
> 
> You can rename, copy, and delete files within a folder, using these functions:
>     
>     
>     rename %temp.txt %temp2.txt                             ; change file name
>     write %temp.txt read %temp2.txt                                ; copy file
>     delete %temp2.txt
>     
> 
> The "write" function writes data to a file. It takes two parameters - a file name to write to, and some data to be written:
>     
>     
>     write %name.txt "John Smith"
>     
> 
> The "read" function reads data from a file:
>     
>     
>     read %name.txt
>     
> 
> You can assign variable labels to data that will be written to a file:
>     
>     
>     name: "John Smith"
>     write %name.txt name
>     
> 
> Assign variable labels to data read from a file:
>     
>     
>     loaded-name: read %name.txt
>     print loaded-name
>     
> 
> REBOL's built-in text editor can also read, write, and manipulate text data in files:
>     
>     
>     editor %name.txt
>     
> 
> You can _write data to a web site_ (or any other connected protocol) using the exact same write syntax that is used to write to a file. Writing to a web site "ftp" account requires a username and password:
>     
>     
>     write ftp://user:pass@website.com/folder/test.txt "Text written by REBOL"
>     
> 
> _You can read data straight from a web server, an ftp account, an email account, etc. using the same format_. Many Internet protocols are built right into the REBOL interpreter. They're understood natively, and REBOL knows exactly how to connect to them without any preparation by the programmer:
>     
>     
>     editor http://rebol.com                      ; Reads the content of the
>                                                  ;   document at this URL.
>     editor pop://user:pass@website.com           ; Reads all emails in this
>                                                  ;   POP inbox.
>     editor clipboard://                          ; Reads data that has
>                                                  ;   been copied/pasted to
>                                                  ;   the OS clipboard.
>     print read dns://msn.com                     ; Displays the DNS info
>                                                  ;   for this address.
>     print read nntp://public.teranews.com        ; (Hit the [ESC] key to stop
>                                                  ;   this Usenet listing.)
>     
> 
> NOTE: The editor reads, AND allows you to SAVE EDITS back to the server:
>     
>     
>     editor ftp://user:pass@website.com/public_html/index.html
>     
> 
> Transferring data between devices connected by any supported protocol is easy - _just read and write_:
>     
>     
>     ; read data from a web site, and paste it into the local clipboard:
>     
>     write clipboard:// (read http://rebol.com)   ; afterward, try pasting into
>                                                  ; your favorite text editor
>     
>     ; read a page from one web site, and write it to another:
>     
>     write ftp://user:pass@website2.com (read http://website1.com) 
>     
>     ; again, notice that the "write" function takes TWO parameters
>     
> 
> Sending email is just as easy, using a similar syntax:
>     
>     
>     send user@website.com "Hello"
>     send user@website.com (read %file.txt)       ; sends an email, with
>                                                  ; file.txt as the body
>     
> 
> The "**/binary**" modifier is used to read or write binary (non-text) data. _You'll use read/binary and write/binary to read and write images, sounds, videos and other non-text files_:
>     
>     
>     write/binary %/c/bay.jpg read/binary http://rebol.com/view/bay.jpg
>     
> 
> For clarification, remember that the write function takes two parameters. The first parameter above is "%/c/bay.jpg". The second parameter is the binary data read from http://rebol.com/view/bay.jpg:
>     
>     
>     write/binary (%/c/bay.jpg) (read/binary http://rebol.com/view/bay.jpg)
>     
> 
> The "load" and "save" functions also read and write data, but in the process, _automatically format_ certain data types for use in REBOL. Try this:
>     
>     
>     ; assign the word "picture" to the image "load"ed from a given URL:
>     
>     picture: load http://rebol.com/view/bay.jpg
>     
>     ; save the image to a given file name, and automatically convert it
>     ; to .png format;
>     
>     save/png %/c/picture.png picture
>     
>     ; show it in a GUI window:
>     
>     view layout [image load %/c/picture.png]
>     
> 
> "Load" and "save" are used to conveniently manage certain types of data in formats directly usable by REBOL (blocks, images, sounds, DLLs, certain native data structures, etc. can be loaded and used immediately). You'll use "read" and "write" more commonly to store and retrieve typical types of data, exactly byte for byte, to/from a storage medium, when no conversion or formatting is necessary.
> 
> All these examples and options may currently come across as confusing. If the topic is feels daunting at the moment, simply accept this section as reference material and continue studying the next sections. You'll become much more familiar with reading and writing as you see the functions in use within real examples.

### 11.9 Understanding Return Values and the Order of Evaluation

> In REBOL, you can put as many functions as you want on one line, and _they are all evaluated strictly from left to right_. Functions are grouped together automatically with their required data parameter(s). The following line contains two alert functions:
>     
>     
>     alert "First function" alert "Second function"
>     
> 
> Rebol knows to look for one parameter after the first alert function, so it uses the next piece of data on that line as the argument for that function. Next on the line, the interpreter comes across another alert function, and uses the following text as it's data parameter.
> 
> Simple requester functions don't require any parameters, but like most functions, they RETURN a useful value. Try pasting these functions directly into the REBOL console to see their return values:
>     
>     
>     request-text
>     request-date 
>     request-color
>     request-file
>     request-dir
>     request-pass
>     
> 
> In the following line, the first function, with its refinements "request-pass/offset/title" requires _two parameters_, so REBOL uses _the next two items on the line_ ("10x100" and "title") as its arguments. After that's complete, the interpreter comes across another "alert" function, and uses the following text, "Processing", as its argument:
>     
>     
>     request-pass/offset/title 10x100 "title" alert "Processing"
>     
> 
> **IMPORTANT**: In REBOL, the return values (output) from one function can be used directly as the arguments (input) for other functions. Everything is simply evaluated from left to right. In the line below, the "alert" function takes _the next thing on the line as it's input parameter_, which in this case is _not a piece of data_, but a _function which returns some data_ (the concatenated text returned by the "rejoin" function):
>     
>     
>     alert rejoin ["Hello " "there" "!"]
>     
> 
> To say it another way, the value returned above by the "rejoin" function is passed to (used as a parameter by) the "alert" function. Parentheses can be used to clarify which expressions are evaluated and passed as parameters to other functions. The parenthesized line below is treated by the REBOL interpreter exactly the same as the line above - it just lets you see more clearly what data the "alert" function puts on screen:
>     
>     
>     alert ( rejoin ["Hello " "there" "!"] )
>     
> 
> Perhaps the hardest part of getting started with REBOL is understanding the order in which functions are evaluated. The process can appear to work backwords at times. In the example below, the "editor" function takes the next thing on the line as it's input parameter, and edits that text. In order for the editor function to begin its editing operation, however, it needs a text value to be returned from the "request-text" function. The first thing the user _sees_ when this line runs, therefore, is the text requester. That appears backwards, compared to the way it's written:
>     
>     
>     editor (request-text)
>     
> 
> Always remember that lines of REBOL code are evaluated from left to right. If you use the return value of one function as the argument for another function, the execution of the whole line will be held up until the necessary return value is processed.
> 
> Any number of functions can be written on a single line, with return values cascaded from one function to the next:
>     
>     
>     alert ( rejoin ( ["You chose: " ( request "Choose one:" ) ] ) )
>     
> 
> The line above is typical of common REBOL language syntax. There are three functions: "alert", "rejoin", and "request". In order for the first alert function to complete, it needs a return value from "rejoin", which in turn needs a return value from the "request" function. The first thing the user sees, therefore, is the request function. After the user responds to the request, the selected response is rejoined with the text "You chose: ", and the joined text is displayed as an alert message. Think of it as reading "display (the following text joined together ("you chose" (an answer selected by the user))). To complete the line, the user must first answer the question.
> 
> To learn REBOL, it's essential to first memorize and recognize REBOL's many built-in function words, along with the parameters they accept as input, and the values which they return as output. When you get used to reading lines of code as functions, arguments, and return values, read from left to right, the language will quickly begin to make sense.
> 
> It should be noted that in REBOL, math expressions are evaluated from _left to right_ like all other functions. There is no "order of precedence", as in other languages (i.e., multiplication doesn't automatically get computed before addition). To force a specific order of evaluation, enclose the functions in parentheses:
>     
>     
>     print   10  +  12  /  2      ;  22 / 2 = 11
>     print  (10  +  12) /  2      ;  22 / 2 = 11  (same as without parentheses)
>     print   10  + (12  /  2)     ;  10 + 6 = 16  (force multiplication first)
>     
> 
> REBOL's left to right evaluation is simple and consistent. Parentheses can be used to clarify the flow of code, if ever there's confusion.

### 11.10 More About Conditional Evaluations

> You've already seen the "if" and "either" conditional operations. Math operators are typically used to perform conditional evaluations: = < > <> (equal, less-than, greater-than, not-equal):
>     
>     
>     if now/time > 12:00 [alert "It's after noon."] 
>     
>     either now/time > 8:00am [
>         alert "It's time to get up!"
>     ][
>         alert "You can keep on sleeping."
>     ]
>     
> 
> #### 11.10.1 Switch
> 
> The "switch" evaluation chooses between numerous functions to perform, based on multiple evaluations. Its syntax is:
>     
>     
>     switch/default (main value) [
>         (value 1) [block to execute if value 1 = main value
>         (value 2) [block to execute if value 2 = main value]
>         (value 3) [block to execute if value 3 = main value]
>         ; etc...
>     ] [default block of code to execute if none of the values match]
>     
> 
> You can compare as many values as you want against the main value, and run a block of code for each matching value:
>     
>     
>     favorite-day:  request-text/title "What's your favorite day of the week?"
>     
>     switch/default favorite-day [
>         "Monday"    [alert "Monday is the worst!  The work week begins..."]
>         "Tuesday"   [alert "Tuesdays and Thursdays are both ok, I guess..."]
>         "Wednesday" [alert "The hump day - the week is halfway over!"]
>         "Thursday"  [alert "Tuesdays and Thursdays are both ok, I guess..."]
>         "Friday"    [alert "Yay!  TGIF!"]
>         "Saturday"  [alert "Of course, the weekend!"]
>         "Sunday"    [alert "Of course, the weekend!"]
>     ] [alert "You didn't type in the name of a day!"]
>     
> 
> #### 11.10.2 Case
> 
> You can choose between _multiple evaluations_ of any complexity using the "case" structure. If none of the cases evaluate to true, you can use any true value to trigger a default evaluation:
>     
>     
>     name: "john"
>     case [
>         find name "a" [print {Your name contains the letter "a"}]
>         find name "e" [print {Your name contains the letter "e"}]
>         find name "i" [print {Your name contains the letter "i"}]
>         find name "o" [print {Your name contains the letter "o"}]
>         find name "u" [print {Your name contains the letter "u"}]
>         true [print {Your name doesn't contain any vowels!}]
>     ]
>     
>     for i 1 100 1 [
>         case [
>             (0 = modulo i 3) and (0 = modulo i 5) [print "fizzbuzz"]
>             0 = modulo i 3 [print "fizz"]
>             0 = modulo i 5 [print "buzz"]
>             true [print i]
>         ]
>     ]
>     
> 
> By default, the case evaluation automatically exits once a true evaluation is found (i.e., in the name example above, if the name contains more than one vowel, only the first vowel will be printed). To check all possible cases before ending the evaluation, use the /all refinement:
>     
>     
>     name: "brian" 
>     found: false
>     case/all [
>         find name "a" [print {Your name contains the letter "a"} found: true]
>         find name "e" [print {Your name contains the letter "e"} found: true]
>         find name "i" [print {Your name contains the letter "i"} found: true]
>         find name "o" [print {Your name contains the letter "o"} found: true]
>         find name "u" [print {Your name contains the letter "u"} found: true]
>         found = false [print {Your name doesn't contain any vowels!}]
>     ]
>     
> 
> #### 11.10.3 Multiple Conditions: "and", "or", "all", "any"
> 
> You can check for more than one condition to be true, using the "and", "or", "all", and "any" words:
>     
>     
>     ; first set some initial values all to be true:
>     
>     value1: value2: value3: true
>     
>     ; then set some additional values all to be false:
>     
>     value4: value5: value6: false
>     
>     ; The following prints "both true", because both the first
>     ; condition AND the second condition are true:
>     
>     either ( (value1 = true) and (value2 = true) ) [
>         print "both true"
>     ] [
>         print "not both true"
>     ]
>     
>     ; The following prints "both not true", because the second 
>     ; condition is false:
>     
>     either ( (value1 = true) and (value4 = true) ) [
>         print "both true"
>     ] [
>         print "not both true"
>     ]
>     
>     ; The following prints "either one OR the other is true"
>     ; because the first condition is true:
>     
>     either ( (value1 = true) or (value4 = true) ) [
>         print "either one OR the other is true"
>     ] [
>         print "neither is true"
>     ]
>     
>     ; The following prints "either one OR the other is true"
>     ; because the second condition is true:
>     
>     either ( (value4 = true) or (value1 = true) ) [
>         print "either one OR the other is true"
>     ] [
>         print "neither is true"
>     ]
>     
>     ; The following prints "either one OR the other is true"
>     ; because both conditions are true:
>     
>     either ( (value1 = true) or (value4 = true) ) [
>         print "either one OR the other is true"
>     ] [
>         print "neither is true"
>     ]
>     
>     ; The following prints "neither is true":
>     
>     either ( (value4 = true) or (value5 = true) ) [
>         print "either one OR the other is true"
>     ] [
>         print "neither is true"
>     ]
>     
> 
> For comparisons involving more items, you can use "any" and "all":
>     
>     
>     ; The following lines both print "yes", because ALL comparisons are true.
>     ; "All" is just shorthand for the multiple "and" evaluations:
>     
>     if ((value1 = true) and (value2 = true) and (value3 = true)) [
>         print "yes"
>     ]
>     
>     if all [value1 = true  value2 = true  value3 = true] [
>          print "yes"
>     ]
>     
>     ; The following lines both print "yes" because ANY ONE of the comparisons
>     ; is true. "Any" is just shorthand for the multiple "or" evaluations:
>     
>     if ((value1 = true) or (value4 = true) or (value5 = true)) [
>         print "yes"
>     ]
>     
>     if any [value1 = true  value4 = true  value5 = true] [
>          print "yes"
>     ]
>     

### 11.11 More About Loops

> #### 11.11.1 Forever
> 
> "Loop" structures provide programmatic ways to methodically repeat actions, manage program flow, and automate lengthy data processing activities. You've already seen the "foreach" loop structure. The "forever" function creates a simple repeating loop. Its syntax is:
>     
>     
>     forever [block of actions to repeat]
>     
> 
> The following code uses a forever loop to continually check the time. It alerts the user when 60 seconds has passed. _Notice the "break" function, used to stop the loop_:
>     
>     
>     alarm-time: now/time + :00:60
>     forever [if now/time = alarm-time [alert "1 minute has passed" break]]
>     
> 
> Here's a more interactive version using some info provided by the user. Notice how the forever loop, if evaluation, and alert arguments are indented to clarify the grouping of related parameters:
>     
>     
>     event-name: request-text/title "What do you want to be reminded of?"
>     seconds: to-integer request-text/title "Seconds to wait?"
>     alert rejoin [
>         "It's now " now/time ", and you'll be alerted in " 
>         seconds " seconds."
>     ]
>     alarm-time: now/time + seconds
>     forever [
>         if now/time = alarm-time [
>             alert rejoin [
>                 "It's now "alarm-time ", and " seconds 
>                 " seconds have passed.  It's time for: " event-name
>             ] 
>             break
>         ]
>     ]
>     
> 
> Here's a forever loop that displays/updates the current time in a GUI:
>     
>     
>     view layout [
>         timer: field
>         button "Start" [
>             forever [
>                 set-face timer now/time 
>                 wait 1
>             ]
>         ]
>     ]
>     
> 
> #### 11.11.2 Loop
> 
> The "loop" function allows you to repeatedly evaluate a block of code, a specified number of times:
>     
>     
>     loop 50 [print "REBOL is great!"]
>     
> 
> #### 11.11.3 Repeat
> 
> Like "loop", the "repeat" function allows you to repeatedly evaluate a block of code, a specified number of times. It _additionally_ allows you to specify a counter variable which is automatically incremented each time through the loop:
>     
>     
>     repeat count 50 [print rejoin ["This is loop #: " count]]
>     
> 
> The above code does the same thing as:
>     
>     
>     count: 0
>     loop 50 [
>         count: count + 1
>         print rejoin ["This is loop #: " count]
>     ]
>     
> 
> Another way to write it would be:
>     
>     
>     for i 1 50 1 [print rejoin ["This is loop #: " i]]
>     
> 
> #### 11.11.4 Forall and Forskip
> 
> "Forall" loops through a block, incrementing the marked index number of the series as it loops through:
>     
>     
>     some-names: ["John" "Bill" "Tom" "Mike"]
>     
>     foreach name some-names [print index? some-names]  ; index doesn't change
>     forall some-names [print index? some-names]  ; index changes
>     
>     foreach name some-names [print name]
>     forall some-names [print first some-names] ; same effect as line above
>     
> 
> "Forskip" works like forall, but skips through the block, jumping a periodic number of elements on each loop:
>     
>     
>     some-names: ["John" "Bill" "Tom" "Mike"]
>     forskip some-names 2  [print first some-names]
>     
> 
> #### 11.11.5 While and Until
> 
> The "while" function repeatedly evaluates a block of code while the given condition is true. While loops are formatted as follows:
>     
>     
>     while [condition] [
>         block of functions to be executed while the condition is true
>     ]
>     
> 
> This example counts to 5:
>     
>     
>     x: 1  ; create an initial counter value 
>     while [x <= 5] [
>         alert to-string x 
>         x: x + 1
>     ]
>     
> 
> In English, that code reads:
>     
>     
>     "x" initially equals 1. 
>     While x is less than or equal to 5, display the value of x,
>     then add 1 to the value of x and repeat.
>     
> 
> Some additional "while" loop examples:
>     
>     
>     while [not request "End the program now?"] [
>         alert "Select YES to end the program."
>     ] 
>     ; "not" reverses the value of data received from
>     ; the user (i.e., yes becomes no and visa versa)
>     
>     alert "Please select today's date" 
>     while [request-date <> now/date] [
>         alert rejoin ["Please select TODAY's date.  It's " now/date]
>     ]
>     
>     while [request-pass <> ["username" "password"]] [
>         alert "The username is 'username' and the password is 'password'"
>     ]
>     
> 
> "Until" loops are similar to "while" loops. They do everything in a given block, repeatedly, _until_ the last expression in the block evaluates to true:
>     
>     
>     x: 10
>     until [
>         print rejoin ["Counting down: " x]
>         x: x - 1
>         x = 0
>     ]
>     
> 
> #### 11.11.6 For
> 
> The **for** function can loop through a series of items in a block, just like "foreach", but using a _counted index_. The _for_ syntax reads like this: "Assign a (variable word) to refer to an ordinally counted sequence of numbers, begin counting on a (start number), count to an (end number), skipping by this (step number) [use the variable label to refer to each consecutive number in the count]:
>     
>     
>     REBOL []
>     for counter 1 10 1 [print counter] 
>     for counter 10 1 -1 [print counter] 
>     for counter 10 100 10 [print counter] 
>     for counter 1 5 .5 [print counter] 
>     halt
>     
> 
> REBOL will properly increment any data type that it understands:
>     
>     
>     REBOL []
>     for timer 8:00 9:00 0:05 [print timer] 
>     for dimes $0.00 $1.00 $0.10 [print dimes] 
>     for date 1-dec-2005 25-jan-2006 8 [print date]
>     for alphabet #"a" #"z" 1 [prin alphabet]
>     halt
>     
> 
> You can _pick_ out indexed items from a list, using the incrementally counted numbers in a FOR loop. Just determine the _length_ of the block using the "length?" function:
>     
>     
>     REBOL []
>     months: system/locale/months
>     len: length? months
>     for i 1 len 1 [
>         print rejoin [(pick months i) " is month number " i]
>     ]
>     halt
>     
> 
> This code does the exact same thing as above, using one of the alternate syntaxes instead of "pick":
>     
>     
>     REBOL []
>     months: system/locale/months
>     len: length? months
>     for i 1 len 1 [
>         print rejoin [months/:i " is month number " i]
>     ]
>     halt
>     
> 
> As you've seen, you can pick out consecutive items from a list using counter arithmetic (pick index, pick index + 1, pick index + 2). Within a for structure that uses a _skip_ value, this concept allows you to pick out _columns_ of data:
>     
>     
>     REBOL []
>     months: system/locale/months
>     len: length? months
>     for i 1 len 3 [
>         print rejoin [
>             "Months " i " to " (i + 2) " are:" newline newline
>             (pick months i) newline
>             (pick months (i + 1)) newline
>             (pick months (i + 2)) newline 
>         ]
>     ]
>     halt
>     
> 
> Here's an example that uses an "if" conditional evaluation to print only names that contain a requested string of text. This provides a functional search:
>     
>     
>     REBOL []
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     search-text: request-text/title/default "Search for:" "t"
>     for i 1 length? users 3 [
>         if find/only (pick users i) search-text [
>             print rejoin [
>                 (pick users i) newline
>                 (pick users (i + 1)) newline
>                 (pick users (i + 2)) newline
>             ]
>     
>         ]
>     ]
>     halt
>     
> 
> To clarify the syntactic difference between "for" and "foreach" loops, here is the same program as above, written using foreach:
>     
>     
>     REBOL []
>     users: [
>         "John Smith" "123 Tomline Lane Forest Hills, NJ" "555-1234"
>         "Paul Thompson" "234 Georgetown Pl. Peanut Grove, AL" "555-2345"
>         "Jim Persee" "345 Pickles Pike Orange Grove, FL" "555-3456"
>         "George Jones" "456 Topforge Court Mountain Creek, CO" ""
>         "Tim Paulson" "" "555-5678"
>     ]
>     search-text: request-text/title/default "Search for:" "t"
>     foreach [name address phone] users [
>         if find/only name search-text [
>             print rejoin [
>                 name newline
>                 address newline
>                 phone newline
>             ]
>     
>         ]
>     ]
>     halt
>     
> 
> As you can see, the _for_ loop function is useful in almost the exact same way as _foreach_. It's a bit cryptic, but useful for certain common field selection algorithms which involve non-consecutive fields. You will find that both functions are used in applications of all types that deal with tabular data and lists. You'll see many use cases for each function, as this tutorial progresses - keep your eyes peeled for _for_ and _foreach_.
> 
> The example below uses several loops to alert the user to feed the cat, every 6 hours between 8am and 8pm. It uses a for loop to increment the times to be alerted, a while loop to continually compare the incremented times with the current time, and a forever loop to do the same thing every day, continuously. Notice the indentation:
>     
>     
>     forever [
>         for timer 8:00am 8:00pm 6:00 [
>             while [now/time <= timer] [wait :00:01] 
>             alert rejoin ["It's now " now/time ".  Time to feed the cat."]
>         ]
>     ]
>     

### 11.12 More About Why/How Blocks are Useful

> **IMPORTANT**: In REBOL, blocks can contain mixed data of _ANY_ type (text and binary items, embedded lists of items (other blocks), variables, etc.):
>     
>     
>     some-items: ["item1" "item2" "item3" "item4"]
>     an-image: load http://rebol.com/view/bay.jpg
>     append some-items an-image
>     
>     ; "some-items" now contains 4 text strings, and an image!
>     
>     ; You can save that entire block of data, INCUDING THE BINARY
>     ; IMAGE data, to your hard drive as a SIMPLE TEXT FILE: 
>     
>     save/all %some-items.txt some-items
>     
>     ; to load it back and use it later:
>     
>     some-items: load %some-items.txt
>     view layout [image fifth some-items]
>     
> 
> Take a moment to examine the example above. REBOL's block structure works in a way that is dramatically easy to use compared to other languages and data management solutions (much more simply than most database systems). It's is a very flexible, simple, and powerful way to store data in code! The fact that blocks can hold all types of data using one simple syntactic structure is a fundamental reason it's easier to use than other programming languages and computing tools. You can save/load block code to the hard drive as a simple text file, send it in an email, display it in a GUI, compress it and transfer it to a web server to be downloaded by others, transfer it directly over a point-to-point network connection, or even convert it to XML, encrypt, and store parts of it in a secure multiuser database to be accessed by other programming languages, etc...
> 
> Remember, all programming, and computing in general, is essentially about storing, organizing, manipulating, and transferring data of some sort. REBOL makes working with all types of data very easy - _just put any number of pieces of data, of any type, in between two brackets, and that data is automatically searchable, sortable, storable, transferable, and otherwise usable in your programs_.
> 
> #### 11.12.1 Evaluating Variables in Blocks: Compose, Reduce, Pick and More
> 
> You will often find that you want to refer to an item in a block by its index (position number), as in the earlier 'some-items' example:
>     
>     
>     view layout [image some-items/5]
>     
> 
> You may not, however, always know the specific index number of the data item you want to access. For example, as you insert data items into a block, the index position of the last item changes (it increases). You can obtain the index number of the last item in a block simply by determining the number of items in the block (the position number of the last item in a block is always the same as the total number of items in the block). In the example below, that index number is assigned the variable word "last-item":
>     
>     
>     last-item: length? some-items
>     
> 
> Now you can use that variable to pick out the last item:
>     
>     
>     view layout [image (pick some-items last-item)]
>     
>     ; In our earlier example, with 5 items in the block, the
>     ; line above evaluates the same as:
>     
>     view layout [image (pick some-items 5)]
>     
> 
> You can refer to other items by adding and subtracting index numbers:
>     
>     
>     alert pick some-items (last-item - 4)
>     
> 
> There are several other ways to do the exact same thing in REBOL. The "compose" function allows variables in parentheses to be evaluated and inserted as if they'd been typed explicitly into a code block:
>     
>     
>     view layout compose [image some-items/(last-item)]
>     
>     ; The line above appears to the interpreter as if the following
>     ; had been typed:
>     
>     view layout [image some-items/5]
>     
> 
> The "compose" function is _very useful_ whenever you want to refer to data at variable index positions within a block. The "reduce" function can also be used to produce the same type of evaluation. Function words in a reduced block should begin with the tick (') symbol:
>     
>     
>     view layout reduce ['image some-items/(last-item)]
>     
> 
> Another way to use variable values explicitly is with the ":" format below. This code evaluates the same as the previous two examples:
>     
>     
>     view layout [image some-items/:last-item]
>     
> 
> Think of the colon format above as the opposite of setting a variable. As you've seen, the colon symbol placed _after_ a variable word _sets_ the word to equal some value. A colon symbol placed _before_ a variable word _gets_ the value assigned to the variable, and inserts that value into the code as if it had been typed explicitly.
> 
> You can use the "index?" and "find" functions to determine the index position(s) of any data you're searching for in a block:
>     
>     
>     index-num: index? (find some-items "item4")
>     
> 
> Any of the previous 4 formats can be used to select the data at the determined variable position:
>     
>     
>     print pick some-items index-num
>     print compose [some-items/(index-num)]
>     print reduce [some-items/(index-num)]  
>     ; no function words are used in the block above, so no ticks are required
>     print some-items/:index-num
>     
> 
> Here's an example that displays variable image data contained in a block, using a foreach loop. The "compose" function is used to include dynamically changeable data (image representations), as if that data had been typed directly into the code:
>     
>     
>     photo1: load http://rebol.com/view/bay.jpg
>     photo2: load http://rebol.com/view/demos/palms.jpg
>     
>     ; The REBOL interpreter sees the following line as if all the code
>     ; representing the above images had been typed directly in the block:
>     
>     photo-block: compose [(photo1) (photo2)]
>     
>     foreach photo photo-block [view layout [image photo]]
>     
> 
> For additional detailed information about using blocks and series functions see http://www.rebol.com/docs/core23/rebolcore-6.html.

### 11.13 REBOL Strings

> In REBOL, a "string" is simply a series of characters. If you have experience with other programming languages, this can be one of the sticking points in learning REBOL. REBOL's solution is actually a very powerful, easy to learn and consistent with the way other operations work in the language. Proper string management simply requires a good understanding of list functions. Take a look at the following examples to see how to do a few common operations:
>     
>     
>     the-string: "abcdefghijklmnopqrstuvwxyz"
>     
>     ; Left String:  (get the left 7 characters of the string):
>     
>     copy/part the-string 7
>     
>     ; Right String:  (Get the right 7 characters of the string):
>     
>     copy at tail the-string -7
>     
>     ; Mid String 1:  (get 7 characters from the middle of the string,
>     ; starting with the 12th character):
>     
>     copy/part (at the-string 12) 7
>     
>     ; Mid String 2:  (get 7 characters from the middle of the string,
>     ; starting 7 characters back from the letter "m"):
>     
>     copy/part (find the-string "m") -7
>     
>     ; Mid String 3:  (get 7 characters from the middle of the string,
>     ; starting 12 characters back from the letter "t"):
>     
>     copy/part (skip (find the-string "t") -12) 7
>     
>     ; 3 different ways to get just the 7th character:
>     
>     the-string/7 
>     pick the-string 7
>     seventh the-string
>     
>     ; Change "cde" to "123"
>     
>     replace the-string "cde" "123"
>     
>     ; Several ways to change the 7th character to "7"
>     
>     change (at the-string 7) "7"
>     poke the-string 7 #"7"  ; the pound symbol refers to a single character
>     poke the-string 7 (to-char "7")  ; another way to use single characters
>     print the-string
>     
>     ; Remove 15 characters, starting at the 3rd position:
>     
>     remove/part (at the-string 3) 15
>     print the-string
>     
>     ; Insert 15 characters, starting at the 3rd position:
>     
>     insert (at the-string 3) "cdefghijklmnopq"
>     print the-string
>     
>     ; Insert 3 instances of "-+" at the beginning of the string:
>     
>     insert/dup head the-string "-+ " 3
>     print the-string
>     
>     ; Replace every instance of "-+ " with " ":
>     
>     replace/all the-string "-+ "  " "
>     print the-string
>     
>     ; Remove spaces from a string (type "? trim" to see all its refinements!):
>     
>     trim the-string
>     print the-string
>     
>     ; Get every third character from the string:
>     
>     extract the-string 3
>     
>     ; Get the ASCII value for "c" (ASCII 99):
>     
>     to-integer third the-string
>     
>     ; Get the character for ASCII 99 ("c"):
>     
>     to-char 99
>     
>     ; Convert the above character value to a string value:
>     
>     to-string to-char 99
>     
>     ; Convert any value to a string:
>     
>     to-string now
>     to-string $2344.44
>     to-string to-char 99
>     to-string system/locale/months
>     
>     ; An even better way to convert values to strings:
>     
>     form now
>     form $2344.44
>     form to-char 99
>     form system/locale/months  ; convert blocks to nicely formed strings
>     
>     ; Covert strings to a block of characters:
>     
>     the-block: copy []
>     foreach item the-string [append the-block item]
>     probe the-block
>     
> 
> REBOL's series functions are very versatile. Often, you can devise several ways to do the same thing:
>     
>     
>     ; Remove the last part of a URL:
>     
>     the-url: "http://website.com/path"
>     clear at the-url (index? find/last the-url "/")
>     print the-url
>     
>     ; Another way to do it:
>     
>     the-url: "http://website.com/path"
>     print copy/part the-url (length? the-url)-(length? find/last the-url "/")
>     
> 
> (Of course, REBOL has a built-in helper function to accomplish the above goal, directly with URLs):
>     
>     
>     the-url: http://website.com/path
>     print first split-path the-url
>     
> 
> There are a number of additional functions that can be used to work specifically with string series. Run the following script for an introduction:
>     
>     
>     string-funcs: [
>         build-tag checksum clean-path compress debase decode-cgi decompress
>         dehex detab dirize enbase entab import-email lowercase mold parse-xml
>         reform rejoin remold split-path suffix? uppercase
>     ]    
>     echo %string-help.txt  ; "echo" saves console activity to a file
>     foreach word string-funcs [
>         print "___________________________________________________________^/"
>         print rejoin ["word:  " uppercase to-string word]  print "" 
>         do compose [help (to-word word)]
>     ]
>     echo off
>     editor at read %string-help.txt 4
>     
> 
> See http://www.rebol.com/docs/dictionary.html and http://rebol.com/docs/core23/rebolcore-8.html for more information about the above functions.

## 12\. More Essential Topics

> ### 12.1 Built-In Help and Online Resources

> The "help" function displays required syntax for any REBOL function:
>     
>     
>     help print
>     
> 
> "?" is a synonym for "help":
>     
>     
>     ? print
>     
> 
> The "what" function lists all built-in words:
>     
>     
>     what
>     
> 
> Together, those two words provide a built-in reference guide for the entire core REBOL language. Here's a script that saves all the above documentation to a file. Give it a few seconds to run:
>     
>     
>     echo %words.txt what echo off   ; "echo" saves console activity to a file
>     echo %help.txt
>     foreach line read/lines %words.txt [
>         word: first to-block line
>         print "___________________________________________________________^/"
>         print rejoin ["word:  " uppercase to-string word]  print "" 
>         do compose [help (to-word word)]
>     ]
>     echo off
>     editor at read %help.txt 4
>     
> 
> You can use help to search for defined words and values, when you can't remember the exact spelling of the word. Just type a portion of the word (hitting the _tab_ key will also show a list of words for automatic _word completion_):
>     
>     
>     ? to-         ; shows a list of all built-in type conversions
>     ? reques      ; shows a list of built-in requester functions
>     ? "load"      ; shows all words containing the characters "load"
>     ? "?"         ; shows all words containing the character "?"
>     
> 
> Here are some more examples of ways to search for useful info using help:
>     
>     
>     ? datatype!   ; shows a list of built-in data types
>     ? function!   ; shows a list of built-in functions
>     ? native!     ; shows a list of native (compiled C code) functions
>     ? char!       ; shows a list of built-in control characters
>     ? tuple!      ; shows a list of built-in colors (RGB tuples)
>     ? .gif        ; shows a list of built-in .gif images
>     
> 
> You can view the _source code_ for built-in "mezzanine" (non-native) functions with the "source" function. There is a _huge volume_ of REBOL code accessible right in the interpreter, and all of the mezzanine functions were created by the language's designer, Carl Sassenrath. Studying mezzanine source is a great way to learn more about advanced REBOL code patterns:
>     
>     
>     source help
>     source request-text
>     source view
>     source layout
>     source ctx-viewtop  ; try this:  view layout [image load ctx-viewtop/13]
>     
> 
> The "word browser" script is a useful tool for finding, cross referencing, and learning about all the critical functions in REBOL:
>     
>     
>     write %wordbrowser.r read http://re-bol.com/wordbrowser.r
>     do %wordbrowser.r
>     
> 
> #### 12.1.1 The REBOL System Object, and Help with GUI Widgets
> 
> "Help system" displays the contents of the REBOL system object, which contains many important settings and values. You can explore each level of the system object using path notation, like this:
>     
>     
>     ? system/console/history        ; the current console session history
>     ? system/options
>     ? system/locale/months
>     ? system/network/host-address
>     
> 
> You can find info about all of REBOL's GUI components in "system/view/VID":
>     
>     
>     ? system/view/VID
>     
> 
> The system/view/VID block is so important, REBOL has a built-in short cut to refer to it:
>     
>     
>     ? svv
>     
> 
> You'll find a list of REBOL's GUI widgets in "svv/vid-styles". Use REBOL's "editor" function to view large system sections like this:
>     
>     
>     editor svv/vid-styles
>     
> 
> Here's a script that neatly displays all the words in the above "svv/vid-styles" block:
>     
>     
>     foreach i svv/vid-styles [if (type? i) = word! [print i]]
>     
> 
> Here's a more concise way to display the above widgets, using the "extract" function:
>     
>     
>     probe extract svv/vid-styles 2
>     
> 
> This script lets you browse the object structure of each widget:
>     
>     
>     view layout [
>         text-list data (extract svv/vid-styles 2) [
>             a/text: select svv/vid-styles value
>             show a focus a
>         ]
>         a: area 500x250 
>     ]
>     
> 
> REBOL's GUI layout words are available in "svv/vid-words":
>     
>     
>     ? svv/vid-words
>     
> 
> The following script displays all the images in the svv/image-stock block:
>     
>     
>     b: copy [] 
>     foreach i svv/image-stock [if (type? i) = image! [append b i]]
>     v: copy [] foreach i b [append v reduce ['image i]]
>     view layout v
>     
> 
> The changeable attributes ("facets") available to all GUI widgets are listed in "svv/facet-words":
>     
>     
>     editor svv/facet-words
>     
> 
> Here's a script that neatly displays all the above facet words:
>     
>     
>     b: copy [] 
>     foreach i svv/facet-words [if (not function? :i) [append b to-string i]]
>     view layout [text-list data b]
>     
> 
> Some GUI widgets have additional facet words available. The following script displays all such functions, and their extra attributes:
>     
>     
>     foreach i (extract svv/vid-styles 2) [
>         x: select svv/vid-styles i
>         ; additional facets are held in a "words" block:
>         if x/words [
>             prin join i ": "
>             foreach q x/words [
>                 if not (function? :q) [prin join q " "]
>             ]
>             print ""
>         ]
>     ]
>     
> 
> To examine the function(s) that handle any of the additional facets for the widgets above, type the path to the widget's "words" block, i.e.:
>     
>     
>     svv/vid-styles/TEXT-LIST/words
>     
> 
> For more information on system/view/VID, see http://www.mail-archive.com/rebol-bounce@rebol.com/msg01898.html and http://www.rebol.org/ml-display-message.r?m=rmlHJNC.
> 
> It's important to note that you can SET any system value. Just use a colon, like when assigning variable values:
>     
>     
>     system/user/email: user@website.com
>     
> 
> Familiarity with the system object yields many useful tools.
> 
> #### 12.1.2 Viewtop Resources
> 
> The REBOL desktop that appears by default when you run the view.exe interpreter can be used as a gateway into a world of "Rebsites" that developers use to share useful code. Surfing the public rebsites is a great way to explore the language more deeply. All of the code in the rebol.org archive, and much more, is available on the rebsites. When typing at the interpreter console, the "desktop" function brings up the REBOL desktop (also called the "Viewtop"):
>     
>     
>     desktop
>     
> 
> Click the "REBOL" or "Public" folders to see hundreds of interesting demos and useful examples. Source code for every example is available by right-clicking individual program icons and selecting "edit". You don't need a web browser or any other software to view the contents of Rebsites - the Viewtop and all its features are part of the REBOL executable. You can learn volumes about the REBOL language using _only_ the resources built directly into the 600k interpreter!
> 
> For detailed, categorized, and cross-referenced information about built-in functions, see the REBOL Dictionary rebsite, found in the REBOL desktop folder REBOL->Tools (an HTML version is also available at http://www.rebol.com/docs/dictionary.html).
> 
> #### 12.1.3 Online Documentation, The Mailing List and The AltME Community Forum
> 
> If you can't find answers to your REBOL programming questions using built-in help and resources, the first place to look is http://rebol.com/docs.html. Googling online documentation also tends to provide quick results, since the word "REBOL" is uncommon.
> 
> To ask a question directly of other REBOL developers, you can join the community mailing list by sending an email to _rebol-request@rebol.com_ , with the word _"subscribe"_ in the subject line. Use your normal email program, or just paste the following code into your REBOL interpreter (be sure your email account settings are set up correctly in REBOL):
>     
>     
>     send rebol-request@rebol.com "subscribe"
>     
> 
> You can also ask questions of numerous gurus and regular users in **AltME**, a messaging program which makes up the most active forum of REBOL users around the world. Rebol.org maintains a searchable history of several hundred thousand posts from both the mailing list and AltME, along with a rich script archive. The REBOL user community is friendly, knowledgeable and helpful, and you will typically find answers to just about any question already in the archives. Unlike other programming communities, _REBOL does not have a popular web based support forum_. AltME is the primary way that REBOL developers interact. If you want to speak with others, you must download the AltME program and set up a user account (it's fast and easy to do). Just follow the instructions at http://www.rebol.org/aga-join.r.

### 12.2 Saving and Running REBOL Scripts

> So far in this tutorial, you've been typing or copying/pasting code snippets directly into the REBOL interpreter. As you begin to work with longer examples and full programs, you'll need to save your scripts for later execution. _Whenever you save a REBOL program to a text file, the code must begin with the following bit of header text_:
>     
>     
>     REBOL []
>     
> 
> That header tells the REBOL interpreter that the file contains a valid REBOL program. You can optionally document any information about the program in the header block. The "title" variable in the header block is displayed in the title bar of GUI program windows:
>     
>     
>     REBOL [
>         title:  "My Program"
>         author: "Nick Antonaccio"
>         date:   29-sep-2009
>     ]
>     view layout [text 400 center "Look at the title bar."]
>     
> 
> The code below is a web cam video viewer program. Type in or copy/paste the complete code source below into a text editor such as Windows Notepad or REBOL's built-in text editor (type "editor none" at the REBOL console prompt). Save the text as a file called "webcam.r" on your C:\ drive.
>     
>     
>     REBOL [title: "Webcam Viewer"]
>     
>     ; try http://www.webcam